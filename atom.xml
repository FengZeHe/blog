<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何泽丰的博客</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://fengzehe.github.io/blog/"/>
  <updated>2020-06-12T03:22:03.000Z</updated>
  <id>https://fengzehe.github.io/blog/</id>
  
  <author>
    <name>何泽丰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6异步的解决方案</title>
    <link href="https://fengzehe.github.io/blog/2020/02/27/es6-async/"/>
    <id>https://fengzehe.github.io/blog/2020/02/27/es6-async/</id>
    <published>2020-02-26T23:50:33.000Z</published>
    <updated>2020-06-12T03:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>js经常会遇到一些异步任务（需要经过一段时间或当某个时机到达后才能得到的任务）<br>例如说：</p><ol><li>使用ajax请求服务器，当服务器完成响应后拿到响应结果</li><li>监听按钮是否被点击，当按钮点击后拿到某个文本框的值</li><li>使用setTimeout 等待一段时间，当时间到达后做某些事情</li></ol><a id="more"></a><p>面对这样的场景，JS没有一种标准的模式来进行处理，我们处理这些问题的方式是杂乱的，这就导致了不同的人书写的异步任务代码使用方式不一致。例如说实用第三方库，不知道要传进去多少个参数，或者各种参数放第几位。</p><h3 id="ES6异步处理模型"><a href="#ES6异步处理模型" class="headerlink" title="ES6异步处理模型"></a>ES6异步处理模型</h3><h4 id="ES6将异步场景分为两个阶段和三种状态"><a href="#ES6将异步场景分为两个阶段和三种状态" class="headerlink" title="ES6将异步场景分为两个阶段和三种状态"></a>ES6将异步场景分为两个阶段和三种状态</h4><ol><li>两个场景： unsettled (未决)  settled (已决)</li><li>三种状态： pending (挂起) resolved(完成) rejected (失败)<br><img src="/blog/FengZeHe/2020/02/27/es6-async/scene.png" alt></li></ol><h5 id="当任务处于未决时"><a href="#当任务处于未决时" class="headerlink" title="当任务处于未决时"></a>当任务处于未决时</h5><pre><code>状态一定是pending的，表示任务从开始至拿到结果之间的过程。例如说网络完成了各种配置，发送了请求但还没有收到回复</code></pre><h5 id="当任务处于已决时"><a href="#当任务处于已决时" class="headerlink" title="当任务处于已决时"></a>当任务处于已决时</h5><pre><code>它只能是resolved和reject两种状态之间的一种。例如说拿到或者没拿到数据--&gt; resolved状态 。网络不通畅 --&gt; rejected状态</code></pre><p><strong>我们把从未决推向已决的resolved状态的过程，叫做resolve，从未决推向已决的rejected状态的过程，叫做reject</strong>如下图所示<br><img src="/blog/FengZeHe/2020/02/27/es6-async/image.png" alt></p><h5 id="任务已决后-有了结果"><a href="#任务已决后-有了结果" class="headerlink" title="任务已决后(有了结果)"></a>任务已决后(有了结果)</h5><pre><code>进一步做后续处理，如果任务成功了（resolved）,有后续处理，如果任务失败了（rejected）,仍可能做后续处理</code></pre><p><strong>我们把针对resolved的后续处理称之为thenable，针对rejected的后续处理，称之为catchable</strong><br><img src="/blog/FengZeHe/2020/02/27/es6-async/catchable.png" alt></p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol><li>任务一旦进入已决后，所有企图改变代码任务状态的代码都将失效</li><li>以下代码可以让任务达到rejected 状态<ol><li>调用reject</li><li>代码执行报错</li><li>抛出错误</li></ol></li><li>后续处理函数一定是异步函数，并且放在微队列中</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;js经常会遇到一些异步任务（需要经过一段时间或当某个时机到达后才能得到的任务）&lt;br&gt;例如说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用ajax请求服务器，当服务器完成响应后拿到响应结果&lt;/li&gt;
&lt;li&gt;监听按钮是否被点击，当按钮点击后拿到某个文本框的值&lt;/li&gt;
&lt;li&gt;使用setTimeout 等待一段时间，当时间到达后做某些事情&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>ES6模块化</title>
    <link href="https://fengzehe.github.io/blog/2020/02/23/ES6-modular/"/>
    <id>https://fengzehe.github.io/blog/2020/02/23/ES6-modular/</id>
    <published>2020-02-23T13:20:35.000Z</published>
    <updated>2020-06-18T10:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6的模块化"><a href="#ES6的模块化" class="headerlink" title="ES6的模块化"></a>ES6的模块化</h3><h4 id="模块（module）-一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件"><a href="#模块（module）-一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件" class="headerlink" title="模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件"></a>模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件</h4><a id="more"></a><h4 id="模块化背景"><a href="#模块化背景" class="headerlink" title="模块化背景"></a>模块化背景</h4><p>过去js很难编写大型应用，因为有以下两个问题：</p><ol><li>全局变量污染</li><li>难以管理的依赖关系<br>这些问题，都导致了JS无法进行精细的模块划分，因为精细的模块划分会导致更多的全局污染更加负载的依赖关系，因为功能精细的划分有利于代码重用</li></ol><h4 id="前端的模块化有两个标准："><a href="#前端的模块化有两个标准：" class="headerlink" title="前端的模块化有两个标准："></a>前端的模块化有两个标准：</h4><ol><li>Commonjs</li><li>ES6 Module<br>注意：上面提到的两个均是模块化标准，具体的实现需要依托于JS的</li></ol><h4 id="ConmomJS"><a href="#ConmomJS" class="headerlink" title="ConmomJS"></a>ConmomJS</h4><p>简介：目前，只有node环境才支持CommonJs模块化标准，所以需要先安装node才能使用CommonJS<br>在CommonJS中，浏览器运行的是html页面，并加载页面通过script元素引入js，node.js直接运行某个js文件，该文件被称之为入口文件。node.js遵循ECMAScript标准，但脱离了浏览器环境：<br>你可以在node.js中使用ECMAScript标准的任何语法或api，例如循环，判断，数组，对象等等<br>但不能在node.js中使用浏览器的web api,例如说dom对象，window对象，document对象</p><h5 id="CommonJS标准和使用"><a href="#CommonJS标准和使用" class="headerlink" title="CommonJS标准和使用"></a>CommonJS标准和使用</h5><p>node中的所有代码均在CommonJS下运行，具体规范如下 ：</p><ol><li><p>一个js文件既为一个模块<br>如果一个模块需要暴露依稀额数据或功能给其他模块使用，需要使用代码<code>module.exports = xxx</code> ,该过程称之为模块的导出</p></li><li><p>如果一个模块需要使用另一个模块导出的内容，需要使用代码require(‘模块路径’)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">路径必须以.&#x2F;或..&#x2F;开头</span><br><span class="line">如果模块文件后缀名为  .js 可以省略后缀名</span><br></pre></td></tr></table></figure><p>require 函数中返回的是模块导出的内容,且模块中所有的全局代码产生的变量、函数均不会对全局造成任何污染，仅在模块内使用</p></li><li><p>模块具有缓存，第一次导入模块时会缓存模块的导出，之后再导入同一个模块 会使用之前缓存的结果</p></li></ol><p>有了CommomJS模块化，代码就会形成以下结构：<br><img src="/blog/blog/2020/02/23/ES6-modular/image.png" alt></p><p>原理：node实际上是将模块文件中的代码防止到一个函数环境中执行，可以想象该函数是下面的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function(module)&#123;</span><br><span class="line">    module.exports &#x3D; &#123;&#125;;</span><br><span class="line">    var exports &#x3D; module.exports;</span><br><span class="line">    return module.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h3><blockquote><p>由于种种原因，CommonJS难以在浏览器中实现，因为一直在浏览器端没有合适的模块化标准，直到es6出现。<br>ES6规范了浏览器的模块化标准，一经发布，各大浏览器厂商纷纷在自己的浏览器中实现该规范。</p></blockquote><p>模块的引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在浏览器使用以下方式引入ES6模块文件</span><br><span class="line">&lt;script src &#x3D; &quot;入口文件&quot; type &#x3D; &quot;module&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="标准和使用"><a href="#标准和使用" class="headerlink" title="标准和使用"></a>标准和使用</h4><p>模块的导出分为两种，基本导出和默认导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可以将整个模块的导出想象成一个对象，基本导出导出的是该对象的某个属性，默认导出导出的是该对象的特殊属性default</span><br><span class="line">&#x2F;&#x2F;导出结果：想象成一个对象</span><br><span class="line">&#123;</span><br><span class="line">    a: xxx, &#x2F;&#x2F;基本导出</span><br><span class="line">    b: xxx, &#x2F;&#x2F;基本导出</span><br><span class="line">    default: xxx, &#x2F;&#x2F;默认导出</span><br><span class="line">    c: xxx &#x2F;&#x2F;基本导出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ES6的导出方式："><a href="#ES6的导出方式：" class="headerlink" title="ES6的导出方式："></a>ES6的导出方式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export var a &#x3D; 1 &#x2F;&#x2F;基本导出 a &#x3D; 1</span><br><span class="line">export var b &#x3D; function()&#123;&#125; &#x2F;&#x2F;基本导出 b &#x3D; function()&#123;&#125;</span><br><span class="line">export function method()&#123;&#125;  &#x2F;&#x2F;基本导出 method &#x3D; function()&#123;&#125;</span><br><span class="line">var c &#x3D; 3;</span><br><span class="line">export &#123;c&#125; &#x2F;&#x2F;基本导出 c &#x3D; 3</span><br><span class="line">export &#123; c as temp &#125; &#x2F;&#x2F;基本导出 temp &#x3D; 3</span><br><span class="line"></span><br><span class="line">export default 3 &#x2F;&#x2F;默认导出 default &#x3D; 3</span><br><span class="line">export default function()&#123;&#125; &#x2F;&#x2F;默认导出 default &#x3D; function()&#123;&#125;</span><br><span class="line">export &#123; c as default &#125; &#x2F;&#x2F;默认导出 default &#x3D; 3</span><br><span class="line">export &#123;a, b, c as default&#125; &#x2F;&#x2F;基本导出 a&#x3D;1, b&#x3D;function()&#123;&#125;, 默认导出 default &#x3D; 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">绝大部分时间写代码使用的导出方式是 export default()&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="ES6模块的导入："><a href="#ES6模块的导入：" class="headerlink" title="ES6模块的导入："></a>ES6模块的导入：</h4><p>使用以下的代码导入模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;a,b&#125; from &quot;模块路径&quot;   &#x2F;&#x2F;导入属性 a、b，放到变量a、b中</span><br><span class="line">import &#123;a as temp1, b as temp2&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性a、b，放到变量temp1、temp2 中</span><br><span class="line">import &#123;default as a&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default，放入变量a中，default是关键字，不能作为变量名，必须定义别名</span><br><span class="line">import &#123;default as a, b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default、b，放入变量a、b中</span><br><span class="line">import c from &quot;模块路径&quot;  &#x2F;&#x2F;相当于 import &#123;default as c&#125; from &quot;模块路径&quot;</span><br><span class="line">import c, &#123;a,b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;相当于 import &#123;default as c, a, b&#125; from &quot;模块路径&quot;</span><br><span class="line">import * as obj from &quot;模块路径&quot; &#x2F;&#x2F;将模块对象放入到变量obj中</span><br><span class="line">import &quot;模块路径&quot; &#x2F;&#x2F;不导入任何内容，仅执行一次模块</span><br></pre></td></tr></table></figure><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>导入模块时，注意以下细节</p><ol><li>ES6 module 采用依赖预加载模式，所有模块导入代码均会提升到代码顶部</li><li>不能将导入代码放置到判断、循环中</li><li>导入的内容放置到常量中，不可更改</li><li>ES6 module 使用了缓存，保证每个模块仅加载一次</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ES6的模块化&quot;&gt;&lt;a href=&quot;#ES6的模块化&quot; class=&quot;headerlink&quot; title=&quot;ES6的模块化&quot;&gt;&lt;/a&gt;ES6的模块化&lt;/h3&gt;&lt;h4 id=&quot;模块（module）-一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件&quot;&gt;&lt;a href=&quot;#模块（module）-一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件&quot; class=&quot;headerlink&quot; title=&quot;模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件&quot;&gt;&lt;/a&gt;模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件&lt;/h4&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>当在浏览器输入一个地址发生了什么</title>
    <link href="https://fengzehe.github.io/blog/2020/02/15/when-Enter-an-address/"/>
    <id>https://fengzehe.github.io/blog/2020/02/15/when-Enter-an-address/</id>
    <published>2020-02-15T02:28:28.000Z</published>
    <updated>2020-06-18T10:14:03.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="过程是这样的："><a href="#过程是这样的：" class="headerlink" title="过程是这样的："></a>过程是这样的：</h4><ol><li><p>浏览器将url地址补充完整，如果没有写协议就自动添加上协议（http： / https：）</p><a id="more"></a></li><li><p>浏览器对url地址进行url编码，如果url地址中出现了非ASCII字符，浏览器则会对其进行编码</p><ol><li>例如说在浏览器中搜索”王思聪”，汉字会被编码成ASCII码</li></ol></li><li><p>浏览器构造一个没有消息体的GET请求，发送至服务器，等待服务器响应（此时浏览器标签应该有一个等等的图标–转圈）</p></li><li><p>服务器收到请求，将一个HTML页面代码组装到消息体中（不一定要html文件）响应给浏览器</p></li><li><p>浏览器拿到服务器的响应后，丢弃当前的页面，开始渲染消息体的HTML代码。浏览器之所以知道这是一个HTML代码，是因为服务器的响应头指定了消息类型为text/html</p></li><li><p>浏览器在渲染页面的过程中发现有嵌入的资源如CSS,JS图片等</p></li><li><p>浏览器使用不阻塞的渲染方式，重定向服务器发送该资源的请求，拿到响应结果后根据Content-Type做响应处理</p></li><li><p>当所有资源已经下载并处理好后，浏览器出发window.onload事件</p></li></ol><p>   这里说的Content-Tpye是在http协议消息头中表示具体请求中的媒体类型信息</p><p>   有一下几种类型：</p><p>   <img src="/blog/blog/2020/02/15/when-Enter-an-address/content-type.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;过程是这样的：&quot;&gt;&lt;a href=&quot;#过程是这样的：&quot; class=&quot;headerlink&quot; title=&quot;过程是这样的：&quot;&gt;&lt;/a&gt;过程是这样的：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;浏览器将url地址补充完整，如果没有写协议就自动添加上协议（http： / https：）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>实现一个简单的VUE</title>
    <link href="https://fengzehe.github.io/blog/2020/02/12/vue-demo-1/"/>
    <id>https://fengzehe.github.io/blog/2020/02/12/vue-demo-1/</id>
    <published>2020-02-12T00:33:19.000Z</published>
    <updated>2020-06-18T10:14:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实现的效果</p></blockquote><div style="position: relative; width: 100%; height: 100%; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=82283147&cid=140781854&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>​    实现一个简单的vue函数，包括双向数据绑定，数据的响应式</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>1. 首先想到要实现vue的数据绑定，根据vue的双向数据绑定，把{{xxx}} 与data{}里面的值进行绑定。将值绑定后，我们想到要将这些数据渲染出来，这里就需要知道页面的各个节点与各节点的子节点 2. 再到数据响应模块，使用object.defineProperty来实现数据的响应式，用get方法来读取属性的值，用set方法来写入属性的值，以此来实现数据绑定 3. 最后为Vue添加构造函数，例如说this.$el 来表示绑定的元素，$data来表示绑定的数据，$vnode代表虚拟节点</code></pre><h3 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h3><ol><li>编译模块</li><li>虚拟节点模块</li><li>渲染模块</li><li>数据响应模块</li><li>VUE构造函数模块</li></ol><h3 id="编译模块"><a href="#编译模块" class="headerlink" title="编译模块"></a>编译模块</h3><blockquote><p>提供一个compile函数，将一个模板文本(数据)和环境对象（DOM节点）编译成一个结果<br>思想：</p></blockquote><ol><li>使用正则表达式匹配到html代码中包含 括号 的字符串</li><li>拿到字符串之后把两边括号替换掉，把表达式分割成数组</li><li>这需要与envObj环境变量进行配合使用，绑定后变成一个数组</li></ol><p><img src="/blog/blog/2020/02/12/vue-demo-1/1.png" alt></p><blockquote><p>compile.js 代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过程： 先拿到&#123;&#123;xxx&#125;&#125;里面的字符串，然后再对字符串进行加工</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFragments</span>(<span class="params">template</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> matches = template.match(<span class="regexp">/&#123;&#123;[^&#125;]+&#125;&#125;/g</span>); <span class="comment">//万一有人的用户名叫12&#125;  所以这里要处理一下</span></span><br><span class="line">    <span class="keyword">return</span> matches || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">fragment, envObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> exp = fragment.replace(<span class="string">"&#123;&#123;"</span>, <span class="string">""</span>).replace(<span class="string">"&#125;&#125;"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">var</span> props = exp.split(<span class="string">"."</span>);<span class="comment">//将表达式分割为属性数组</span></span><br><span class="line">    <span class="keyword">var</span> obj = envObj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">        obj = obj[props[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template, envObj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 提取模板中的&#123;&#123;&#125;&#125;</span></span><br><span class="line">    <span class="keyword">var</span> flags = getFragments(template);</span><br><span class="line">    <span class="keyword">var</span> result = template;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; flags.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> flag = flags[i];</span><br><span class="line">        result = result.replace(flag, getValue(flag, envObj))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM:"></a>虚拟DOM:</h3><blockquote><p>提供一个函数createVNode,根据提供真实的DOM，构建一个虚拟DOM树<br>思想：</p></blockquote><ol><li>需要创建虚拟DOM 以便以后操作数据</li><li>需要判断真实节点是否为文本节点，如果是就要记录到虚拟节点</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">VNode</span>(<span class="params">realDom, template</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// node 构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.realDom = realDom;</span><br><span class="line">    <span class="keyword">this</span>.template = template;</span><br><span class="line">    <span class="keyword">this</span>.children = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createVNode</span>(<span class="params">realDom</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> root = <span class="keyword">new</span> VNode(realDom, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (realDom.nodeType === Node.TEXT_NODE) &#123;</span><br><span class="line">        root.template = realDom.nodeValue;</span><br><span class="line">        <span class="comment">// 判断真实节点是否为文本节点，如果是，就要记录到虚拟节点</span></span><br><span class="line">        <span class="comment">// 文本节点代表的数字是3</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i  = <span class="number">0</span>; i&lt; realDom.childNodes.length;i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> childNode = realDom.childNodes[i];</span><br><span class="line">            <span class="keyword">var</span> vNode = createVNode(childNode)</span><br><span class="line">            root.children.push(vNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染模块"><a href="#渲染模块" class="headerlink" title="渲染模块"></a>渲染模块</h3><blockquote><p>用于提取虚拟节点，将其模板编译结果设置到真实的dom中，对虚拟节点的子节点也做同样的操作<br><img src="/blog/blog/2020/02/12/vue-demo-1/vnode.png" alt></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> compile <span class="keyword">from</span> <span class="string">"./compile.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染一个虚拟节点（将文本的虚拟节点进行编译）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, envObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode.realDom.nodeType === Node.TEXT_NODE) &#123;</span><br><span class="line">        vnode.realDom.nodeValue = compile(vnode.template, envObj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vnode.children.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> childNode = vnode.children[i];</span><br><span class="line">            render(childNode, envObj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据响应模块"><a href="#数据响应模块" class="headerlink" title="数据响应模块"></a>数据响应模块</h3><blockquote><p>主要负责将原始对象的数据附加到代理对象上，代理对象能够监听到数据的更改，当数据发生改变时，执行某个回调函数(就可以实现数据响应)</p></blockquote><ol><li><p>使用Object.defineProperty来实现数据的响应式</p></li><li><p>这里有一个关键是当代理一个对象是，发现对象里面还有属性没法代理。这时候就要重新申请一个新的代理（如下图）</p></li></ol><p><img src="/blog/blog/2020/02/12/vue-demo-1/newTarget.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将原始对象的prop属性添加到代理对象中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyProp</span>(<span class="params">originalObj, targetObj, prop, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> originalObj[prop] === <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="comment">// 要代理的属性是一个对象,对象要单独处理</span></span><br><span class="line">        <span class="keyword">var</span> newTarget = &#123;&#125;;<span class="comment">//新的 要代理的对象</span></span><br><span class="line">        createResponsive(originalObj[prop], newTarget, callback);</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(targetObj,prop,&#123;</span><br><span class="line">            <span class="keyword">get</span>:function()&#123;</span><br><span class="line">                <span class="keyword">return</span> newTarget;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>:function(value)&#123;</span><br><span class="line">                originalObj[prop] = value;</span><br><span class="line">                newTarget = value;</span><br><span class="line">                callback &amp;&amp; callback(prop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(targetObj, prop, &#123;</span><br><span class="line">            <span class="keyword">get</span>: function () &#123;</span><br><span class="line">                <span class="keyword">return</span> originalObj[prop];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>: function (value) &#123;</span><br><span class="line">                originalObj[prop] = value;</span><br><span class="line">                callback &amp;&amp; callback(prop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将原始对象的属性，提取到代理对象中</span></span><br><span class="line"><span class="comment">// org是原始对象， target是代理对象 当代理对象被赋值的时候要调用回调函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createResponsive</span>(<span class="params">originalObj, targetObj, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> originalObj) &#123;</span><br><span class="line">        proxyProp(originalObj, targetObj, prop, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为vue写一个构造函数"><a href="#为vue写一个构造函数" class="headerlink" title="为vue写一个构造函数"></a>为vue写一个构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createVNode <span class="keyword">from</span> <span class="string">'./vnode.js'</span></span><br><span class="line"><span class="keyword">import</span> createResponsive <span class="keyword">from</span> <span class="string">'./dataResponsive.js'</span></span><br><span class="line"><span class="keyword">import</span> render <span class="keyword">from</span> <span class="string">'./render.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">vue</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$el = option &amp;&amp; option.el;</span><br><span class="line">    <span class="keyword">this</span>.$data = option &amp;&amp; option.data;</span><br><span class="line">    <span class="keyword">this</span>.$vnode = createVNode(<span class="built_in">document</span>.querySelector(<span class="keyword">this</span>.$el))</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    createResponsive(<span class="keyword">this</span>.$data, <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 重新渲染</span></span><br><span class="line">        that.render();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.render()<span class="comment">//初次渲染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vue.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    render(<span class="keyword">this</span>.$vnode, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在前端页面写一个简单的VUE结构"><a href="#在前端页面写一个简单的VUE结构" class="headerlink" title="在前端页面写一个简单的VUE结构"></a>在前端页面写一个简单的VUE结构</h3><blockquote><p>在前端页面写一个简单的VUE结构，测试一下是否正确</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"./vue/index.js"</span></span><br><span class="line">        <span class="built_in">window</span>.vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">"#app"</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                name:<span class="string">"FengZe"</span>,</span><br><span class="line">                age:<span class="number">16</span>,</span><br><span class="line">                addr:&#123;</span><br><span class="line">                    province:<span class="string">"广东"</span>,</span><br><span class="line">                    city:<span class="string">"佛山"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="大概就是这样实现的了"><a href="#大概就是这样实现的了" class="headerlink" title="大概就是这样实现的了."></a>大概就是这样实现的了.</h4><blockquote><p>源码地址：<a href="https://github.com/FengZeHe/vue_demo" target="_blank" rel="noopener">https://github.com/FengZeHe/vue_demo</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;实现的效果&lt;/p&gt;
&lt;/blockquote&gt;


&lt;div style=&quot;position: relative; width: 100%; height: 100%; padding-bottom: 75%;&quot;&gt;
    &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=82283147&amp;cid=140781854&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;
&lt;/div&gt;


&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;​    实现一个简单的vue函数，包括双向数据绑定，数据的响应式&lt;/p&gt;
    
    </summary>
    
    
      <category term="demo" scheme="https://fengzehe.github.io/blog/categories/demo/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="vue" scheme="https://fengzehe.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简单的ofo微信小程序</title>
    <link href="https://fengzehe.github.io/blog/2020/01/10/ofo_demo/"/>
    <id>https://fengzehe.github.io/blog/2020/01/10/ofo_demo/</id>
    <published>2020-01-10T02:03:40.000Z</published>
    <updated>2020-06-18T10:16:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实现的效果</p></blockquote><div style="position: relative; width: 100%; height: 100%; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=82787506&cid=141641375&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><a id="more"></a><p>实现功能简介：</p><ol><li>扫码骑车记时功能</li><li>用户登录及充值功能</li><li>用户报障功能</li></ol><p>思路：</p><ol><li>要实现这些功能，首先要设置一个首页，首页里面包含所有功能按钮，包括回到当前定位，立即用车，单车报障及个人用户按钮</li><li>回到当前定位功能直接调用this.movetoCenter()函数</li><li>立即用车功能;调用扫码接口获取开锁密码与当前单车编号，完事进入开锁界面并在90秒后跳转到计费页面并开始记录用户当前开始用车时间。<ol><li>不过这里需要注意的是在计费中页面，用户仍然可以切换到首页地图，再次点击扫码用车的时候直接进入计费页面。<img src="/blog/blog/2020/01/10/ofo_demo/2020/01/10/ofo_demo/ride_logic.png" class title="是这个意思"></li><li>因为切回首页是把计费页面放在后台,所以使用navtgateTo()方法，而不是使用redirectTo()方法。</li></ol></li><li>单车报障功能<ol><li>这里要说一嘴的是故障类型跟上传照片是必填，要验证内容是否为空。这里我只是判断了input框中的长度是否大于0；</li><li>上传照片这里调用了微信的chooseImage()接口；我使用了一个数组存储上传的照片，所以在删除的时候直接在数组干掉就好了。</li></ol></li><li>用户登录及充值功能<ol><li>用户登录这里要注意下微信新版本是要授权，在按钮处设置open-type 为 getUserInfo才能使用。</li><li>另外我把用户数据存进了storage,这样处理下一次就可以自动登录了。同时在登出的时候也会删除storage.</li></ol></li></ol><blockquote><p>关于后台：<br>    因为时间<del>（技术）</del>问题暂时没有做出来，后续版本就有了嘿。因此这次我在modeHttp在线mock了后台数据。</p></blockquote><blockquote><p>源码地址：<a href="https://github.com/FengZeHe/ofo_demo" target="_blank" rel="noopener">https://github.com/FengZeHe/ofo_demo</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;实现的效果&lt;/p&gt;
&lt;/blockquote&gt;


&lt;div style=&quot;position: relative; width: 100%; height: 100%; padding-bottom: 75%;&quot;&gt;
    &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=82787506&amp;cid=141641375&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="demo" scheme="https://fengzehe.github.io/blog/categories/demo/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="微信小程序" scheme="https://fengzehe.github.io/blog/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/12/14/spring/"/>
    <id>https://fengzehe.github.io/blog/2019/12/14/spring/</id>
    <published>2019-12-14T12:40:13.000Z</published>
    <updated>2020-06-18T10:16:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring学习笔记"><a href="#Spring学习笔记" class="headerlink" title="Spring学习笔记"></a>Spring学习笔记</h4><h4 id="框架的概念："><a href="#框架的概念：" class="headerlink" title="框架的概念："></a>框架的概念：</h4><ol><li>高度抽取可重用代码的设计</li><li>高度的通用性<a id="more"></a><h4 id="Spring的特点"><a href="#Spring的特点" class="headerlink" title="Spring的特点:"></a>Spring的特点:</h4>优良特性：</li><li>非侵入式</li><li>依赖注入</li><li>面向切面编程</li><li>容器</li><li>组件化</li><li>一站式</li></ol><blockquote><p>Core Container（IOC）核心容器包含Bean Core Context expression 这几个容器</p></blockquote><h4 id="Web：Sping开发Web应用"><a href="#Web：Sping开发Web应用" class="headerlink" title="Web：Sping开发Web应用"></a>Web：Sping开发Web应用</h4><ol><li>WebSocket</li><li>Servlet</li><li>web protlet<blockquote><p>(建议用哪个模块就导哪个包)</p></blockquote></li></ol><h4 id="IOC："><a href="#IOC：" class="headerlink" title="IOC："></a>IOC：</h4><blockquote><p>控制反转;被动式的资源获取方式：资源的获取不是自己创建，而是交给容器创建和设置</p></blockquote><h4 id="DI：（Injevtion-依赖注入）"><a href="#DI：（Injevtion-依赖注入）" class="headerlink" title="DI：（Injevtion  依赖注入）"></a>DI：（Injevtion  依赖注入）</h4><ol><li>容器能知道哪个组件（类运行的时候时候需要另外一个类）</li><li>只要使用管理的组件，都能使用组件提供的强大功能。现在所有的对象交给容器创建，容器中的组件注册。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id &#x3D; &quot;person03&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;lastName&quot; value&#x3D;&quot;小明&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;email&quot; value&#x3D;&quot;skjdhfkjsdfhkd@126.com&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;gender&quot; value&#x3D;&quot;男&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"> &#x2F;&#x2F;有参构造器 &lt;constructor-arg&gt;就代表一个属性</span><br><span class="line"></span><br><span class="line"> &lt;bean id&#x3D;&quot;person01&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;he&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;age&quot; value &#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;hzf@666.com&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;man&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">  &lt;&#x2F;bean&gt;</span><br><span class="line">  &#x2F;&#x2F;通过无参构造器</span><br><span class="line">  &#x2F;&#x2F;如果省略name参数 就要严格按照构造器参数的位置</span><br><span class="line">  &#x2F;&#x2F;在重载的情况下 type可以指定参数的类型</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;名称空间：在xml中名称空间是用来防止标签重复的</span><br><span class="line">  &lt;book&gt;</span><br><span class="line">      &lt;b:name&gt;西游记&lt;&#x2F;name&gt;</span><br><span class="line">      &lt;author&gt;</span><br><span class="line">         &lt;a:name&gt;吴承恩&lt;&#x2F;name&gt;</span><br><span class="line">      &lt;&#x2F;author&gt;</span><br><span class="line">  &lt;&#x2F;book&gt;</span><br><span class="line">  通过标签的前缀，就可以知道name是指哪个name</span><br><span class="line"></span><br><span class="line">  xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;property name&#x3D;&quot;lastName&quot;&gt;</span><br><span class="line">      &lt;&#x2F;null&gt; &#x2F;&#x2F;进行复杂的赋值，在property标签里面</span><br><span class="line">   &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;如果把多个属性赋值给一个对象呢</span><br><span class="line"></span><br><span class="line">  &lt;bean  id &#x3D;&quot;car01&quot; class&#x3D;&quot;com.bean.Car&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;carName&quot; value&#x3D;&quot;宝马&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;color&quot; value&#x3D;&quot;pink&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;price&quot; value&#x3D;&quot;30000&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property name&#x3D;&quot;car&quot; ref&#x3D;&quot;car01&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">  &#x2F;&#x2F;在person01的容器中加入这段代码就ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;在bean里面写property写是引用外部bean， 在property里面写bean是引用内部bean</span><br></pre></td></tr></table></figure><h4 id="Spring在为各种属性赋值："><a href="#Spring在为各种属性赋值：" class="headerlink" title="Spring在为各种属性赋值："></a>Spring在为各种属性赋值：</h4><ol><li>在bean使用ref写是引用外部bean， 在property里面写bean是引用内部bean</li><li>在对list属性进行赋值，写在property里面，同时也可以使用ref引用外部赋值</li><li>在对map属性进行赋值，在property键值对里面<code>&lt;entry&gt;</code>标签，在标签内使用key value进行键值对的赋值。</li><li>util名称空间创建集合类型的bean 方便别人引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;util:map id&#x3D;&quot;myMap&quot;&gt;&#x2F;&#x2F;一定要有Id</span><br><span class="line">    &#x2F;&#x2F;里面写的直接是元素</span><br><span class="line">&lt;&#x2F;util:map&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>级联属性赋值：就是属性的属性</p></blockquote><blockquote><p>通过继承实现bean配置信息的重用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;parent05&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;男&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;akshdajsk&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;person06&quot; class&#x3D;&quot;com.bean.Person&quot; parent&#x3D;&quot;parent05&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;fengZe&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;abstract&#x3D;&quot;true&quot;,这个Bean的配置是一个抽象的，不能获取他的实例，只能被别人用来继承</span><br></pre></td></tr></table></figure><blockquote><p>bean之间的依赖（只是改变创建顺序）如果在创建之前写入 depends-on=‘book,person“，那么就会先创建book 还有person。</p></blockquote><blockquote><p>通过静态工厂方法创建bean，实例工厂方法创建bean<br>bean的创建默认就是框架利用反射new出来的bean实例，工厂模式就是有一个类帮你去创建对象</p></blockquote><ol><li>静态工厂：工厂本身不用创建对象：通过静态方法调用  对象 = 工厂类.工厂方法名（）</li><li>实例工厂：工厂本身需要创建对象：<blockquote><p>工厂类 工厂对象 =  new 工厂类（）；<br>工厂对象.getAirplane</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">factory-method：指定工厂方法</span><br><span class="line">class:指定静态工厂全类名</span><br><span class="line">&lt;constructor-arg value&#x3D;&quot;李四&quot;&gt;&lt;&#x2F;constructor-arg&gt;传参</span><br></pre></td></tr></table></figure><blockquote><p>实例工厂</p></blockquote></li><li>先配出实例工厂对象</li><li>配置我们需要创建的airPlane使用哪个工厂创建</li><li>facotry-bean ：指定使用哪个工厂实例</li><li>factory-method：使用哪个工厂方法</li></ol><blockquote><p>FactoryBean（是Spring规定的一个接口);只要是这个接口的实现类，Spring都认为是一个工厂，ioc容器启动的时候就不会创建实例</p></blockquote><h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h4><ol><li><p>ioc容器中注册的bean：</p><ol><li>单例bean ，容器启动的时候才会创建好，容器关闭也会销毁创建的bean</li><li>多例bean，获取的时候才会创建</li></ol></li><li><p>引用外部属性文件:</p><ol><li>数据库连接池作为单实例是最好的，一个项目就一个连接池，连接池里面管理很多连接。连接直接从连接里拿，可以让spring 帮我们创建连接池对象。</li><li>依赖context名称空间，可以加载外部配置文件</li></ol></li></ol><h4 id="自动装配（自动赋值）"><a href="#自动装配（自动赋值）" class="headerlink" title="自动装配（自动赋值）"></a>自动装配（自动赋值）</h4><ol><li>autowire= “default” ，可以填byName ,byType, constructor,no。</li><li>例如说byName，按照名字，以属性名作为id去容器里找到这个组件，给他赋值。如果找不到就装配null</li></ol><h4 id="Spring有四种注解："><a href="#Spring有四种注解：" class="headerlink" title="Spring有四种注解："></a>Spring有四种注解：</h4><ol><li>@Controller  控制器</li><li>@Service 业务逻辑</li><li>@Respository 数据库（持久化层）</li><li>@Component<blockquote><p>注意：某个类上添加任何一个注解都能快速的将这个组件加入ioc容器的管理</p></blockquote></li></ol><h5 id="添加步骤："><a href="#添加步骤：" class="headerlink" title="添加步骤："></a>添加步骤：</h5><ol><li>加入注释:告诉Spring，自动扫描加注释，依赖名称空间 –context:component-scan<br>base.package:” “填入需要扫描的包，至少填两级目录</li><li>在ioc获取bean的过程中，id是默认是类名的首字母小写， 也可以在注释后加入()来修改名字</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Spring学习笔记&quot;&gt;&lt;a href=&quot;#Spring学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记&quot;&gt;&lt;/a&gt;Spring学习笔记&lt;/h4&gt;&lt;h4 id=&quot;框架的概念：&quot;&gt;&lt;a href=&quot;#框架的概念：&quot; class=&quot;headerlink&quot; title=&quot;框架的概念：&quot;&gt;&lt;/a&gt;框架的概念：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;高度抽取可重用代码的设计&lt;/li&gt;
&lt;li&gt;高度的通用性&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="back-end" scheme="https://fengzehe.github.io/blog/categories/back-end/"/>
    
    
      <category term="后端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用CSS3做LoadIng动画</title>
    <link href="https://fengzehe.github.io/blog/2019/12/12/frontEnd_Loading/"/>
    <id>https://fengzehe.github.io/blog/2019/12/12/frontEnd_Loading/</id>
    <published>2019-12-12T06:47:13.000Z</published>
    <updated>2020-06-12T01:45:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用CSS3做Loading动画"><a href="#使用CSS3做Loading动画" class="headerlink" title="使用CSS3做Loading动画"></a>使用CSS3做Loading动画</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用CSS3做Loading动画&quot;&gt;&lt;a href=&quot;#使用CSS3做Loading动画&quot; class=&quot;headerlink&quot; title=&quot;使用CSS3做Loading动画&quot;&gt;&lt;/a&gt;使用CSS3做Loading动画&lt;/h3&gt;
      
    
    </summary>
    
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="CSS3" scheme="https://fengzehe.github.io/blog/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>vue学习笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/10/02/vue/"/>
    <id>https://fengzehe.github.io/blog/2019/10/02/vue/</id>
    <published>2019-10-02T01:03:25.000Z</published>
    <updated>2020-06-18T10:17:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue学习笔记"><a href="#vue学习笔记" class="headerlink" title="vue学习笔记"></a>vue学习笔记</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><pre><code>Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现在话的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</code></pre><a id="more"></a><h3 id="vue的特点："><a href="#vue的特点：" class="headerlink" title="vue的特点："></a>vue的特点：</h3><ol><li>渐进式：vue的侵入性很少，可以与很多其他前端技术联用</li><li>组件化</li><li>响应式：数据响应式，vue会监控数据变化。当数据变化时</li></ol><h3 id="vue的核心功能："><a href="#vue的核心功能：" class="headerlink" title="vue的核心功能："></a>vue的核心功能：</h3><h4 id="关于创建vue工程"><a href="#关于创建vue工程" class="headerlink" title="关于创建vue工程"></a>关于创建vue工程</h4><ol><li>直接在页面上引用vue.js</li><li>使用构建工具vue-cli脚手架</li></ol><h4 id="vue实例"><a href="#vue实例" class="headerlink" title="vue实例"></a>vue实例</h4><h4 id="vue实例：通过new-vue（配置对象）得到的对象"><a href="#vue实例：通过new-vue（配置对象）得到的对象" class="headerlink" title="vue实例：通过new vue（配置对象）得到的对象"></a>vue实例：通过new vue（配置对象）得到的对象</h4><ol><li>当创建vue实例的时候，vue将会把data（为了实现响应式）methods配置（为了在模板中方便使用）等配置成员提升到vue实例中.</li><li>由于有提升的存在，为了防止命名冲突，vue会将自身的成员名称前加上$ 或 _ , 为了防止命名冲突，vue会将自身的成员加上$(可以使用),_符号就不用用了</li></ol><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="插值：在模板的元素内部使用"><a href="#插值：在模板的元素内部使用" class="headerlink" title="插值：在模板的元素内部使用"></a>插值：在模板的元素内部使用</h4><h4 id="指令：通常作为元素的属性存在，名称上以v-开头"><a href="#指令：通常作为元素的属性存在，名称上以v-开头" class="headerlink" title="指令：通常作为元素的属性存在，名称上以v- 开头"></a>指令：通常作为元素的属性存在，名称上以v- 开头</h4><p>v-for:用于循环生成元素<br>v-on :用于注册事件。 语法糖@<br>v-if :用于判断该玄素是否可以生成,可以与v-else 或者v-else-if联用<br>v-show:元素已经显示,display:none<br>v-bind:用于绑定属性, 语法糖:<br>v-model：用于事件双向绑定，实际上是自动绑定用了value值,和注册了input事件</p><h4 id="模板中的配置"><a href="#模板中的配置" class="headerlink" title="模板中的配置"></a>模板中的配置</h4><ol><li>页面中直接书写</li><li>在template配置中书写（常见）</li><li>在render中手动配置用函数创建，render函数的参数是一个创建虚拟DOM对象，为什么要创建虚拟DOM,因为真实DOM操作特别慢</li></ol><h3 id="配置对象"><a href="#配置对象" class="headerlink" title="配置对象"></a>配置对象</h3><ol><li>template:字符串，配置模板</li><li>el:配置控制的元素，css选择器</li><li>data: 管理的数据，该数据是响应式的</li><li>mothods:配置方法，方法中的this指向vue实例，不能会用箭头函数,会干扰vue绑定this<h3 id="挂在的配置"><a href="#挂在的配置" class="headerlink" title="挂在的配置"></a>挂在的配置</h3></li><li>通过el进行配置</li><li>使用vue实例中的$mount函数进行配置</li></ol><h3 id="关于computed-–计算属性"><a href="#关于computed-–计算属性" class="headerlink" title="关于computed –计算属性"></a>关于computed –计算属性</h3><ol><li>计算属性，其中的配置会提升到vue实例中，因为在模板中可以直接当做属性使用，使用时，实际上调用的是对应的方法。通常，计算属性用户通过data或其他计算属性得到的数据。</li><li>与方法的区别：vue会检查计算属性的依赖，当依赖没有发生变化时，vue会直接使用之前缓存的结果，而不会重新计算</li><li>能用计算属性尽量使用，因为效率很高。依赖不变时不会重新加载。（计算属性的读取函数不可以有参数，有参数没意义）</li><li>计算属性可以配置get和set. 分别用于读取时和设置时。 get读取属性的时候可以监听到，然后检查那张表函数有没有变化。</li></ol><h3 id="关于v-html指令："><a href="#关于v-html指令：" class="headerlink" title="关于v-html指令："></a>关于v-html指令：</h3><ol><li>vue为了安全，会将元素内部的插值进行实体编码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-html &#x3D; &quot;html&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">config &#x3D; &#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        html:&lt;p&gt;带标签的元素&lt;&#x2F;p&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;这样就可以把html标签渲染出来了</span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是页面中可复用的功能单元</p><h4 id="VUE中的组建"><a href="#VUE中的组建" class="headerlink" title="VUE中的组建"></a>VUE中的组建</h4><ol><li>组件的创建：组件对于开发者，是一个普通的配置对象</li><li>组件的注册：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局注册组件</span><br><span class="line">Vue.component(&quot;组件形成&quot;,pager)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;局部注册组件 在使用的组件和vue实例配置中进行注册</span><br><span class="line">const config &#x3D; &#123;</span><br><span class="line">    template:&#96;&lt;div&gt;</span><br><span class="line">        &lt;MyPager&gt;&lt;&#x2F;MyPager&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;,</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        MyPager :pager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="组件名称的规范，以下命名的方式任选其一："><a href="#组件名称的规范，以下命名的方式任选其一：" class="headerlink" title="组件名称的规范，以下命名的方式任选其一："></a>组件名称的规范，以下命名的方式任选其一：</h4><ol><li>使用短横线命名</li><li>使用大驼峰命名<h4 id="组件的使用：把组件当成标签使用即可，标签名任选其一"><a href="#组件的使用：把组件当成标签使用即可，标签名任选其一" class="headerlink" title="组件的使用：把组件当成标签使用即可，标签名任选其一"></a>组件的使用：把组件当成标签使用即可，标签名任选其一</h4></li><li>短横线命名</li><li>大驼峰命名</li></ol><p>组件可以嵌套，因为会形成一个组件树，组件树的根叫做根组件</p><h3 id="组件中的数据通信："><a href="#组件中的数据通信：" class="headerlink" title="组件中的数据通信："></a>组件中的数据通信：</h3><ol><li>prevent修饰符用于v-on指令，表示阻止默认行为</li><li>stop修饰符用于v-on指令，表示阻止事件冒泡</li></ol><h4 id="组件的状态和属性："><a href="#组件的状态和属性：" class="headerlink" title="组件的状态和属性："></a>组件的状态和属性：</h4><ol><li>通常讲组件中需要自身管理的数据（组件配置中的data）叫做组件状态（component state），组件状态只能在组件内部使用，外部原则上不可以使用.</li><li>data(state 状态)在组件中的配置和在vue实例中配置的区别：<br>在组件中data必须是一个函数，而VUE实例中心必须是一个对象。因为组件是可以被复用的，每一个组件都是独立的，所以data必须是一个函数.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在组件中</span><br><span class="line">export default&#123;</span><br><span class="line">    template,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x2F;&#x2F;返回的结果是组件的状态</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组件中可以有属性（component-props），而vue实例中没有"><a href="#组件中可以有属性（component-props），而vue实例中没有" class="headerlink" title="组件中可以有属性（component props），而vue实例中没有"></a>组件中可以有属性（component props），而vue实例中没有</h4><ol><li>声明组件属性时，使用短横线或小驼峰命名法</li><li>传递组件属性时，使用短横线或小驼峰命名法</li><li>属性会被提升到vue组件实例中</li></ol><p>==组件的属性时只读的，不允许更改，根本原因是要保证单向数据流==</p><h3 id="自定义事件："><a href="#自定义事件：" class="headerlink" title="自定义事件："></a>自定义事件：</h3><ol><li>在组件中触发事件： this.$emit(“事件名”,事件参数…)</li><li>当一个组件状态发生变化时，该组件会重新渲染，在渲染的过程中，可能会导致其子组件的属性发生变化，而属性的变化会导致组件重新渲染。但根本原因，是状态的变化.</li><li>v-model 的本质是一个语法糖，实际上是绑定value属性，同时监听input事件</li></ol><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><ol><li>beforeCreate(){}  –&gt;这个是自动执行的</li><li>created()  –&gt;组件实例中已经提升到实例总，但是没有渲染页面</li><li>beforeMount   –&gt; 组件即将进行渲染，但还没有渲染，此时已经编译好模板</li><li>mounted【常用】  –&gt;组件已经完成渲染（页面可见）</li><li>beforeUpdate –&gt;组件即将更新，还没有更新，此时得到的数据是新的，但页面依旧是旧的</li><li>updated –&gt; 数据，界面都是新的</li><li>beforeDestory –&gt; 当组件即将被销毁  调用vm.$destroy()函数</li><li>destoryed  –&gt; 解除绑定，销毁子组件以及事件监听器</li></ol><h3 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h3><p>vue路由，可以简单理解为，当访问某个地址时，渲染某个组件</p><p>使用路由</p><ol><li>根据一个配置对象创建路由，得到路由对象</li><li>在创建vue实例时，将路由对象配置到实例配置的router中</li><li>在合适的位置写上router-view组件，表示路由匹配到组件渲染的位置，它实际上是vue-router做好的一个组件，并且做好了全局注册</li></ol><p>路由配置对象</p><ol><li>routes:路由规则配置</li><li>mode:配置模式<ol><li>hash模式，兼容性最好，地址出现#号后，切换地址不会导致页面刷新</li><li>history模式，使用的是HTML5 history API，地址直接变化，并且页面不刷新</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vue学习笔记&quot;&gt;&lt;a href=&quot;#vue学习笔记&quot; class=&quot;headerlink&quot; title=&quot;vue学习笔记&quot;&gt;&lt;/a&gt;vue学习笔记&lt;/h2&gt;&lt;h3 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;headerlink&quot; title=&quot;概念：&quot;&gt;&lt;/a&gt;概念：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现在话的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2019-09-03 实习笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/09/03/2019.09.03/"/>
    <id>https://fengzehe.github.io/blog/2019/09/03/2019.09.03/</id>
    <published>2019-09-03T14:58:13.000Z</published>
    <updated>2020-06-18T10:17:14.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h5><blockquote><p>今天刷面试题的时候，遇到一个问题——如何判断一段字符串里面出现最多的字符以及出现次数。</p></blockquote><h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><ol><li>利用javascript对象的属性特征，可以实现每个字符与出现次数的绑定</li><li>通过遍历和累加，计算得出每个字符出现的次数</li><li>通过对比出现的次数，返回出现次数最多的字符<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">const str &#x3D; &#39;asddfgdfwwqeweqwezczxcsdfgdgd&#39;;</span><br><span class="line"></span><br><span class="line">   var obj &#x3D; &#123;&#125;;</span><br><span class="line">   var max &#x3D; 0;</span><br><span class="line">   var maxStr &#x3D; &quot;&quot;;</span><br><span class="line">   for(let i &#x3D; 0; i &lt; str.length ; i++)&#123;</span><br><span class="line">     var word &#x3D; str.charAt(i);</span><br><span class="line">     if(obj[word] !&#x3D; null)&#123;</span><br><span class="line">       obj[word]++;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">       obj[word] &#x3D; 1</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     for(let i in obj)&#123;</span><br><span class="line">       if(obj[i]&gt;max)&#123;</span><br><span class="line">         max &#x3D; obj[i];</span><br><span class="line">         maxStr &#x3D; i</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&#39;出现最多次:&#39; + max +&#39;的字符是：&#39;+ maxStr)</span><br><span class="line">   console.log(obj);</span><br><span class="line">   &#x2F;&#x2F; &#123;a: 1, s: 2, d: 6, f: 3, g: 3, …&#125;</span><br><span class="line">   &#x2F;&#x2F; a: 1</span><br><span class="line">   &#x2F;&#x2F; c: 2</span><br><span class="line">   &#x2F;&#x2F; d: 6</span><br><span class="line">   &#x2F;&#x2F; e: 3</span><br><span class="line">   &#x2F;&#x2F; f: 3</span><br><span class="line">   &#x2F;&#x2F; g: 3</span><br><span class="line">   &#x2F;&#x2F; q: 2</span><br><span class="line">   &#x2F;&#x2F; s: 2</span><br><span class="line">   &#x2F;&#x2F; w: 4</span><br><span class="line">   &#x2F;&#x2F; x: 1</span><br><span class="line">   &#x2F;&#x2F; z: 2</span><br><span class="line">   &#x2F;&#x2F; __proto__: Object</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;今天刷面试题的时候，遇到一个问题——如何判断一段字符串里面出现最多的字符以及出现次数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;利用javascript对象的属性特征，可以实现每个字符与出现次数的绑定&lt;/li&gt;
&lt;li&gt;通过遍历和累加，计算得出每个字符出现的次数&lt;/li&gt;
&lt;li&gt;通过对比出现的次数，返回出现次数最多的字符&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>HTML5学习笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/09/02/HTML5-note/"/>
    <id>https://fengzehe.github.io/blog/2019/09/02/HTML5-note/</id>
    <published>2019-09-02T01:03:25.000Z</published>
    <updated>2020-06-18T10:16:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML5学习笔记"><a href="#HTML5学习笔记" class="headerlink" title="HTML5学习笔记"></a>HTML5学习笔记</h3><h4 id="Canvas-画布"><a href="#Canvas-画布" class="headerlink" title="Canvas 画布"></a>Canvas 画布</h4><h5 id="Canvas应用场景："><a href="#Canvas应用场景：" class="headerlink" title="Canvas应用场景："></a>Canvas应用场景：</h5><ol><li>游戏</li><li>图表</li><li>动画</li><li>condepen.io（HTML5动效）<a id="more"></a><h5 id="Canvas-发展史"><a href="#Canvas-发展史" class="headerlink" title="Canvas 发展史"></a>Canvas 发展史</h5><blockquote><p>最早在apple Safari1.3中引入，ie9之前的浏览器不支持canvas</p></blockquote></li></ol><h4 id="如何使用canvas"><a href="#如何使用canvas" class="headerlink" title="如何使用canvas"></a>如何使用canvas</h4><h5 id="添加canvas标签"><a href="#添加canvas标签" class="headerlink" title="添加canvas标签"></a>添加canvas标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas width &#x3D; 500 height &#x3D; 500&gt;&lt;&#x2F;canvas&gt;</span><br><span class="line"></span><br><span class="line">获取cancas元素</span><br><span class="line">var canvas &#x3D; document.getElementById(&#39;myCanvas&#39;)</span><br><span class="line"></span><br><span class="line">获取canvas上下文对象</span><br><span class="line">var ctx &#x3D; camvas.getContext(&#39;2d&#39;);</span><br></pre></td></tr></table></figure><h5 id="如何画线段"><a href="#如何画线段" class="headerlink" title="如何画线段"></a>如何画线段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(x,y) 移动到x,y坐标点</span><br><span class="line">ctx.lineTo(x,y) 从当前点描绘直线到x,y点</span><br><span class="line">ctx.stroke();描边</span><br><span class="line">ctx.lineWidth &#x3D; 20  设置线条宽度</span><br><span class="line">ctx.closePath();  闭合当前路径</span><br><span class="line">ctx.fill() 填充</span><br></pre></td></tr></table></figure><h5 id="fill和stroke方法都是作用在当前的所有子路径"><a href="#fill和stroke方法都是作用在当前的所有子路径" class="headerlink" title="fill和stroke方法都是作用在当前的所有子路径"></a>fill和stroke方法都是作用在当前的所有子路径</h5><blockquote><p>完成一条路径后重新开始另一条路径时必须使用beginPath()开始子路径的一个新集合</p></blockquote><h5 id="如何使用Canvas画矩阵"><a href="#如何使用Canvas画矩阵" class="headerlink" title="如何使用Canvas画矩阵"></a>如何使用Canvas画矩阵</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.rect(x, y,dx,dy)</span><br><span class="line">ctx.fillRect(x,y ,dx,dy)</span><br><span class="line">ctx.strockeRect(x, y ,w, h)</span><br></pre></td></tr></table></figure><blockquote><p>如何擦除当前区域： ctx.clearRect</p></blockquote><h5 id="如何画圆角："><a href="#如何画圆角：" class="headerlink" title="如何画圆角："></a>如何画圆角：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ctx.arcTo(x1,y1,x2,y2,r)</span><br><span class="line">&#x2F;&#x2F;绘制的弧线与当前点和x1,y1连线，x1,y1和x2,y2连线都相切</span><br><span class="line"></span><br><span class="line">贝塞尔曲线：</span><br><span class="line">quadraticCureveTo(x1 ,x2,ex,ey)  二次贝塞尔曲线 x1,y1控制点，ex,ey结束点</span><br><span class="line">bezierCureveTo(x1,y1,x2,y2,ex,ey)  三次贝塞尔曲线</span><br><span class="line">x1 y1  x2 y2 控制点</span><br><span class="line">ex ey结束点</span><br></pre></td></tr></table></figure><h5 id="坐标轴的抓换"><a href="#坐标轴的抓换" class="headerlink" title="坐标轴的抓换"></a>坐标轴的抓换</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tanslate(dx,dy) 重新映射到画板上的（0,0）位置</span><br><span class="line">scale(sx,sy) 缩放当前绘图</span><br><span class="line">rotate(Math.PI)  旋转当前的绘图</span><br><span class="line">save()  restore()</span><br><span class="line">保存当前图像状态的一份拷贝</span><br><span class="line">从栈中弹出存储的图形状态并恢复</span><br><span class="line">setTransform(a,b,c,d,e,f)</span><br><span class="line">transform(a,b,c,d,e,f)  &#x2F;&#x2F;在之前的基础上变换</span><br></pre></td></tr></table></figure><h5 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h5><p> createLinearGradubt(x1,y1,x2,y2);线性渐变，必须在填充渐变区域里定义渐变，否则没有效果</p><ol><li>createRadialGradient(x1, y1, r1, x2, y2, r2); 径向渐变<br>bg.addColorStop(p.color)</li></ol><h5 id="阴影："><a href="#阴影：" class="headerlink" title="阴影："></a>阴影：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctx.shadowColor</span><br><span class="line">ctx.shadowOffsetX</span><br><span class="line">ctx.shadowOffsetY</span><br><span class="line">ctx.shadowBlur</span><br></pre></td></tr></table></figure><h5 id="文本："><a href="#文本：" class="headerlink" title="文本："></a>文本：</h5><ol><li>fillText();</li><li>strokeText();</li><li>measureText(‘helloworld’）</li></ol><h5 id="线段样式"><a href="#线段样式" class="headerlink" title="线段样式"></a>线段样式</h5><ol><li>lineCap</li><li>lineJoion</li></ol><h5 id="绘制图片："><a href="#绘制图片：" class="headerlink" title="绘制图片："></a>绘制图片：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.drawImage();</span><br><span class="line">&#x2F;&#x2F;第一个参数是img(Image,canvas,video)</span><br></pre></td></tr></table></figure><h5 id="将canvas内容导出"><a href="#将canvas内容导出" class="headerlink" title="将canvas内容导出"></a>将canvas内容导出</h5><ol><li>canvas.toDataURL();  是canvas自身方法不是上下文对象</li><li>将canvas的内容抽取成一张照片，base64编码格式（注意同源策略）</li><li>将canvas内容放进img元素里</li></ol><h5 id="获取canvas像素信息"><a href="#获取canvas像素信息" class="headerlink" title="获取canvas像素信息"></a>获取canvas像素信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.getImageData(x,y,dx,dy)</span><br><span class="line">crx.createImageData(w,h) 创建新的空白ImageData对象</span><br><span class="line">ctx.putImageData(imgData,x,y) 将图像数据放回画布上</span><br></pre></td></tr></table></figure><h4 id="SVG（Scalable-Vector-Graphics）"><a href="#SVG（Scalable-Vector-Graphics）" class="headerlink" title="SVG（Scalable Vector Graphics）"></a>SVG（Scalable Vector Graphics）</h4><p>可缩放适量图形</p><h5 id="SVG应用场景"><a href="#SVG应用场景" class="headerlink" title="SVG应用场景:"></a>SVG应用场景:</h5><ol><li>图表</li><li>图标icon</li><li>动效</li><li>矢量图</li></ol><h5 id="使用svg画各种各样的图形："><a href="#使用svg画各种各样的图形：" class="headerlink" title="使用svg画各种各样的图形："></a>使用svg画各种各样的图形：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 直线</span><br><span class="line">&lt;line x1&#x3D;&quot;100&quot; y1&#x3D;&quot;100&quot; x2&#x3D;&quot;200&quot; y2&#x3D;”100”&gt;&lt;&#x2F;line&gt;</span><br><span class="line">2. 矩形</span><br><span class="line">&lt;rect x&#x3D;&quot;50&quot; y&#x3D;&quot;50&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;100&quot; rx&#x3D;&quot;10&quot;ry&#x3D;&quot;20&quot;&gt;&lt;&#x2F;rect&gt;</span><br><span class="line">3. 圆形</span><br><span class="line">&lt;circle r&#x3D;&quot;50&quot; cx&#x3D;&quot;220&quot; cy&#x3D;&quot;100&quot;&gt;&lt;&#x2F;circle&gt;</span><br><span class="line">4. 椭圆</span><br><span class="line">&lt;ellipse rx&#x3D;&quot;100&quot; ry&#x3D;&quot;50&quot; cx&#x3D;&quot;100&quot; cy&#x3D;&quot;200&quot;&gt;&lt;&#x2F;ellipse&gt;</span><br><span class="line">5. 折线</span><br><span class="line">&lt;polyline points&#x3D;&quot;60 50, 75 35, 100 50, 125 35, 150 50,</span><br><span class="line">175 35, 190 50&quot;&gt;&lt;&#x2F;polyline&gt;</span><br><span class="line">6. 多边形</span><br><span class="line">&lt;polygon points&#x3D;&quot;125 125,130 140,120 140&quot;&gt;&lt;&#x2F;</span><br><span class="line">polygon&gt;</span><br><span class="line">7. ⽂本</span><br><span class="line">&lt;text x&#x3D;&quot;125&quot; y&#x3D;&quot;220&quot;&gt;hello,world&lt;&#x2F;text&gt;</span><br></pre></td></tr></table></figure><h5 id="path指令：（大写代表绝对定位，小写表示相对定位）"><a href="#path指令：（大写代表绝对定位，小写表示相对定位）" class="headerlink" title="path指令：（大写代表绝对定位，小写表示相对定位）"></a>path指令：（大写代表绝对定位，小写表示相对定位）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">M &#x3D; moveto</span><br><span class="line">L &#x3D; lineto</span><br><span class="line">H &#x3D; horizontal lineto 水平线</span><br><span class="line">V &#x3D; vertical lineto垂直线</span><br><span class="line">C &#x3D; curveto 曲线</span><br><span class="line">S &#x3D; smooth curveto 平滑的曲线</span><br><span class="line">Q &#x3D; quadratic Belzier curve 二次贝塞尔曲线</span><br><span class="line">T &#x3D; smooth quadratic Belzier curveto 光滑贝塞尔曲线</span><br><span class="line">A &#x3D; elliptical Arc  椭圆弧</span><br><span class="line">Z &#x3D; closepath</span><br></pre></td></tr></table></figure><h4 id="SVG渐变"><a href="#SVG渐变" class="headerlink" title="SVG渐变"></a>SVG渐变</h4><ol><li>线性渐变</li><li>径向渐变</li></ol><h4 id="HTML5动画api-requestAnimationFrame"><a href="#HTML5动画api-requestAnimationFrame" class="headerlink" title="HTML5动画api requestAnimationFrame"></a>HTML5动画api requestAnimationFrame</h4><ol><li>页面刷新钱执行一次</li><li>1000ms 60fps -&gt; 16ms</li><li>cancelAnimationFrame</li><li>用法和setTimeout类似</li><li>兼容性(只在IE10以上的浏览器)用老浏览器就用setTimeout</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">window.requestAnimFrame &#x3D; (function()&#123;</span><br><span class="line">  return window.requestAnimationFrame ||</span><br><span class="line">  window.webkitRequestAnimationFrame ||</span><br><span class="line">  window.mozRequestAnimationFrame ||</span><br><span class="line">  function( callback )&#123;</span><br><span class="line">  window.setTimeout(callback, 1000 &#x2F; 60);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;cancelAnimFrame()</span><br><span class="line">window.cancelAnimFrame &#x3D; (function()&#123;</span><br><span class="line">  return window.cancelAnimationFrame ||</span><br><span class="line">  window.webkitCancelAnimationFrame ||</span><br><span class="line">  window.mozCancelAnimationFrame ||</span><br><span class="line">  function( id)&#123;</span><br><span class="line">  window.clearTimeout(id);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h4><ol><li>Storage<ol><li>localstorage (永久的)</li><li>sessionstorage(关闭浏览器就没有了)</li></ol></li><li>cookie（存储容量很小，4K左右）</li></ol><h5 id="如何使用storage存储和读取数据"><a href="#如何使用storage存储和读取数据" class="headerlink" title="如何使用storage存储和读取数据"></a>如何使用storage存储和读取数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage.name &#x3D; &#39;admin&#39; &#x2F;&#x2F;存字符串</span><br><span class="line">localStorage.info &#x3D; JSON.stringify(&#123;name:&#39;admin&#39;，company:&#39;jizhu&#39;&#125;) &#x2F;&#x2F;存对象</span><br><span class="line"></span><br><span class="line">    var info &#x3D; JSON.parse(localStorage.obj);&#x2F;&#x2F;取出数据</span><br><span class="line">       console.log(info);</span><br></pre></td></tr></table></figure><h5 id="storage作用域"><a href="#storage作用域" class="headerlink" title="storage作用域"></a>storage作用域</h5><ol><li>localSotrage -&gt; 文档源限制</li><li>sessionStorage -&gt; 文档源显示 + 窗口</li></ol><h5 id="storage-的API"><a href="#storage-的API" class="headerlink" title="storage 的API"></a>storage 的API</h5><ol><li>setItem(name,val) 设置属性值</li><li>getItem(name) 获得属性值</li><li>removeItem(name) 移除属性</li><li>clear() 清除属性</li></ol><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><ol><li>存储信息到用户的设备上，数据量比较小</li><li>navigator.cookieEnable  监测是否开启了cookie</li></ol><h6 id="设置cookie值"><a href="#设置cookie值" class="headerlink" title="设置cookie值"></a>设置cookie值</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">document.cookie &#x3D; “name&#x3D;aimee”</span><br><span class="line">&#x2F;&#x2F;（每次只能设置一个值，因为浏览器会认为后面的键值对是这个cookie的属性）</span><br><span class="line">document.cookie &#x3D; “name&#x3D;aimee”</span><br><span class="line">&#x2F;&#x2F;（每次只能设置一个值，因为浏览器会认为后面的键值对是这个cookie的属性）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getCookie(name) &#123;</span><br><span class="line">  var name &#x3D; name + &quot;&#x3D;&quot;;</span><br><span class="line">  var ca &#x3D; document.cookie.split(&#39;;&#39;);</span><br><span class="line">  for(var i&#x3D;0; i&lt;ca.length; i++) &#123;</span><br><span class="line">  var c &#x3D; ca[i];</span><br><span class="line">  while (c.charAt(0)&#x3D;&#x3D;&#39; &#39;) c &#x3D; c.substring(1);</span><br><span class="line">  if (c.indexOf(name) !&#x3D; -1) return c.substring(name.length, c.length);</span><br><span class="line">  &#125;</span><br><span class="line">  return &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="cookie-与-storage的对比"><a href="#cookie-与-storage的对比" class="headerlink" title="cookie 与 storage的对比"></a>cookie 与 storage的对比</h5><p><img src="/blog/blog/2019/09/02/HTML5-note/cookieAndSess.png" alt></p><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><ol><li>history.back();</li><li>history.forward();</li><li>history.go(n)</li></ol><h5 id="通过修改hash和hashchange事件来实现历史纪录管理"><a href="#通过修改hash和hashchange事件来实现历史纪录管理" class="headerlink" title="通过修改hash和hashchange事件来实现历史纪录管理"></a>通过修改hash和hashchange事件来实现历史纪录管理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、pushState</span><br><span class="line">history.pushState(state, title, url); &#x2F;&#x2F;添加一条历史记录</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、replaceState</span><br><span class="line">history.replaceState(state, title, url);&#x2F;&#x2F; 替换当前的历史记录</span><br></pre></td></tr></table></figure><h4 id="worker-异步操作的api"><a href="#worker-异步操作的api" class="headerlink" title="worker(异步操作的api)"></a>worker(异步操作的api)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var worker &#x3D; new Worker(&#39;workder.js&#39;)</span><br><span class="line">&#x2F;&#x2F;https:&#x2F;&#x2F;www.w3school.com.cn&#x2F;html5&#x2F;html_5_webworkers.asp</span><br></pre></td></tr></table></figure><p><img src="/blog/blog/2019/09/02/HTML5-note/worker.png" alt></p><h4 id="geolocation"><a href="#geolocation" class="headerlink" title="geolocation"></a>geolocation</h4><ol><li>getCurrentPosition()     //获取当前的位置信息<ol><li>getCurrentPosition(s,e,p)</li><li>success 回调 必须的</li><li>error  回调</li><li>option 参数</li></ol></li><li>watchPosition()    //监视位置变化, 和1参数一样</li><li>clearWatch()  //清除位置监视</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.navigator.geolocation.getCurrentPosition(suc)</span><br></pre></td></tr></table></figure><p><img src="/blog/blog/2019/09/02/HTML5-note/geolocation1.png" alt><br><img src="/blog/blog/2019/09/02/HTML5-note/geolocation2.png" alt></p><h4 id="PositionError对象"><a href="#PositionError对象" class="headerlink" title="PositionError对象"></a>PositionError对象</h4><ol><li>用户拒绝code = 1;</li><li>获取不到 code = 2;</li><li>连接超时 code  = 3;</li></ol><h5 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h5><p>enableHighAccuracy 是否需要高精度位置默认false<br>timeout 单位ms 请求超时时间 默认infinity<br>maximumAge 单位ms，位置信息过期时间 设置为0就无条件获取新的地理位置信息 默认0<br><a href="https://dev.w3.org/geo/api/spec-source.html#position_options_interface" target="_blank" rel="noopener">https://dev.w3.org/geo/api/spec-source.html#position_options_interface</a></p><h5 id="watchPosition"><a href="#watchPosition" class="headerlink" title="watchPosition"></a>watchPosition</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var id &#x3D; geolocation.watchPostion()  &#x2F;&#x2F;用于注册监听器，在设备的地理位置发生个改变的时候自动被调用</span><br><span class="line">clearWatch(id)  &#x2F;&#x2F;使用clearWatch 清除监听</span><br></pre></td></tr></table></figure><h5 id="devicemotion事件所包含的属性"><a href="#devicemotion事件所包含的属性" class="headerlink" title="devicemotion事件所包含的属性"></a>devicemotion事件所包含的属性</h5><ol><li>accelerationIncludingGravity （包括重心引力）重力加速度</li><li>acceleration 重力加速度<br>（需要陀螺仪支持）</li><li>rotationRate(alpha, beta, gamma)旋转速率</li><li>interval // 获取的时间间隔<br>均为只读属性</li></ol><h4 id="多媒体："><a href="#多媒体：" class="headerlink" title="多媒体："></a>多媒体：</h4><ol><li>audio 音频</li><li>video 视频<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio src&#x3D; &quot;.&#x2F;demo.mp3&quot; controls &#x3D; &gt;&lt;&#x2F;audio&gt;</span><br><span class="line"></span><br><span class="line">autoplay &#x2F;&#x2F;自动播放控件</span><br><span class="line">controls &#x2F;&#x2F;设置控件</span><br><span class="line">preload(none&#x2F;metadata&#x2F;auto)预加载</span><br><span class="line">metadata :元数据 诸如时长、比特率、帧大小这样的原数据而不是媒体内容需要加载的</span><br><span class="line">loop： 是否循环播放音频or视频</span><br><span class="line">poster:(video独有)，当视频不可用的时候，使用一张图片替代</span><br></pre></td></tr></table></figure></li></ol><h5 id="多类型选择器："><a href="#多类型选择器：" class="headerlink" title="多类型选择器："></a>多类型选择器：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio id&#x3D;&quot;music&quot;&gt;</span><br><span class="line">        &lt;source src&#x3D;&quot;成都.mp3&quot; type&#x3D;&quot;audio&#x2F;mpeg&quot;&gt; &#x2F;&#x2F;如果没有第一个，就播放第二个</span><br><span class="line">        &lt;source src&#x3D;&quot;成都.ogg&quot; type&#x3D;&#39;audio&#x2F;ogg&quot;&#39;&gt;</span><br><span class="line">        &lt;&#x2F;audio&gt;</span><br></pre></td></tr></table></figure><h5 id="脚本化："><a href="#脚本化：" class="headerlink" title="脚本化："></a>脚本化：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var audio &#x3D; document.getElementById(&#39;audio&#39;);</span><br><span class="line"></span><br><span class="line">var audio &#x3D; new Audio(&#39;.&#x2F;laojie.mp3&#39;);</span><br><span class="line"></span><br><span class="line">var audio &#x3D; document.createElement(&#39;video&#39;);</span><br></pre></td></tr></table></figure><h5 id="播放的方法"><a href="#播放的方法" class="headerlink" title="播放的方法"></a>播放的方法</h5><ol><li>play() 方法</li><li>pause() 方法    //用于暂停</li><li>load()方法 用于重新加载视频/音频元素</li></ol><blockquote><p>表示播放音量，介于0(静音)~1(最大音量)之间，默认1。将muted属性设置为true则会进入静音模式，设置为false则会恢复之前指定的音量继续播放。超过范围会报错[0, 1]</p></blockquote><blockquote><p>播放速率playbackRate：用于指定媒体播放的速度。该属性值为1.0表示正常播放，大于1则表示快进，0-1之间表示慢放，负值表示回放。</p></blockquote><h5 id="currentTime-duration-属性"><a href="#currentTime-duration-属性" class="headerlink" title="currentTime/duration 属性"></a>currentTime/duration 属性</h5><ol><li>currentTime设置或返回音频视频的当前位置</li><li>duration 返回当前音频/视频的时常<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">audio.currentTime &#x3D; 50;</span><br><span class="line">button.addEventLidtener(&#39;clkick&#39;,function()&#123;</span><br><span class="line">    consoloe.log(audio.currentTime)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">window.onload &#x3D;  function(&#123;</span><br><span class="line">    console.log(audio.duration);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h6 id="played-buffered-seekable"><a href="#played-buffered-seekable" class="headerlink" title="played/buffered/seekable"></a>played/buffered/seekable</h6><blockquote><p>played属性返回已经播放(看过)的时间段，buffered属性返回当前已经缓冲的时间段，seekable属性则返回用户可以跳转的时间段。这三个属性都是TimeRanges对象，每个对象都有一个length属性以及start()和end()方法，length属性表示当前的一个时间段，start()与end()分别返回当前时间段的起始时间点和结束时间点(单位是秒，起始参数是0)</p></blockquote><blockquote><p>paused/seeking/ended<br>这三个属性用来查询媒体播放状态，paused为true表示播放器暂停。seeking为true表示播放器正在调到一个新的播放点，如果播放器播放完媒体并且停下来，则ended属性为true。</p></blockquote><h6 id="canPlayType-方法"><a href="#canPlayType-方法" class="headerlink" title="canPlayType()方法"></a>canPlayType()方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; new Audio();</span><br><span class="line">if(a.canPlayType(&quot;audio&#x2F;mp3&quot;))&#123;</span><br><span class="line">    a.src &#x3D; &quot;.&#x2F;chengdu.mp3&quot;;</span><br><span class="line">    a.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><ol><li>play 开始播放触发</li><li>pause 暂停触发</li><li>loadedmetadata 浏览器获取完媒体的元数据触发</li><li>loadedata 浏览器已经加载完当前帧数据，准备播放时触发，注意兼容IE8</li><li>ended 当前播放结束后触发<blockquote><p>readyState属性音频的当前就绪状态<br><img src="/blog/blog/2019/09/02/HTML5-note/readyState.png" alt><br><img src="/blog/blog/2019/09/02/HTML5-note/networkState.png" alt><br><img src="/blog/blog/2019/09/02/HTML5-note/error_medio.png" alt></p></blockquote></li></ol><h4 id="drap-＆-drop-常用语各种拖动操作中"><a href="#drap-＆-drop-常用语各种拖动操作中" class="headerlink" title="drap  ＆ drop(常用语各种拖动操作中)"></a>drap  ＆ drop(常用语各种拖动操作中)</h4><h5 id="创建可拖动元素"><a href="#创建可拖动元素" class="headerlink" title="创建可拖动元素"></a>创建可拖动元素</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;abc&quot; draggable&#x3D;&quot;true&quot;&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F;使用draggable之后就能够拖拽元素了</span><br></pre></td></tr></table></figure></code></pre><h5 id="关于拖拽的相关事件："><a href="#关于拖拽的相关事件：" class="headerlink" title="关于拖拽的相关事件："></a>关于拖拽的相关事件：</h5><ol><li>dragstart 被拖拽元素 开始被拖拽时触发  e.dataTransfer.setData(“data”,e.target.id)</li><li>dragend 被拖拽元素 拖拽完成时</li><li>dragenter 目标元素 拖曳元素进入目标元素</li><li>dragover 目标元素 拖拽元素在目标元素上移动</li><li>drop 目标元素 被拖拽的元素在目标元素上同时鼠标放开触发的事件</li><li>e.dataTransfer.getData(“data”)<br>需要阻止dragover的默认行为才会触发drop事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    &lt;script&gt;</span><br><span class="line">        var item &#x3D; document.getElementById(&quot;abc&quot;);</span><br><span class="line">        item.addEventListener(&#39;dragstart&#39;,function()&#123;</span><br><span class="line">            console.log(&quot;akshd&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    var itemO &#x3D; document.getElementById(&quot;wrapper&quot;);</span><br><span class="line">        itemO.addEventListener(&#39;dragenter&#39;,function()&#123;</span><br><span class="line">            console.log(&#39;dragenter&#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#x2F;&#x2F;这个是写在被进入的元素里面</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DragEvent 事件对象</span><br><span class="line">&#x2F;&#x2F;传值</span><br><span class="line">e.dataTranSfer.setData(&quot;data&quot;,e.target.id)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取值</span><br><span class="line"> e.dataTransfer.getData(&quot;data&quot;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="FileReader-读取文件"><a href="#FileReader-读取文件" class="headerlink" title="FileReader 读取文件"></a>FileReader 读取文件</h4><ol><li>abrot() 终止读取</li><li>readAsBinaryString(file) 将文件读取为二进制编码</li><li>readAsDataURL(file)     将文件读取为DataURL编码</li><li>readAsText(file,[encoding]) 将文件读取为文本</li><li>readAsArrayBuffer(file)  将文本读取为arraybuffer 通过不同的方式读取文件</li></ol><h5 id="FileReader-事件"><a href="#FileReader-事件" class="headerlink" title="FileReader 事件"></a>FileReader 事件</h5><ol><li>onloadstart 读取开始时触发</li><li>onprogress 读取中</li><li>onloadend 读取完成，无论成功或失败</li><li>onload  文件读取成功完成时触发</li><li>onabort 中断时触发</li><li>onerror 出错时触发<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取读取的结果</span><br><span class="line">fr.onload  &#x3D; function()&#123;</span><br><span class="line">    tihs.result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Web-Socket（是一个新的协议）"><a href="#Web-Socket（是一个新的协议）" class="headerlink" title="Web Socket（是一个新的协议）"></a>Web Socket（是一个新的协议）</h4><blockquote><p>WebSocket 对象提供了一组 API，用于创建和管理 WebSocket 连接,<br>​​​​​​​以及通过连接发送和接收数据.<br>Websocket 其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已.借用了HTTP的协议来完成握手</p></blockquote><h5 id="产生背景："><a href="#产生背景：" class="headerlink" title="产生背景："></a>产生背景：</h5><ol><li>在 HTTP/1.0 中,大多实现为每个请求/响应交换使用新的连接</li><li>在 HTTP/1.1 中,一个连接可用于一次或多次请求/响应交换</li><li>HTTP协议中，服务端不能主动联系客户端，只能有客户端发起。</li><li>webSoket服务器和客户端均可主动发送数据</li></ol><h5 id="建立连接的握手："><a href="#建立连接的握手：" class="headerlink" title="建立连接的握手："></a>建立连接的握手：</h5><ol><li>当Web应用程序调用new WebSocket(url)接口时，Browser就开始了与地址为url的WebServer建立握手连接的过程。</li><li>Browser与WebSocket服务器通过TCP握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用程序将收到错误消息通知。</li><li>在TCP建立连接成功后，Browser通过http协议传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端。</li><li>WebSocket服务器收到Browser发送来的请求后，如果数据包数据和格式正确，客户端和服务器端的协议版本号匹配等等，就接受本次握手连接，并给出相应的数据回复，同样回复的数据包也是采用http协议传输。</li><li>Browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发onopen消息，此时Web开发者就可以在此时通过send接口向服务器发送数据。否则，握手连接失败，Web应用程序会收到onerror消息，并且能知道连接失败的原因。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建webSocket</span><br><span class="line">var Socket &#x3D; new WebSocket(url)</span><br></pre></td></tr></table></figure><h5 id="webSocket方法"><a href="#webSocket方法" class="headerlink" title="webSocket方法"></a>webSocket方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket.send() 方法使用连接传输数据</span><br><span class="line">socket.close()  方法用于终止任何现有连接</span><br></pre></td></tr></table></figure><p><img src="/blog/blog/2019/09/02/HTML5-note/webSocket.png" alt></p><h5 id="webSocket的优点"><a href="#webSocket的优点" class="headerlink" title="webSocket的优点"></a>webSocket的优点</h5><ol><li>客户端与服务器都可以主动传递数据给对方</li><li>不用频率创建TCP请求及销毁请求，减少网络带宽资源的占用，同时也节省服务器资源</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTML5学习笔记&quot;&gt;&lt;a href=&quot;#HTML5学习笔记&quot; class=&quot;headerlink&quot; title=&quot;HTML5学习笔记&quot;&gt;&lt;/a&gt;HTML5学习笔记&lt;/h3&gt;&lt;h4 id=&quot;Canvas-画布&quot;&gt;&lt;a href=&quot;#Canvas-画布&quot; class=&quot;headerlink&quot; title=&quot;Canvas 画布&quot;&gt;&lt;/a&gt;Canvas 画布&lt;/h4&gt;&lt;h5 id=&quot;Canvas应用场景：&quot;&gt;&lt;a href=&quot;#Canvas应用场景：&quot; class=&quot;headerlink&quot; title=&quot;Canvas应用场景：&quot;&gt;&lt;/a&gt;Canvas应用场景：&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;游戏&lt;/li&gt;
&lt;li&gt;图表&lt;/li&gt;
&lt;li&gt;动画&lt;/li&gt;
&lt;li&gt;condepen.io（HTML5动效）&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>ES6</title>
    <link href="https://fengzehe.github.io/blog/2019/08/12/ES6/"/>
    <id>https://fengzehe.github.io/blog/2019/08/12/ES6/</id>
    <published>2019-08-12T13:10:57.000Z</published>
    <updated>2020-06-18T10:18:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6学习笔记"><a href="#ES6学习笔记" class="headerlink" title="ES6学习笔记"></a>ES6学习笔记</h2><a id="more"></a><h3 id="ES6语法的一个特性"><a href="#ES6语法的一个特性" class="headerlink" title="ES6语法的一个特性"></a>ES6语法的一个特性</h3><p>块级作用域：<br>{</p><p>}</p><h3 id="LET命令"><a href="#LET命令" class="headerlink" title="LET命令"></a>LET命令</h3><ol><li>LET声明的变量具有块级作用域的概念<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    console.log(typeof a)&#x2F;&#x2F;Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization</span><br><span class="line">    let a &#x3D; 42;</span><br><span class="line">    var b &#x3D; 1212;</span><br><span class="line">    console.log(typeof a)  &#x2F;&#x2F;number</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    console.log(typeof a)  &#x2F;&#x2F;underfind</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>不存在变量提升。在Let声明之前使用就会报错</li><li>暂时性死区：只要块级作用域内存在let命令，它所在的变量就“绑定”这个区域，不再受外部的影响</li><li>不允许重复声明<blockquote><p>注意：因为let的不存在变量提升和暂时性死区，因此在let之前使用该变量会报错，在此变量作用域外使用会无效。</p></blockquote></li></ol><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><pre><code>1. const声明一个只读常量，一旦声明，常量的值就不能更改2. const变量只声明不赋值就会报错3. 只在作用域内生效以及不允许重复声明4. const变量不能更改的实质是变量指向的那个内存地址所保存的数据不得改动.</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> const foo &#x3D; &#123;&#125;;</span><br><span class="line">     foo.prop &#x3D; 123;&#x2F;&#x2F;添加一个属性，没有问题</span><br><span class="line">     console.log(foo.prop)</span><br><span class="line">     foo&#x3D; 123;&#x2F;&#x2F;就会报错</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 浏览器的 ES6 环境</span><br><span class="line">function f() &#123; console.log(&#39;I am outside!&#39;); &#125;</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    &#x2F;&#x2F; 重复声明一次函数f</span><br><span class="line">    function f() &#123; console.log(&#39;I am inside!&#39;); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">&#x2F;&#x2F;上面在ES6代码当中会报错，ES6规定，浏览器始兴县要遵循一些规定</span><br><span class="line">&#x2F;&#x2F;1.允许在块级作用于内声明函数</span><br><span class="line">&#x2F;&#x2F;2.函数声明类似于var ,即会提升到全局作用于函数作用于的头部</span><br><span class="line">&#x2F;&#x2F;3.同时，函数声明还会提升到所在的块级作用于的头部</span><br><span class="line"></span><br><span class="line">注意：以上三条规则只对ES6浏览器内有效，其他环境还是将块级作用于的函数声明当做let处理</span><br></pre></td></tr></table></figure><blockquote><p>注意：在ES6中一共有6种赋值的方式，有var 和 function 命令，还有let 和const命令，以及import和class命令。var 和 function 命令声明的全局变量是顶层对象的属性；let、const和class命令声明全局变量，不属于顶层对象的属性。</p></blockquote><h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><ol><li>数组的解构赋值</li><li>概念：ES6允许按照一定的模式，从数组和对象中提取，对变量进行赋值<br>注意：要是被赋值一边有一项没有被赋值或者赋值underfind，则被称为解构失败；要是赋值一边有三个值，被赋值一边只有两个变量，则被称为不完全解构</li><li>匹配模式其实是懒散匹配，如第6行代码，如果赋值一方对应位置有值，x就不会管默认值是10,而当赋值一边【】啥都没有的时候，才取默认值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;模式匹配</span><br><span class="line">let [a , b, c] &#x3D; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">let [a ,[b,[c]]] &#x3D; [1,[2,[3]]]</span><br><span class="line"></span><br><span class="line">let [x &#x3D; 10] &#x3D;[20] &#x2F;&#x2F;x &#x3D; 20</span><br><span class="line"></span><br><span class="line">对象的解构赋值</span><br><span class="line">无序性：只要变量与属性同名，就能取到正确的值。当右边没有同名的属性，那么不叫取不到值而取得underfind</span><br><span class="line">let &#123;bar ,foo &#125; &#x3D; &#123;foo :234, bar:123&#125;</span><br><span class="line">&#x2F;&#x2F;无论赋值的一方的顺序是怎么样的，赋值都不影响</span><br><span class="line"></span><br><span class="line">let &#123;foo:bar&#125; &#x3D; &#123;foo:123&#125;</span><br><span class="line">        console.log(bar);&#x2F;&#x2F;123</span><br><span class="line">        console.log(foo);&#x2F;&#x2F; foo is not defined</span><br><span class="line"></span><br><span class="line">        let&#123;length&#125; &#x3D; &quot;123&quot; &#x2F;&#x2F;length &#x3D; 3</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;可用于嵌套</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  p: [</span><br><span class="line">    &#39;abcabc&#39;,</span><br><span class="line">    &#123; y: &#39;123123&#39; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; p, p: [x, &#123; y &#125;] &#125; &#x3D; obj;&#x2F;&#x2F;&#39;abcabc&#39; &#39;123123&#39;</span><br></pre></td></tr></table></figure><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const [a,b,c,d,e] &#x3D; &#39;hello&#39;;</span><br><span class="line"></span><br><span class="line">        console.log(a);</span><br><span class="line">        console.log(b);</span><br><span class="line">        console.log(d);</span><br><span class="line"></span><br><span class="line">        let&#123; length :len&#125; &#x3D; &#39;hello&#39;</span><br><span class="line">        console.log(len)</span><br><span class="line">&#x2F;&#x2F; a b l 5</span><br></pre></td></tr></table></figure></li></ol><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解构赋值时，如果等号右边是数值和布尔值，则会先转换成对象</span><br><span class="line">函数参数的解构赋值</span><br><span class="line">        function add([x,y])&#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        add([1,2])</span><br></pre></td></tr></table></figure><blockquote><p>不能使用圆括号的情况：<br>使用场景：</p></blockquote><ol><li>交换变量的值</li><li>从函数返回多个值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function example()&#123;</span><br><span class="line">    return [1,2,3];</span><br><span class="line">&#125;</span><br><span class="line">let [a,b,c] &#x3D; example();</span><br><span class="line"></span><br><span class="line">console.log(a,b,c) &#x2F;&#x2F;1 2 3</span><br></pre></td></tr></table></figure><ol start="3"><li>提取JSON数据–解构赋值对提取JSON对象中的数据，尤其有用</li></ol><p>便利Map结构：<br>部署了Iterator接口的对象，都可以用for…of循环遍历。配合变量的解构赋值，获取键名和键值就肥肠方便</p><h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><ol><li><p>字符串的遍历器接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &#96;hzfnb&#96;;</span><br><span class="line"></span><br><span class="line">for(let  condePoint of a )&#123;</span><br><span class="line">    console.log(condePoint)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; h z f n b</span><br></pre></td></tr></table></figure></li><li><p>模板字符串</p></li><li><p>增强字符串:可以保留字符串在编辑器的模式 ，如果代码中的模板字符串都要用反引号表示，则前面需要用反斜杠转义</p></li><li><p>在字符串中添加变量（表达式）</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3></li><li><p>${}对变量进行抓取</p></li><li><p>${} 对变量进行运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;hello&#39;;</span><br><span class="line">var newStr &#x3D; &#96;hello world&#96;;</span><br><span class="line"></span><br><span class="line"> var xm &#x3D; &#123;</span><br><span class="line">            age :19,</span><br><span class="line">            height:180,</span><br><span class="line">            name :&#39;xiaoming&#39;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var &#123;age ,name, height&#125; &#x3D; xm;</span><br><span class="line"></span><br><span class="line">        var newstr &#x3D;&#96;name: $&#123;name&#125; age: $&#123;age&#125; &#96;</span><br><span class="line">        console.log(newstr);&#x2F;&#x2F;通过对象的解构拿到对象的值， 再通过$&#123;&#125;直接取得这个值</span><br><span class="line">        &#x2F;&#x2F;$&#123;&#125;也是可以进行运算的，还可以添加方法</span><br><span class="line"></span><br><span class="line">        var x &#x3D; 3, y &#x3D; 5;</span><br><span class="line">        function getName()&#123;</span><br><span class="line">            return &#39;xiaoming&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        var str &#x3D; &#96;my name is $&#123;getName()&#125;&#96;;</span><br><span class="line">        console.log(str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        var arr &#x3D; [1,2,3,4,5];</span><br><span class="line">        var resStr &#x3D;&#96;$&#123;arr.map(function(item,index)&#123;</span><br><span class="line">            return &#96;$&#123;item&#125;: $&#123;index&#125;&#96;</span><br><span class="line">        &#125;)&#125;&#96;&#x2F;&#x2F;通过增强字符串与函数把值赋给另外一个变量（对象）</span><br></pre></td></tr></table></figure></li></ol><h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><ol><li>它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串<br>标签模板的实质，函数调用的特殊形式<br>重要应用，过滤HTML字符串–防止用户恶意注意内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">safeHtml &#96;&lt;p&gt;$&#123;name&#125; Welcome&lt;&#x2F;p&gt;&#96;</span><br><span class="line"></span><br><span class="line">function safeHtml(data)&#123;</span><br><span class="line">    var str &#x3D;  data[0]</span><br><span class="line">    for(let i &#x3D; 1; i&lt;arguments.length;i++)&#123;</span><br><span class="line">        var arg &#x3D; String(arguments[i])</span><br><span class="line"></span><br><span class="line">        str +&#x3D; arg.replace(&#x2F;&amp;&#x2F;g,&#39;&amp;&#39;).replace(&#39;&#x2F;&lt;&#x2F;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="字符串的新增方法"><a href="#字符串的新增方法" class="headerlink" title="字符串的新增方法"></a>字符串的新增方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String.fromCodePoint() --用于从Unicode编码返回对应的字符串</span><br><span class="line">String.raw()--用于转义字符串，往往用于模板字符串的处理方法</span><br><span class="line">        a &#x3D; String.raw&#96;hi\n\n$&#123;5&#125;!&#96;</span><br><span class="line">        console.log(a); &#x2F;&#x2F;hi\n\n5!</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;String.raw 作为正常的函数使用</span><br><span class="line">        a &#x3D; String.raw(&#123;raw:&#39;hzfnb&#39;&#125;,0,1,2)</span><br><span class="line">        console.log(a); &#x2F;&#x2F;h0z1f2nb</span><br></pre></td></tr></table></figure><ol><li>实例方法：codePointAt() –测试一个字符由两字节还是四个字节组成的最简单方法</li><li>实例方法：normailza()</li><li>includes(): 返回布尔值，表示是否找到了参数字符串</li><li>startsWith() ： 返回布尔值，表示参数字符串是否在原字符串的头部</li><li>endWith(): 返回布尔值，表示参数字符串是否在原字符串尾部<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &quot;hzfnb zf&quot;</span><br><span class="line">var r1 &#x3D; a.includes(&#39;hzfnb&#39;)</span><br><span class="line">var r2 &#x3D; a.startsWith(&#39;h&#39;)</span><br><span class="line">var r3 &#x3D; a.endsWith(&#39;f&#39;)</span><br><span class="line"></span><br><span class="line">console.log(r1,r2,r3)&#x2F;&#x2F;true true true</span><br></pre></td></tr></table></figure></li><li>实例方法： repeat()返回一个新的字符串，并将原字符串重复N次</li><li>实例方法：padStart() padEnd()：接受两个参数，第一个参数是字符串补全的位数，第二个填的是要补全的字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">padStart() 用于补全头部</span><br><span class="line">padEnd()  用于补全尾部</span><br><span class="line">        console.log(&#39;hzf&#39;.padStart(5,&#39;nb&#39;)) &#x2F;&#x2F;hzfnb</span><br></pre></td></tr></table></figure></li><li>实例方法：trimStart() , trimEnd();<br>分别用于消除字符串最前面的空格以及最后面的空格</li><li>实例方法：matchAll()<br>方法返回一个正则表达式在当前字符串的所有匹配</li></ol><h3 id="正则表达式的扩展"><a href="#正则表达式的扩展" class="headerlink" title="正则表达式的扩展"></a>正则表达式的扩展</h3><h4 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h4><ol><li>match()</li><li>replace()</li><li>search()</li><li>split()</li><li>u修饰符:含义为unicode模式，用来处理四个字节的UTF-16编码</li><li>点字符</li><li>i修饰符</li><li>y修饰符</li></ol><h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><p>函数的默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function Persion(name ,age &#x3D; 100)&#123;</span><br><span class="line">            console.log(name,age)</span><br><span class="line">        &#125;</span><br><span class="line">Persion(&#39;hs&#39;); &#x2F;&#x2F; hs 100</span><br><span class="line">Persion(&#39;hs&#39;,12); &#x2F;&#x2F; hs 12</span><br><span class="line"></span><br><span class="line">默认值与解构赋值的使用</span><br><span class="line">  function f1( &#123;x &#x3D; 0, y &#x3D; 0&#125; &#x3D;&#123;&#125;)&#123;</span><br><span class="line">           console.log(x,y)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function f2(&#123;x,y&#125; &#x3D; &#123;x:0,y:0&#125;)&#123;</span><br><span class="line">            console.log(x,y)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f1()</span><br><span class="line">        f2()</span><br><span class="line">        f1(&#123;x:1,y:2&#125;)</span><br><span class="line">        f2(&#123;x:1,y:2&#125;)</span><br><span class="line">        f1(&#123;x:1&#125;)</span><br><span class="line">        f2(&#123;x:1&#125;)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;0 0</span><br><span class="line">        &#x2F;&#x2F;0 0</span><br><span class="line"> &#x2F;&#x2F;1 2</span><br><span class="line">&#x2F;&#x2F;1 2</span><br><span class="line">&#x2F;&#x2F;1 0</span><br><span class="line">&#x2F;&#x2F;1 undefined   最后一个解构赋值之后表示为 &#123;x:1&#125; 所以y &#x3D; underfined</span><br><span class="line"></span><br><span class="line">参数作用域已经注意事项</span><br><span class="line">在函数体内用let定义的变量，不能提前当做参数（放在括号内）</span><br><span class="line">es6在参数默认值方面是使用let来定义的</span><br><span class="line">REST</span><br><span class="line">var arr &#x3D; [1,2,3,4,5];</span><br><span class="line">        fn.call(null,...arr) &#x2F;&#x2F;...相当于把括号去掉</span><br><span class="line">        fn.apply(null,arr) &#x2F;&#x2F;apply 要用数组的形式引入</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; (5) [1, 2, 3, 4, 5]</span><br><span class="line">        &#x2F;&#x2F; (5) [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">        function fn(...args)&#123;</span><br><span class="line">            console.log(args)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><blockquote><p>注意事项：箭头函数里面没有this这个对象，它只会依次找到父级，也没有arguments</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D;            ()   &#x3D;&gt;   num</span><br><span class="line">var f &#x3D; function  参数      return 参数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;箭头函数的嵌套</span><br><span class="line"> function fn(str)&#123;</span><br><span class="line">         return function()&#123;</span><br><span class="line">                return str.splite(&#96;&#96;)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     var fn &#x3D; str &#x3D;&gt; () &#x3D;&gt;str.splite(&#96;&#96;)</span><br></pre></td></tr></table></figure><h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h3 id="数组的合并"><a href="#数组的合并" class="headerlink" title="数组的合并"></a>数组的合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;dy1&#39;]</span><br><span class="line">        var arr1 &#x3D; [&#39;1,2,3,4,5&#39;]</span><br><span class="line">        var arr2 &#x3D; [&#39;false&#39;,NaN]</span><br><span class="line">        var newArr &#x3D; [...arr,...arr1,...arr2]</span><br><span class="line">        console.log(newArr)&#x2F;&#x2F;[&quot;dy1&quot;, &quot;1,2,3,4,5&quot;, &quot;false&quot;, NaN]</span><br><span class="line"></span><br><span class="line">        var arr3 &#x3D; [...&#39;hzf&#39;]</span><br><span class="line">        console.log(arr3);&#x2F;&#x2F;[&quot;h&quot;, &quot;z&quot;, &quot;f&quot;]</span><br><span class="line"></span><br><span class="line">Array.from()</span><br><span class="line">把类数组和可遍历的对象转换成数组</span><br><span class="line">Array.of()</span><br><span class="line"> 数组实例的方法copyWithin()</span><br><span class="line">   var arr &#x3D; [1,2,3,4,5]</span><br><span class="line">    &#x2F;&#x2F; Array.prototype.copyWithin(target ,start &#x3D; 0,end &#x3D; this.length))</span><br><span class="line">       console.log (arr.copyWithin(0,3))</span><br><span class="line">       &#x2F;&#x2F; 0 3 还有一位end没写出来，0代表从第0位开始，3代表start&#x3D;3, 第三位是4 end 没写表示到一直最后，</span><br><span class="line">       &#x2F;&#x2F;表示从4,5替换掉从0开始的两位 因此结果 &#x3D; 4,5,3,4,5</span><br></pre></td></tr></table></figure><h3 id="数组实例方法"><a href="#数组实例方法" class="headerlink" title="数组实例方法"></a>数组实例方法</h3><h4 id="fill-entries-，keys-values"><a href="#fill-entries-，keys-values" class="headerlink" title="fill() , entries()，keys()   values()"></a>fill() , entries()，keys()   values()</h4><ol><li>entries() 是对键值对的遍历</li><li>values() 是对键值的遍历</li><li>key() 是对键名的遍历<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1,2,3,4,5]</span><br><span class="line">       var a &#x3D; arr.keys()</span><br><span class="line">       console.log(a) &#x2F;&#x2F;Array Iterator &#123;&#125;</span><br><span class="line"></span><br><span class="line">       var arr1 &#x3D; new Array(5);</span><br><span class="line">       arr1.fill(7,3,4)</span><br><span class="line">       console.log(arr1)  &#x2F;&#x2F;(5) [empty x 3 ,7 empty x 3]</span><br><span class="line">       &#x2F;&#x2F;fill的用法是添加某个数，用法跟copywithin()差不多，</span><br><span class="line">       &#x2F;&#x2F;添加7这个数字，在第3跟第4个数之间插入数字7</span><br><span class="line"></span><br><span class="line">       var arr2 &#x3D; [&#39;2&#39;,2,3,4,5]</span><br><span class="line">       var a &#x3D; arr2.keys()</span><br><span class="line"></span><br><span class="line">       for([item, index] of arr.entries())</span><br><span class="line">       &#123;</span><br><span class="line">           console.log(item ,index)</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;entries 可以用于遍历数组，列出是第几位的并且把值打印出来</span><br><span class="line">       &#x2F;&#x2F;  0 &quot;2&quot;</span><br><span class="line">       &#x2F;&#x2F;  1  2</span><br><span class="line">       &#x2F;&#x2F;  2  3</span><br></pre></td></tr></table></figure></li></ol><h3 id="数组的实例方法"><a href="#数组的实例方法" class="headerlink" title="数组的实例方法"></a>数组的实例方法</h3><h4 id="includes-find-findIndex"><a href="#includes-find-findIndex" class="headerlink" title="includes() find() findIndex()"></a>includes() find() findIndex()</h4><ol><li>includes() ——返回一个布尔值，表示某个数组是否包含给定的值。如果包含则返回true，否则返回false</li><li>find() ——找到第一个符合条件的数组成员</li><li>findIndex() 返回第一个负荷而条件的数组成员的位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [20 , 4, -5, 10]</span><br><span class="line">        var str &#x3D; [arr.find((n) &#x3D;&gt; n &lt;19)]</span><br><span class="line">        console.log(str)    &#x2F;&#x2F;[4]</span><br></pre></td></tr></table></figure></li></ol><h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性的简洁表示法</span><br><span class="line"> var foo &#x3D; &#39;123&#39;</span><br><span class="line"> var bar &#x3D; &#123;foo&#125;</span><br></pre></td></tr></table></figure><h5 id="属性的可枚举性以及属性的遍历"><a href="#属性的可枚举性以及属性的遍历" class="headerlink" title="属性的可枚举性以及属性的遍历"></a>属性的可枚举性以及属性的遍历</h5><ol><li>对象的每个属性都有一个遍历对象（Descriptor）用来控制该属性的行为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;age :123,name:&#39;dv&#39;&#125;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(Object.prototype,&#39;toString&#39;))</span><br><span class="line">&#x2F;&#x2F;enumerable: false 说明不可枚举</span><br></pre></td></tr></table></figure><blockquote><p>但是有4种操作会忽略enumerable 为flase的属性</p><ol><li>for… in 循环：遍历对象自身的和继承的可枚举属性</li><li>object.keys()  返回对象自身的所有可枚举的属性的键名</li><li>JSON.stringify() 只串行话独享自身的可枚举属性</li><li>object.assign() （ES6新增）</li></ol></blockquote></li></ol><h3 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h3><ol><li>Object.is()</li></ol><p>ES5判断两个值知否相等只有 == 和 ===。它们的缺点在于， == 回自动转换数据类型， === 会使得Nan不等于自身，-0 不等于 +0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object.is()</span><br><span class="line">       console.log (Object.is(-0,+0))      &#x2F;&#x2F;false</span><br><span class="line">       console.log (Object.is(NaN,NaN))    &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><blockquote><p>class 一定要先定义再使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        class Person&#123;</span><br><span class="line">            constructor( name&#x3D;&#39;zf&#39;,age &#x3D; 18)&#123;</span><br><span class="line">                this.name &#x3D; name</span><br><span class="line">                this.age &#x3D; age</span><br><span class="line">            &#125; &#x2F;&#x2F;这里不能写  &#39;,&#39; 写了就报错</span><br><span class="line">            show()&#123;</span><br><span class="line">                console.log(this.age,this.name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var per &#x3D; new Person()</span><br><span class="line">        &#x2F;&#x2F; per.name 表示实例属性</span><br><span class="line"></span><br><span class="line">立即执行class</span><br><span class="line">var p &#x3D; new class&#123; &#x2F;&#x2F;这个类只能使用一次</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p> =&gt; 指向父级作用域，跟ES5里面的this指向有些不同</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>与es5的不同之处</p><ol><li>子类 <strong>proto</strong>表示构造函数的继承</li><li>子类 <strong>proto</strong>.prototype 表示方法的继承</li><li>注意：<strong>proto</strong>并不属实语言本身的特征，目前很多浏览器的JS引擎都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，推荐使用Object.getPrototypeof()来获取实例对象的原型，再为原型添加属性</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">            constructor()&#123;</span><br><span class="line">                this.name &#x3D; &#39;zf&#39;</span><br><span class="line">            &#125;</span><br><span class="line">            print()&#123;</span><br><span class="line">                console.log(this.name)&#x2F;&#x2F;console.log(&#39;father A&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        class B extends A&#123;</span><br><span class="line">            constructor()&#123;</span><br><span class="line">                super() &#x2F;&#x2F;为啥要调用super？</span><br><span class="line">                &#x2F;&#x2F;子类要调用super方法，才能使用this，给父级绑定才有this</span><br><span class="line">                this.name &#x3D; &#39;aasda&#39;</span><br><span class="line">            &#125;</span><br><span class="line">            print()&#123;</span><br><span class="line">                super.print() &#x2F;&#x2F;b.print() -&gt; father A</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var b &#x3D; new B()</span><br><span class="line">        &#x2F;&#x2F; b.name &#x3D; &#39;aasda&#39;</span><br><span class="line">        &#x2F;&#x2F; b.print() aasda</span><br></pre></td></tr></table></figure><h3 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h3><h4 id="Promise的含义：简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常来说是一个异步操作。）"><a href="#Promise的含义：简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常来说是一个异步操作。）" class="headerlink" title="Promise的含义：简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常来说是一个异步操作。）"></a>Promise的含义：简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常来说是一个异步操作。）</h4><ol><li>基本用法</li><li>三种状态<ol><li>pending 就绪状态</li><li>resolved 成功状态</li><li>rejected 失败状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实例方法</span><br><span class="line">Promise.all Promise.race</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ES6学习笔记&quot;&gt;&lt;a href=&quot;#ES6学习笔记&quot; class=&quot;headerlink&quot; title=&quot;ES6学习笔记&quot;&gt;&lt;/a&gt;ES6学习笔记&lt;/h2&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>CSS3学习笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/05/12/CSS3-note/"/>
    <id>https://fengzehe.github.io/blog/2019/05/12/CSS3-note/</id>
    <published>2019-05-12T06:47:13.000Z</published>
    <updated>2020-06-18T10:17:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CSS3学习笔记"><a href="#CSS3学习笔记" class="headerlink" title="CSS3学习笔记"></a>CSS3学习笔记</h4><p>CSS33只是版本号，目前主流浏览器都支持了，IE10以后也开始全面支持CSS3。</p><ul><li>CSS3提供了更加强大的且精准的选择器，提供多种背景填充方案，可以实现渐变颜色，可以改变元素的形状，角度等。可以加阴影效果，报纸布局，弹性盒子，ie6混杂模式的盒模型，新的计量单位，动画效果等<br>但CSS3并不是所有属性都通过了W3C标准，要查兼容性手册。<a id="more"></a></li></ul><h5 id="CSS3的特性"><a href="#CSS3的特性" class="headerlink" title="CSS3的特性"></a>CSS3的特性</h5><ol><li><p>border-radius –圆角，实现一个叶子的形状，画一个半圆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100px 100px 0 0；</span><br></pre></td></tr></table></figure></li><li><p>box-shadow  盒子的阴影  box-shadow   x代表偏移量，y代表偏移量， ，阴影模糊半径，阴影扩展半径，阴影颜色，投影方式<br>text-shadow<br>==不过shodow都是性能杀手==</p></li></ol><ol start="3"><li><p>线性渐变 语法：linear-gradient[方向，颜色，颜色，颜色…]</p></li><li><p>径向渐变 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">radial-gradient(shape at position ,color[percent ] ,color)</span><br></pre></td></tr></table></figure></li><li><p>shape ：放射的形状，可以为原型circle 或拖延ellipse,position 为圆心位置</p></li><li><p>border-image</p></li><li><p>border-origin:content-box / border-box / padding-box</p></li><li><p>background-clip :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-box &#x2F; padding-box &#x2F;conteent-box  &#x2F;no-clip</span><br></pre></td></tr></table></figure><p>参数分别从边框，或内填充，或内容区域向外剪裁背景</p></li><li><p>text :background-clip :text;</p></li><li><p>background-size :auto |&lt;长度值&gt;|&lt;百分比&gt;</p></li><li><p>background-position: center</p></li></ol><h5 id="CSS3-选择器："><a href="#CSS3-选择器：" class="headerlink" title="CSS3 选择器："></a>CSS3 选择器：</h5><h6 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h6><ol><li>E[att ^= “val” ]{….}  选择匹配元素E，且E元素定义了属性att ，其属性值以val 开头的任何字符串</li><li>E[att $= “val”]{….} 选择匹配元素E ，且E元素定义了属性att ,其属性以val为结尾的任何字符串</li><li>E[att *= “val”]{….}  选择匹配元素E， 且E元素定义了属性att ，其属性值任意位置出现了’val’ ,即属性值包含了“val”，位置不限。</li><li>~=的意思是只要有item 的元素都被选中了。</li></ol><h6 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h6><p>伪元素选择：伪元素的效果是需要通过添加一个实际的元素才能达到的.</p><p>CSS3 对伪元素进行一定的调整，在以前的基础上增加了一个：也就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::first-letter, ::first-line ,::before ::after</span><br></pre></td></tr></table></figure><p>另外还增加了一个 ::selection</p><h6 id="root选择器"><a href="#root选择器" class="headerlink" title="root选择器"></a>root选择器</h6><p>等同于html ,但权重比html更高</p><h6 id="not-选择器"><a href="#not-选择器" class="headerlink" title="not 选择器"></a>not 选择器</h6><p>除了那一个，其他都选中</p><h6 id="empty-空标签选择器"><a href="#empty-空标签选择器" class="headerlink" title="empty 空标签选择器"></a>empty 空标签选择器</h6><h6 id="target-目标元素选择器"><a href="#target-目标元素选择器" class="headerlink" title="target 目标元素选择器"></a>target 目标元素选择器</h6><p>被锚点的元素，被选中的元素被进行操作。</p><h5 id="伪类选择器："><a href="#伪类选择器：" class="headerlink" title="伪类选择器："></a>伪类选择器：</h5><ol><li>first-child 第一个子元素</li><li>last-child 最后一个子元素</li><li>:nth-child（）{}  第XXX个子元素，n代表变量自然数</li><li>first-of-type 第一个子元素</li><li>:last-of-child 最后一个子元素</li><li>:only-of-type  唯一一个子元素</li></ol><p>表示状态的伪类选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:enabled 可用的元素</span><br><span class="line">:disabled  禁用的元素</span><br></pre></td></tr></table></figure><p>有些表单元素才会有这样的元素，例如输入框，密码框，复选框</p><p>:check  已经被选中的状态   check-box<br>read-only  选中只读的元素</p><h6 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h6><p>::first-letter  首个字母<br>:first-line 首行<br>::selection  被选中时候的文本</p><h6 id="条件选择器"><a href="#条件选择器" class="headerlink" title="条件选择器"></a>条件选择器</h6><p>E &gt; F 直接子元素选择器<br> E + F  后面紧挨着的兄弟节点<br> E ~ F 后面的兄弟节点</p><p>例如单选框旁的div ，被选中的时候隔壁也被选中。 input:checked + div</p><h5 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h5><h6 id="形状变换"><a href="#形状变换" class="headerlink" title="形状变换"></a>形状变换</h6><ol><li>transform 可以实现元素的形状，角度，位置等变化（包括旋转）。transform: rotateX /Y/ Z(  deg);不写默认是Z。</li><li>rotate3d(x , y, z, Angel)</li><li>scale () 以x/y 轴进行缩放</li><li>scale(x,y)接受两个值，如果第二个参数未提供，则第二个参数使用第一个参数的值。</li><li>skew() 对元素进行倾斜扭曲<br>shew（） 接受两个值，分别对应X轴 和Y轴， 如果第二个参数未提供，则默认为0；</li><li>translate(x ,[y])  移动</li><li>使用CSS3属性实现水平垂直居中当使用：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top: 50%;left: 50%;， 是以左上角为原点，故不处于中心位置。</span><br><span class="line">    translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。</span><br></pre></td></tr></table></figure><ol start="8"><li>transition 过渡动画</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition 第一项选择属性(什么width height fontsize opacity ，就是一项属性，用于监听)，第二项选择时间，第三项选择速度，第四项指定过渡函数，第五项为动画的延迟时间</span><br></pre></td></tr></table></figure><img src="/blog/blog/2019/05/12/CSS3-note/2019/05/12/CSS3-note/1.png" class><ol start="9"><li>animation  动画<ol><li>animation-iteration-count   属性主要用来定义动画的播放次数</li><li>animation-direction 。normal 正常播放， reverse 反向播放</li><li>animation-play-state 用来控制动画的播放状态 running播放，paused 暂停。</li></ol></li></ol><h5 id="CSS-多列布局"><a href="#CSS-多列布局" class="headerlink" title="CSS 多列布局"></a>CSS 多列布局</h5><p>为了能在Web页面中方便实现类似报纸，杂志那种多列排版的布局，W3C特意给CSS3增加了一个多列布局。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">columns:[column-width][column-count]  columns:2;  变成两列</span><br><span class="line">column-gap ：</span><br></pre></td></tr></table></figure><p> 设置列与列之间的宽度，直接用数值即可（eg:10px）<br>column-span  设置多列布局的子元素可以跨列，类似标题效果。</p><h5 id="CSS3-盒模型："><a href="#CSS3-盒模型：" class="headerlink" title="CSS3 盒模型："></a>CSS3 盒模型：</h5><p>IE6混杂模式，首先要触发一个怪异模式。 在IE6混杂模式盒模型下(IE6及以下浏览器)，内容宽度（盒子） = width - padding -border.width包含padding 和 border<br>W3C标准下的空间高度（盒子）= width +padding +border;  width 为内容宽度，不包括padding 和 border</p><h5 id="CSS3-弹性盒子-display-flex"><a href="#CSS3-弹性盒子-display-flex" class="headerlink" title="CSS3 弹性盒子 display :flex"></a>CSS3 弹性盒子 display :flex</h5><p>==flex为复合属性，必须配合父元素display :flex使用==<br>如图</p><img src="/blog/blog/2019/05/12/CSS3-note/2019/05/12/CSS3-note/2.png" class><h6 id="6个属性"><a href="#6个属性" class="headerlink" title="6个属性"></a>6个属性</h6><ol><li><p>flex-grow    把盒子分成多少份，要是1 的话就分成1分自己独占。默认是0；</p></li><li><p>flex-shrink 多出盒子的部分，按照比例的大小砍掉相应的大小，即比例越大，被砍的越大。</p></li><li><p>flex-basis    伸缩基准值，占据主轴空间。</p></li><li><p>flex    order    可以进行排序，从小到大进行排列</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">align-self &#123;</span><br><span class="line">auto &#x2F; flex-start &#x2F;flex-end  &#x2F; center &#x2F;baseline（基准线对齐） &#x2F;stretch</span><br><span class="line">&#125;</span><br><span class="line">主轴 &#x2F;侧轴&#x2F;交叉轴</span><br></pre></td></tr></table></figure></li><li><p>flex-direction 决定主轴的方向<br>row 从左向右， row-reverse , column ,column-reverse</p></li><li><p>flex-wrap 是否换行</p></li><li><p>flex-flow 是dirction 和 wrap的简写方式</p></li><li><p>justify-content<br> 1.flex-start    左对齐</p><ol start="2"><li>flex-end    右对齐</li><li>conter     居中</li><li>space-between    两端对齐，项目之间的间隔都相等</li><li>space-around 每个项目两侧的间隔相等。</li><li>align-items  属性如何在侧轴上对齐</li><li>flex-start 交叉轴的起点对齐。</li><li>flex-end 交叉轴终点对齐</li><li>center 交叉轴中点对齐</li><li>baseline 项目的第一行文字基准线对齐</li><li>stretch 如果未设置高度或设为auton ,将占满整个容器的高度</li></ol></li></ol><p>transparent 透明色颜色值。</p><h6 id="CSS3响应式布局"><a href="#CSS3响应式布局" class="headerlink" title="CSS3响应式布局"></a>CSS3响应式布局</h6><p>通过设备不同的宽度，相应出不同的布局。这就叫做响应式布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">width&#x3D;device-width 意思是宽度等于设备的宽度，user-scalable &#x3D; no 意思是不允许用户缩放</span><br></pre></td></tr></table></figure><p>媒体查询：媒体查询是向不同设备提供不同样式的一种方式，为每种类型的用户提供了更佳的体验。<br>CSS2 :mdeia type 是CSS2中一个非常有用的属性，通过media type 我们可以对不同设备执行不同的样式<br>CSS3 mdeia query 是CSS3对meida type的增强。</p><p>添加方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一种插入样式，需要多个CSS文件</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; media&#x3D;&quot;screen and (max-width:800px)&quot; href&#x3D;&quot;.&#x2F;text.css&quot;&gt;</span><br></pre></td></tr></table></figure><p>第二种插入方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:300px)&#123;</span><br><span class="line">    div&#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width:301px)&#123;</span><br><span class="line">    div&#123;</span><br><span class="line">        width: 499px;</span><br><span class="line">        height: 293px;</span><br><span class="line">        background-color: aqua;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and not only 这三个值。only是仅有的意思。 and是再添加这个属性的意思</p><p>demo–&gt;从四列变三列再变成两列一列的CSS3响应式布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">.wrapper&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    width: 100%;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.wrapper div&#123;</span><br><span class="line">    width: 20%;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.wrapper div img&#123;</span><br><span class="line">    width:100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width:1000px)&#123;</span><br><span class="line">    .wrapper div&#123;</span><br><span class="line">        width: 25%;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width:800px)&#123;</span><br><span class="line">    .wrapper div&#123;</span><br><span class="line">        width: 33.33%;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width:400px)&#123;</span><br><span class="line">    .wrapper div&#123;</span><br><span class="line">        width: 50%;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width:200px)&#123;</span><br><span class="line">    .wrapper div&#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CSS3动画</span><br><span class="line">transform-style ：flat | preserve-3d；</span><br><span class="line">注意：属性需要设置在父元素中，高于任何嵌套的变形元素。</span><br><span class="line">设置了tranform-style :preserve-3d的原型，就不能设置overflow:hidden 否则preserve-3d失效</span><br><span class="line">元素旋转，其他轴也在旋转</span><br><span class="line">translate3d 这样写好了之后浏览器就会使用GPU加速。</span><br><span class="line"></span><br><span class="line">下图代码块为爱的魔力转圈圈</span><br><span class="line"></span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .wrapper&#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            transform-style: preserve-3d;</span><br><span class="line">            &#x2F;* transform: rotateX(-20deg); *&#x2F;</span><br><span class="line">            margin-top: 200px;</span><br><span class="line">            animation: turn 5s linear infinite;</span><br><span class="line">        &#125;</span><br><span class="line">        .wrapper div&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            opacity: 0.5;</span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: 200px;</span><br><span class="line">            color :#fff;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .wrapper .item:nth-of-type(1)&#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">            transform: rotateY(0deg) translateZ(200px);</span><br><span class="line">        &#125;</span><br><span class="line">        .wrapper .item:nth-of-type(2)&#123;</span><br><span class="line">            background-color: yellow;</span><br><span class="line">            transform: rotateY(60deg) translateZ(200px);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .wrapper .item:nth-of-type(3)&#123;</span><br><span class="line">            background-color: green;</span><br><span class="line">            transform: rotateY(120deg) translateZ(200px);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .wrapper .item:nth-of-type(4)&#123;</span><br><span class="line">            background-color: blueviolet;</span><br><span class="line">            transform: rotateY(180deg) translateZ(200px);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .wrapper .item:nth-of-type(5)&#123;</span><br><span class="line">            background-color: pink;</span><br><span class="line">            transform: rotateY(240deg)translateZ(200px);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .wrapper .item:nth-of-type(6)&#123;</span><br><span class="line">            background-color: yellowgreen;</span><br><span class="line">            transform: rotateY(300deg) translateZ(200px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @keyframes turn&#123;</span><br><span class="line">            0%&#123;</span><br><span class="line">                transform:rotateX(-20deg) rotateY(0deg);</span><br><span class="line">            &#125;</span><br><span class="line">            100%&#123;</span><br><span class="line">                transform:rotateX(-20deg) rotateY(-360deg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;item&quot;&gt;6&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;CSS3学习笔记&quot;&gt;&lt;a href=&quot;#CSS3学习笔记&quot; class=&quot;headerlink&quot; title=&quot;CSS3学习笔记&quot;&gt;&lt;/a&gt;CSS3学习笔记&lt;/h4&gt;&lt;p&gt;CSS33只是版本号，目前主流浏览器都支持了，IE10以后也开始全面支持CSS3。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS3提供了更加强大的且精准的选择器，提供多种背景填充方案，可以实现渐变颜色，可以改变元素的形状，角度等。可以加阴影效果，报纸布局，弹性盒子，ie6混杂模式的盒模型，新的计量单位，动画效果等&lt;br&gt;但CSS3并不是所有属性都通过了W3C标准，要查兼容性手册。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="CSS3" scheme="https://fengzehe.github.io/blog/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>JQuery笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/05/12/JQuery-note/"/>
    <id>https://fengzehe.github.io/blog/2019/05/12/JQuery-note/</id>
    <published>2019-05-12T06:20:06.000Z</published>
    <updated>2020-06-18T10:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JQuery学习笔记"><a href="#JQuery学习笔记" class="headerlink" title="JQuery学习笔记"></a>JQuery学习笔记</h4><h5 id="jQuery是啥呢？"><a href="#jQuery是啥呢？" class="headerlink" title="jQuery是啥呢？"></a>jQuery是啥呢？</h5><p>它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</p><a id="more"></a><h5 id="jQuery的用法："><a href="#jQuery的用法：" class="headerlink" title="jQuery的用法："></a>jQuery的用法：</h5><h6 id="选择元素："><a href="#选择元素：" class="headerlink" title="选择元素："></a>选择元素：</h6><ol><li>$(); 里面和CSS一样，不过对选择出的一组元素，一起处理，省略循环，这里是js不允许的。</li><li>里面可以写CSS选择器原生dmo,jQuery对象、 null  /undefind / function(){}    selector/content等</li><li>jQuery特有的选择规则，选出来是jquery对象</li><li>filter可以用来筛选，例如说筛选类名。not的话可以用来反向选择，没有这一项的就被选中，is则相反。has说明里面有这一项的选项被选中。find跟has的区别是，找到这里有这一项的然后选中。</li><li>jQuery可以进行链式操作。</li><li>sizzle是用来选择特殊写法的，是查到dom最快的方式。</li></ol><h6 id="函数写法："><a href="#函数写法：" class="headerlink" title="函数写法："></a>函数写法：</h6><ol><li>都是函数式的写法。</li><li>CSS取值相当于getComputed，赋值相当于<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.style.***</span><br></pre></td></tr></table></figure>，就写width，然后啥也不写</li><li>css赋值一组，取值取一个（）</li><li>xxx.setAttribute(‘son’,’’Feng)  这样就可以给对象添加属性了。</li><li>attr() 用于设置或返回被选中元素的属性值</li><li>prop() 如果是检索html元素则使用attr()替代。</li><li>next()下一个兄弟节点。</li><li>prev()上一个兄弟节点</li><li>index 当前兄弟节点</li><li>addClass removeClass</li><li>toggleClass 删除或者添加类名  没有的话帮你添加，有话帮你删除</li><li>insertBefore  插入到谁谁的前面。</li><li>appendTo()   –这个比较常用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A添加到B的里面（添加到最后一个子元素后） $(&#39;p&#39;).appendTo($(&#39;ul&#39;)</span><br><span class="line">D.append（C）  D里加上C</span><br></pre></td></tr></table></figure></li><li>remove detach 可以删除元素并且可以return 删除的元素。remove的话点击删除之后也删除了方法，因此第二次点击不能再删除了，而detach则可以。不断的进行删除和添加</li><li>on方法绑定时间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.on(&#39;click&#39; ,&#39;a&#39;, function()&#123;&#125;)  &#x2F;&#x2F;off可以解除绑定 $(&#39;.item&#39;).off(&#39;click&#39;), 如果想指定解绑的元素，那就要传值以更精准</span><br></pre></td></tr></table></figure><ol start="16"><li>one() 只绑定之间一次<br>scrollTop()  滚出去的高度</li><li>动态生成标签<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;&lt;div&gt;&lt;&#x2F;div&gt;&#39;)</span><br></pre></td></tr></table></figure>经常用于动态添加图片或者选项框</li></ol><h5 id="关于事件："><a href="#关于事件：" class="headerlink" title="关于事件："></a>关于事件：</h5><ol><li><p>时间对象 e-&gt;e.pageX 相对文档而言，e.clinetX 相对于浏览窗口而言。 e.which 哪个键或按钮  e.button哪个鼠标按键被按</p></li><li><p>e.preventDefalut()  s.stopPrpagation()  return false;  这些都是用来解绑事件的</p></li><li><p>offset().left/top position().left/top。</p><ol><li>offset()方法返回或设置匹配元素相对于文档的偏移（位置）。</li></ol></li><li><p>parent() 返回父节点</p></li><li><p>offsetParent() 返回离它最近有定位的父级</p></li><li><p>paerents()  返回多个父级</p></li><li><p>closet()  查找最近的祖先节点</p></li><li><p>val是jQuery里面代表.value的参数</p></li><li><p>each 遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;li&#39;)each(function (index  , ele )&#123;&#125; )</span><br></pre></td></tr></table></figure></li><li><p>end() 回退操作,可以使jQuery 可以连续实现点操作。就说可以用一行代码搞定。</p></li><li><p>slblings()  当前元素节点的所有兄弟节点<br>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;li.third-item&#39;).siblings().css(&#39;background-color&#39;, &#39;red&#39;);</span><br></pre></td></tr></table></figure></li><li><p>prevAll()  当前元素上面的所有兄弟节点</p></li><li><p>nextAll() 当前元素下面的所有兄弟节点</p></li><li><p>prevUntil()  nextUntil() 掐头去尾选中元素，传jQuery 对象dom</p></li><li><p>clone 克隆节点，参数为true的时候，事件也能克隆</p></li><li><p>wrap 包裹的意思  wrapall    包裹选中所有的元素 会破坏结构  unwrap 接触包装，接过话标签不能删除。</p></li><li><p>A.add(B)  选中元素A和B集中操作。</p></li><li><p>slice(0，2)  截取，算头不算尾</p></li><li><p>serialize 串联表单数据 serializeArray 串联数据成数组</p></li><li><p>animate()</p><ol><li>参数target</li><li>参数durition</li><li>参数代表速度变化方式</li><li>回调函数</li></ol></li><li><p>stop(true, true) 停止当前所有的运动，停在当前目标带点  ,后面的参数决定是否立即到达目标点上</p><ol><li>是否停止后续所有运动     false：不停止，继续运动  true :停止后续所有运动</li><li>是否立即到达当前目标点     flase :不到达    true：到达</li></ol></li></ol><p>22.stop（flase ,true） 跳过当前运动并到达目标点，执行后续运动</p><ol start="23"><li><p>finish()  停止当前运动</p></li><li><p>delay （）延迟，参数，延迟运动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jquery.easing.js 是专门用来做jQuery 运动的.</span><br></pre></td></tr></table></figure></li><li><p>slideToggle(speed ,callback)  通过滑动效果来切换元素的可见状态</p></li><li><p>sildeUp   sildedown   隐藏起来元素/显示元素——根据之前的不同状态进行切换- none–block  or  block–none</p></li><li><p>toggleClass(active)  对设置或移除备选元素的一个或多个类进行切换</p></li><li><p>fade in/out   淡入淡出</p></li><li><p>tigger 方法触发被选元素的指定事件类型。<br>==tigger出发事件是会冒泡，触发里面会影响外面  tigger可以触发自定义事件==</p></li></ol><h5 id="工具方法："><a href="#工具方法：" class="headerlink" title="工具方法："></a>工具方法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以$.xxx  jQuery.xxx这种方式调用 ，此类方法定位在jQuery 函数上面</span><br></pre></td></tr></table></figure><p>$.type()  判断 参数的数据类型<br> 原生js判断类型的三种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. arr.instanceof Aarray</span><br><span class="line">2. arr.constructor &#x3D;&#x3D;Array</span><br><span class="line">3. Object.prototype.toString.call(arr)</span><br></pre></td></tr></table></figure><p>1,2两种有局限性，3 比较通用</p><p>trim()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.trim 消除空格</span><br></pre></td></tr></table></figure><p>$proxy() 改变this指针方向 参数1：function , 参数2：函数执行期上下文。</p><p>$noConflict() 防止冲突 在很多javascript库使用$作为一个函数或变量名，正如我们同时需要使用jQuery和其他库一样，我们可以使用$.noConfilct把$控制权交给其他库。</p><p>$.parseJSON()  字符转换成json ,要求非常严格，外部是单引号，内部属性是双引号，不需要回车符</p><p>$.makeArray 把类数组转换成数组。</p><h5 id="jQuery高级方法："><a href="#jQuery高级方法：" class="headerlink" title="jQuery高级方法："></a>jQuery高级方法：</h5><p>$.extend()  插件扩展1 提供最新的jQuery 工具方法</p><p>$.fn.extend()  插件扩展2 提供最新的jQuery 实例方法，是实例不是工具方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编写方法1， $.extend(&#123;keftTrim :function ()&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.fn.extend(&#123;drag : function()&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. var cd &#x3D; $.Callback()   回调函数--》返回回调对象</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. once 只执行一次fire()  方法 放在回调函数的参数里面。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var cd &#x3D; $.Callbacks(&#39;once&#39;);</span><br><span class="line">cd.add(fn1 ,fn2 ,fn3);</span><br><span class="line">cd.fire();</span><br></pre></td></tr></table></figure><p>memory记忆  前面触发函数，后面添加也会被添加并触发  unique也是只执行一遍</p><p>$.Deferred() 延迟对象相当于有状态的Callbacks();</p><p>添加函数；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">donefailprogress</span><br><span class="line">触发成功，   失败 ，    进行中</span><br></pre></td></tr></table></figure><p>触发函数：<br>resolve          reject    notify</p><p>$.deferred.promise() —-&gt;不能触发函数（无状态）</p><p>$(when) —-&gt;返回的是延迟对象，参数也是延迟对象。当参数延迟对象全部触发done的时候最后会触发when返回延迟对象的done函数。</p><ol><li>延迟对象作用控制的关键点，做链式运动的效果</li><li>$.ajax这种有状态的异步操作核心是deferred</li><li>when当发生多个ajax请求的时候，因为都是异步的，所以可以用多个deferred ，每当ajax 成功后我们触发一个，最后全部成功在when后一并处理。</li></ol><p>$() 里面可以填什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(false &#x2F;null &#x2F;undefined)</span><br><span class="line"> $(&#39;&lt;li&gt;,&lt;&#x2F;li&gt;&#39;)   $(&lt;li&#x2F;&gt;s1234)  $(&#39;&lt;li&gt;&#39;, &#123;html : 123 ,dg :&#39; ds&#39;&#125;)</span><br><span class="line">$(&#39;#id&#39; &#x2F;  &#39;.class&#39;   &#x2F;  div &#x2F; ul &#x2F;li &#x2F;    li:eq(0))</span><br><span class="line">$(dom)</span><br></pre></td></tr></table></figure><p>//在JQuery中，init()函数里面会判断返回的类型，如果是DOM则是因为后面有.nodeType<br>$(function () {})<br>$($())</p><p>jQuery .extend()  拓展工具方法<br>$().extend()   拓展实例方法</p><p>extend：<br>拓展<br>合并（传两个参数 ，合并到第一个对象里面去）</p><p>原始值的话并不会变化，而改个引用值就ok。</p><p>extends的四种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.extend(obj1)</span><br><span class="line">$.extend(obj1, obj2)</span><br><span class="line">$.extend(true ,obj1)</span><br><span class="line">$.extend(true ,obj1,obj2)</span><br></pre></td></tr></table></figure><p>其实就是要关注target是什么，i是什么（从第几位开始传)，如果前面有true就往后挪一位.</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JQuery学习笔记&quot;&gt;&lt;a href=&quot;#JQuery学习笔记&quot; class=&quot;headerlink&quot; title=&quot;JQuery学习笔记&quot;&gt;&lt;/a&gt;JQuery学习笔记&lt;/h4&gt;&lt;h5 id=&quot;jQuery是啥呢？&quot;&gt;&lt;a href=&quot;#jQuery是啥呢？&quot; class=&quot;headerlink&quot; title=&quot;jQuery是啥呢？&quot;&gt;&lt;/a&gt;jQuery是啥呢？&lt;/h5&gt;&lt;p&gt;它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。&lt;/p&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JQuery" scheme="https://fengzehe.github.io/blog/tags/JQuery/"/>
    
  </entry>
  
  <entry>
    <title>javascript学习笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/05/11/javascript-note/"/>
    <id>https://fengzehe.github.io/blog/2019/05/11/javascript-note/</id>
    <published>2019-05-11T09:22:32.000Z</published>
    <updated>2020-06-18T10:18:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JavaScript笔记"><a href="#JavaScript笔记" class="headerlink" title="JavaScript笔记"></a>JavaScript笔记</h4><img src="/blog/blog/2019/05/11/javascript-note/2019/05/11/javascript-note/map.png" class title="这是js思维导图"><h5 id="Web-发展史："><a href="#Web-发展史：" class="headerlink" title="Web 发展史："></a>Web 发展史：</h5><ol><li>Mosaic：是全世界第一款可以显示图片的浏览器</li><li>Netscape Navigator -&gt;2003 firefox 浏览器</li><li>IE6 -&gt;IE6浏览器</li><li>2008 -&gt; Chrome 浏览器<a id="more"></a></li></ol><ul><li>关于浏览器的内核部分：</li></ul><ol><li>渲染引擎（语法规则和渲染）</li><li>js引擎</li><li>其他模块</li></ol><ul><li><p>JavaScript的语言特点：</p><ol><li>解释性语言 –（不需要编译成文件）跨平台</li><li>单线程</li><li>ECMA标注 ECMAscript</li></ol></li><li><p>JavaScript执行队列：<br>  执行片段A1-&gt;执行片段A2-&gt;执行片段A3 （争抢时间片）</p></li></ul><ul><li>主流浏览器及其内核：<table><thead><tr><th>主流浏览器</th><th>内核</th></tr></thead><tbody><tr><td>IE</td><td>trident</td></tr><tr><td>Chrome</td><td>wekit/blink</td></tr><tr><td>firefox</td><td>grcko</td></tr><tr><td>Opera</td><td>presto</td></tr><tr><td>Safari</td><td>webkit</td></tr></tbody></table></li></ul><ul><li>引入javascript的两种方式  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;script&gt;&lt;&#x2F;script&gt;</span><br><span class="line">2.&lt;script src&#x3D;&#39;.js&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>js变量名的命名规则</li></ul><ol><li>变量名必须以英语字母 ,_ ,$开头。</li><li>变量名里面可以包括英文字母，_还有$.</li><li>不可以用系统的关键字还有保留字作为变量名。</li></ol><h5 id="JavaScript基本语法："><a href="#JavaScript基本语法：" class="headerlink" title="JavaScript基本语法："></a>JavaScript基本语法：</h5><p>数据类型分为原始值还有引用值</p><ol><li>==原始值有：number , boolean , String ,undefinded ,null==</li><li>==引用值有：array ,object ,funciton ,date ,regexp==</li></ol><ul><li>几个注意点：</li></ul><ol><li>==javascript对象才能拥有方法，然而number，String，boolean也可以拥有自己的方法，null和underfind是无法拥有方法的值。==</li><li>对象和数组属于可变类型，javascript程序可以更改对象属性值和数组元素的值。</li><li>数字，布尔值、null，和undefined属于不可变类型。</li><li>==原始值和引用值的区别在于，原始值存在于stack(栈)当中，规则是先进去的最后出来。<br>而引用值是存在heap（堆）里面的 ，引用值拷贝的是地址。==</li></ol><p>String的方法：<br>在javascript权威指南中，笔者列举出了许多字符串可调用的方法。</p><h5 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h5><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ - * &#x2F;</span><br><span class="line">不过特别要注意的是，任何“+”碰到字符串，都会变成字符串连接符。</span><br></pre></td></tr></table></figure>比较运算符：</code></pre><p>字符串的比较是ASCII码数值的比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Infinity &#x3D;&#x3D; Infinityundefind &#x3D;&#x3D; undenfind</span><br></pre></td></tr></table></figure><blockquote><p>特别注意的是 NaN!= NaN无穷大除以无穷大，给人以负数作开方运算或者算术云算法不是数字或无法转换为数字的操作数一起使用时都将返回NaN</p></blockquote><ul><li><p>逻辑运算符：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; || !</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li>与运算符-&gt;&amp;&amp;，在运算中，undefind ,null ,Nan ,” “ ,0 ,flase ,会转换成false</li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例： var a &#x3D;1 &amp;&amp; 2;</span><br></pre></td></tr></table></figure></code></pre><p>   先看表达式前面1，直接转换成true，然后知己输出第二个表达式，若第一个表达式为false，则直接输出为0；</p><h6 id="或运算符"><a href="#或运算符" class="headerlink" title="或运算符"></a>或运算符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;||</span><br></pre></td></tr></table></figure><pre><code>在运算中，寻找一个真值，第一个为真则直接返回第一个值。若第一个为假，而又只有两个值，则返回第二个值，无论真假。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">左移（&lt;&lt;）</span><br><span class="line">将一个值左移相当于它乘以2，7&lt;&lt;2 &#x3D; 28</span><br><span class="line"></span><br><span class="line">右移（&gt;&gt;）</span><br><span class="line">将一个值右移相当于它除以2， 7&gt;&gt;1&#x3D;3 ，-7&gt;&gt;1&#x3D;-4</span><br></pre></td></tr></table></figure><h5 id="条件语句："><a href="#条件语句：" class="headerlink" title="条件语句："></a>条件语句：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(条件)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2. switch(1)&#123;</span><br><span class="line"></span><br><span class="line">    case(1):</span><br><span class="line">      console.log(&#39;a&#39;);</span><br><span class="line">break;       &#x2F;&#x2F;switch这种选择语句，遇到合适条件的case才会执行，而却会把全部的case看一遍，如果在只有一种</span><br><span class="line">  &#x2F;&#x2F;条件下的case，则可以用break；停止运行。减少资源浪费。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象：</span><br><span class="line">var obj &#x3D;&#123;</span><br><span class="line">属性名 ：&quot;属性值&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>typeof可以判别的值有：number，String，boolean ，object，undefined，function；这6种。<br>而typeof 在辨别null 和 Array的时候一律返回object 。</p></blockquote><h5 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h5><h6 id="显示类型转换："><a href="#显示类型转换：" class="headerlink" title="显示类型转换："></a>显示类型转换：</h6><ol><li><p>var num = Number(‘123’)；<br>注意：undefined -&gt;Number (Nan)</p></li><li><p>parseInt(‘10’ ,16)<br>可以把任何东西转换成整形，而且可以进行10进制，16进制的转换。</p></li><li><p>parsefloat<br>把数据转换成浮点类型。“123abc”可以识别数字并返回。</p></li><li><p>boolean：会把underfined ,null ,0 ,-0 ,NaN ,”” 转换成false。</p></li><li><p>toString:    将返回一个表示调用这个方法的对象值的字符串。</p></li></ol><h6 id="隐式类型转换："><a href="#隐式类型转换：" class="headerlink" title="隐式类型转换："></a>隐式类型转换：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.isNan()</span><br><span class="line">2.+ -&gt;String类型</span><br><span class="line">3. - *  &#x2F; % -&gt;number类型</span><br><span class="line">4. ！&#x3D;</span><br></pre></td></tr></table></figure><h6 id="隐式类型转换：-1"><a href="#隐式类型转换：-1" class="headerlink" title="隐式类型转换："></a>隐式类型转换：</h6><ol><li>减号,乘号,除号,取模等操作会尝试将他们所操作转换为数字Number，如果没办法转换成数字，结果就是Nan</li><li>大于，小于，大于等于，小于等于，跟上面一样。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D; ！&#x3D;</span><br></pre></td></tr></table></figure><ol><li>字符串 op 字符串，不会进行类型转换，直接比较；</li><li>对象op对象，引用都指向同一个对象才为true</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean(Nan) &#x3D;&#x3D; false;</span><br><span class="line">null &#x3D;&#x3D; undefinded  &#x2F;&#x2F;  true</span><br></pre></td></tr></table></figure><h6 id="不发生类型转换："><a href="#不发生类型转换：" class="headerlink" title="不发生类型转换："></a>不发生类型转换：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x2F;&#x2F;绝对相等</span><br><span class="line">如果两个值为数字且数值相等，则它们相等。如果一个数值为0，另一个数值为-0，则它们同样相等。</span><br><span class="line">！&#x3D;&#x3D;&#x2F;&#x2F;绝对不相等</span><br><span class="line">！&#x3D;&#x3D;也可以用来判断一个属性书否是underfind</span><br><span class="line">var o &#x3D; &#123;x : 1&#125;</span><br><span class="line">o.x !&#x3D;&#x3D; underfind &#x2F;&#x2F;true o中有属性x</span><br><span class="line">o.y !&#x3D;&#x3D; underfind &#x2F;&#x2F;false o中没有属性y</span><br></pre></td></tr></table></figure><p>==typeof(typeof(number)) —&gt;最后其实类型是String ,因为第一个typeof是返回的是String类型。==</p><h5 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h5><ol><li>函数表达分为命名表达式还有匿名函数表达式。</li><li>命名表达式：function text(){ }<br> text(); -&gt;调用</li><li>匿名表达式： var text :function() {}</li></ol><h6 id="形参与实参："><a href="#形参与实参：" class="headerlink" title="形参与实参："></a>形参与实参：</h6><ol><li>形参text(a,b)  ==text.length== 可以知道形参的数量。</li><li>实参text(1,2)。==arguments.length== 可以知道实参的长度。</li></ol><ul><li>形参出生是多少个就是多少个，以后不会再往后加了。</li></ul><p>return:<br>使程序停止执行；<br>返回值</p><p>递归：</p><ol><li>符合人的逻辑思维过程</li><li>递归一定要有递归出口</li></ol><h5 id="javascript预编译："><a href="#javascript预编译：" class="headerlink" title="javascript预编译："></a>javascript预编译：</h5><h6 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h6><ol><li>函数声明整体提升</li><li>变量声明提升</li></ol><h6 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h6><ol><li>imply global 暗示全局变量：即任何变量，如果变量未经声明就直接赋值，该变量为全局对象变量。</li><li>一切声明的全局变量，都是window的属性。即可以通过window调用。</li></ol><h5 id="预编译的四部曲（局部）：-重要"><a href="#预编译的四部曲（局部）：-重要" class="headerlink" title="预编译的四部曲（局部）：(重要)"></a>预编译的四部曲（局部）：(重要)</h5><ol><li><p>创建AO（执行期上下文）</p></li><li><p>找形参和变量声明。将变量和形参作为AO属性名，值为underfined。</p></li><li><p>将实参值和形参值统一。</p></li><li><p>在函数体里面找函数声明，值赋予函数体，-&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;&#125;</span><br></pre></td></tr></table></figure><p>这种–优先级最高，function会覆盖之前变量的值。</p></li></ol><p>==注意：fcuntion a() {}这种叫函数表达式才算funciton, 在预编译里==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var b &#x3D;function ()&#123;&#125;</span><br></pre></td></tr></table></figure><p> ==这种，因为还没有执行，所以不算function(){}==</p><h5 id="全局的预编译"><a href="#全局的预编译" class="headerlink" title="全局的预编译"></a>全局的预编译</h5><ol><li>创建GO</li></ol><p>——————-（其余步骤相等）</p><p>==在预编译的规则中，先生成GO ，再生成AO。==</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>[[scope]]:每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些不行，这些对象仅供js引擎存取，[[scope]]就是其中一个。==其存储了运行上下文的集合==。</p><h6 id="作用域链："><a href="#作用域链：" class="headerlink" title="作用域链："></a>作用域链：</h6><p>[[scope]]中所存储的执行器上下文对象的集合，集合呈链式连接。</p><p>==查找变量：从作用域的顶端依次向下查找，而AO在GO的顶端。==</p><h6 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h6><p>但凡是内部函数被保存到了外部，就一定会生成闭包。</p><p>缺点：当内部函数被保存到外部时，将会生成闭包。闭包会导致原有的作用域链不释放，造成内存泄露（像内存泄露，只是说内存被占用）</p><p>闭包的作用：</p><ol><li>实现公有变量。<br>例如说做一个函数累加器。</li><li>可以做缓存（存储结构）</li><li>可以实现封装，属性私有化</li><li>模块化开发，放置污染全局变量</li></ol><h6 id="立即执行函数："><a href="#立即执行函数：" class="headerlink" title="立即执行函数："></a>立即执行函数：</h6><p>（也有执行器上下文，也需要预编译）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;&#125; ()) 执行之后就立即被销毁。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传递参数：(function(a,b,c))&#123;</span><br><span class="line">console.log(a+b+c);</span><br><span class="line">&#125;(1,2,3)</span><br></pre></td></tr></table></figure><ul><li>注意：只有表达式才能被执行符号执行（执行符号就是（）），利用立即执行函数把内部数据传到外部，也用于数据的初始化；<br>‘  ， ’逗号可以把后面的值返回;</li></ul><h5 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h5><p>所有的对象继承了两个转换方法，第一个是toString()，它的作用是返回一个反应这个对象的字符串。</p><ul><li>toSting<ol><li>数组类继承的toString()可以将每一个数组元素转换成一个字符串，并在元素之间添加都好并合并成结果字符串</li><li>函数类的toString()可以返回这个函数的实现定义的标识方式。</li><li>日期类的toString可以返回一个可读的日期和时间字符串。</li><li>RegExp类定义的toString()方法将RegExp对象转换成表达正则表达式直接量的字符串</li></ol></li></ul><p>另外一个方法是ValueOf()。如果存在任意原始值，它就默认将对象转换为表示它的原始值。</p><h6 id="this"><a href="#this" class="headerlink" title="this"></a>this</h6><p>this ：代表在某一对象里面的第一人称，例如this.health<br>在对象内部的增删改查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.wife&#x3D;&#39;FengZe&#39; ，即在这里直接进行添加和修改。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除：delete xx.name;</span><br></pre></td></tr></table></figure><h6 id="对象创建方法"><a href="#对象创建方法" class="headerlink" title="对象创建方法;"></a>对象创建方法;</h6><ol><li><p>var obj = {}  对象字面量/对象直接量。</p></li><li><p>通过构造函数创建：</p><ol><li>系统自带构造函数  var obj = new object();<br>构造函数要用大驼峰式方法来写：TheFirstName<br>构造函数的内部原理：（一定要有new，不然就不是构造函数了）</li><li>在函数体最前面隐式加上this ={}</li><li>执行this.xxx=xxx;</li><li>隐式返回this</li></ol></li></ol><h6 id="包装类："><a href="#包装类：" class="headerlink" title="包装类："></a>包装类：</h6><p>new String()；</p><p>new Boolean();</p><p>new Number()；</p><h6 id="对象创建方法："><a href="#对象创建方法：" class="headerlink" title="对象创建方法："></a>对象创建方法：</h6><ol><li><p>对象字面量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D;&#123;&#x2F;&#x2F;对象字面量、对象直接量</span><br><span class="line">name : &quot;FengZe&quot;,</span><br><span class="line">sex  : &quot;male&quot;,</span><br><span class="line">wfie : &quot;xingyu&quot;,</span><br><span class="line">smoke : function () &#123;</span><br><span class="line">console.log(&#39;i am smoking ！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数：</p><ol><li>系统自带的构造函数 object   –&gt;  var obj = new object();</li></ol></li></ol><ul><li>==注意：构造函数要用大驼峰式的方法来写： TheFirstName这种==</li></ul><ol start="3"><li>自定义</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function xx()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="构造函数的内部原理"><a href="#构造函数的内部原理" class="headerlink" title="构造函数的内部原理"></a>构造函数的内部原理</h6><p>（一定要用new ,不然就不是构造函数了）</p><ol><li>在函数体最前面隐式加入this = {}</li><li>执行this.xxx=xxx;</li><li>隐式地返回this;</li></ol><p>包装类：<br>new String（）；<br>new Boolean ();<br>new Number ();</p><h5 id="原型："><a href="#原型：" class="headerlink" title="原型："></a>原型：</h5><ol><li><p>定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的睡醒和方法。原型也是对象。</p></li><li><p>利用原理，可以提取共有属性。</p></li><li><p>独享通过隐式属性查看原型–&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__proto__</span><br></pre></td></tr></table></figure></li><li><p>通过constructor 查看对象的构造函数。</p></li></ol><p>例子：如果生产一种汽车，而这种汽车大部分是相同的，而小部分作为选配部分，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Car (owner,power)&#123;</span><br><span class="line">this.owner &#x3D; owner,</span><br><span class="line">this.power &#x3D; power</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype &#x3D; &#123;</span><br><span class="line">name :&#39;BMW&#39;,</span><br><span class="line">tite :18,</span><br><span class="line">run : function ()&#123;</span><br><span class="line">console.log(&quot;i am running &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var car1 &#x3D; new Car(&#39;feng&#39;,&#39;900&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete.Car.name ,这样就可以删除了Car.prototype里面的属性了。</span><br></pre></td></tr></table></figure><h5 id="原型链："><a href="#原型链：" class="headerlink" title="原型链："></a>原型链：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Crand.protype.__prtot__ &#x3D; object.prototype --&gt;是所有对象的最终原型。</span><br><span class="line">var obj &#x3D; object.create(&quot;原型&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例： var person &#x3D; Object.create(Person.prototype)</span><br><span class="line">是绝大多数对象最终都会集成object.prototpype, 大也有例外的，例如说object.create(null)</span><br></pre></td></tr></table></figure><h5 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h5><p>call /apply 作用是转移this指向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.call(obj)；</span><br><span class="line">&#x2F;&#x2F;call需要把实参按照形参个数传进去，而apply需要传输一个arguments  区别在于传参列表不同。</span><br></pre></td></tr></table></figure><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><h6 id="继承的发展史："><a href="#继承的发展史：" class="headerlink" title="继承的发展史："></a>继承的发展史：</h6><ol><li><p>传统形式 -&gt;原型链   缺点：过多继承了没用的属性</p></li><li><p>借用构造函数</p><p> 缺点：</p><ol><li>不能继承借用构造函数的原型。</li><li>每次构造函数都要执行多个方法。</li></ol></li><li><p>共享原型<br> 缺点：</p><ol><li>不能随便改动自己的原型，因为他们拥有同一个原型。</li></ol></li><li><p>圣杯模式</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function  F()&#123;</span><br><span class="line">F.prototype &#x3D; Father.prototype;</span><br><span class="line">son.prototype &#x3D; new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间:"></a>命名空间:</h6><p>管理变量，能防止污染全局，适用于模块化开发</p><h6 id="属性拼接问题："><a href="#属性拼接问题：" class="headerlink" title="属性拼接问题："></a>属性拼接问题：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function (num)&#123;</span><br><span class="line">return this[&#39;name&#39; + num];</span><br><span class="line">&#125;&#x2F;&#x2F;输入num 得出num1的效果</span><br></pre></td></tr></table></figure><h5 id="对象的枚举："><a href="#对象的枚举：" class="headerlink" title="对象的枚举："></a>对象的枚举：</h5><p>（遍历和枚举）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. for()</span><br><span class="line">2. for(var temp in obj)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当遍历不知道对象的数量多少的时候，可以用for in循环解决问题</p><ol start="3"><li><p>[hasOwnProperty]obj.hasOwnProperty(),    用来判断属性是不是自己的，是不是从原型链上拿过来的。</p></li><li><p>in   属性只能用来能不能访问到这个属性<br>in运算符希望它的左操作数是一个字符串或可以转换成字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数的属性名则返回true.</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var point &#x3D; &#123;x:1 ,y:1&#125;  &#39;x&#39; in point --&gt;true</span><br></pre></td></tr></table></figure><ol start="5"><li>A instanceof B<br>可以查到 A对象是不是从B的构造函数，构造出来的。Object 可以看A对象的原型链上有没有B 的原型。<br>instanceof 运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧对象是右侧对象的实例则返回true</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var d  &#x3D; new Data();</span><br><span class="line">d instanceof Data; &#x2F;&#x2F;true,d是由Data() 创建的</span><br><span class="line">d instanceof Number; &#x2F;&#x2F; false ,d不是由Number创建的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array -&gt;true</span><br><span class="line">    Object -&gt;true</span><br></pre></td></tr></table></figure><p>toString方法：<br>    toString() 方法可把一个逻辑值转换为字符串，并返回结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.prototype.toString.call([]);</span><br><span class="line">object.prototype.toString &#x3D; function ()&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="克隆："><a href="#克隆：" class="headerlink" title="克隆："></a>克隆：</h5><h6 id="浅层克隆，深层克隆。"><a href="#浅层克隆，深层克隆。" class="headerlink" title="浅层克隆，深层克隆。"></a>浅层克隆，深层克隆。</h6>{% asset_img 深克隆.png 深克隆 %}<p>function clone ()</p><ul><li>对象序列化指的是对象的状态转换为字符串，也可以将字符串还原为对象。ECMAScript5提供了JSON.stringify()和 json.parse()用来序列化和还原js对象。但注意函数，RegExp,Error和underfind不能序列化和还原。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o &#x3D; &#123;x : 1 , y:&#123;z : [false , null ,&#39;&#39;]&#125;  &#125;;</span><br><span class="line">s &#x3D; JSON.stringify() &#x2F;&#x2F; s &#x3D; &#123;x : 1 , y:&#123;z : [false , null ,&#39;&#39;]&#125;  &#125;</span><br><span class="line">p &#x3D; JSON.parse() &#x2F;&#x2F;p是o的深拷贝</span><br></pre></td></tr></table></figure><h6 id="三目运算符："><a href="#三目运算符：" class="headerlink" title="三目运算符："></a>三目运算符：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">？：</span><br></pre></td></tr></table></figure><pre><code>例：1&gt;0? 2:1  如果1大于0 则选择2，否则选择1。</code></pre><h5 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h5><ol><li>数组的第一个元素索引为0，最大可能索引为2 32(2的32次方) -2。</li><li>JavaScript数组是动态的，根据需要变长变短。数组都有一个length属性。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; []; 数组字面量；</span><br><span class="line">var arr &#x3D; new Array();</span><br></pre></td></tr></table></figure><p>可以传参数，但如果只写一个数会认为这是数组的长度。</p><ul><li>数组继承了默认的Value0f()方法，这个返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString方法。空数组转换成为空字符串，空字符串转换成数字0。</li></ul><h6 id="常用的方法："><a href="#常用的方法：" class="headerlink" title="常用的方法："></a>常用的方法：</h6><ul><li><p>改变原数组： push ,pop， shift ，unshift， sort， reverse</p></li><li><p>不改变原数组：concat ,join, split toString ,slice</p></li></ul><ol><li>push()–在数组的==最后一位添加数据==</li><li>pop ()–把数组的最后一位剪切出来</li><li>unshift()–在数组前面添加数据，并可以通过传参添加多个数据，</li><li>shift()    在数组前面减</li><li>reverse() 数组颠倒</li><li>splice()  arr.splice (从第几位开始 ， 截取多少的长度  ，在切口处添加的新数据)</li><li>sort()给数组排序，但这个是用ASII码排序的，因为有时候会不尽人意。也可以自行添加函数。</li></ol><p>如何优化sort()方法进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(function ( a , b )&#123;&#x2F;&#x2F;必须传2个形参</span><br><span class="line">return a-b;&#x2F;&#x2F;升序</span><br><span class="line">&#x2F;&#x2F;看返回数，当返回值为负数时，那么前面的数在前面</span><br><span class="line"></span><br><span class="line">return b-a;&#x2F;&#x2F;降序</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如何给数组乱序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(function ()&#123;</span><br><span class="line">Math.random() -0.5;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>不改变原数组：</li></ul><ol><li>concat :拼接数组，并且不应县前面的数组，也不会排序</li><li>toString :把数组变成字符串</li><li>slice() 从该位开始截取，截取到该位</li><li>join()  要字符串，然后用字符串连接</li><li>split ()  用“”来拆分字符串变成数组。</li></ol><h6 id="类数组："><a href="#类数组：" class="headerlink" title="类数组："></a>类数组：</h6><p>类数组不是数组，当然没有数组的方法。<br>构成要素：属性为索引，必须要有length 属性，最好有push方法</p><p>优点：类数组的关键点在于length 还有push方法<br>obj [obj.lenght] = target<br>obj.length++;</p><p>如此来实现push方法。</p><h6 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h6><p>不影响try catch 下一块代执行，但不会执行try块里面的那行代码</p><p>几种常见错误类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Error：6</span><br><span class="line">EvalError</span><br><span class="line">RangeError ；数值越界</span><br><span class="line">ReferenceError ：非法或不识别的引用</span><br><span class="line">SyntaxError :语法错误</span><br><span class="line">TypeError :操作的类型错误</span><br><span class="line">urIError:uri不当</span><br></pre></td></tr></table></figure><h5 id="es5严格模式"><a href="#es5严格模式" class="headerlink" title="es5严格模式"></a>es5严格模式</h5><p>（即es3.0与es5.0冲突的部分使用es5.0的解决办法）</p><p>浏览器基于es3.0+es5.0的新增方法<br>“use strict”;</p><ol><li>在es5严格模式中，不允许使用argument.callee ，with{}  caller 并且变量赋值前必须声明，局部里面的this一定要被赋值，拒绝重复的属性。</li></ol><h6 id="在严格模式下有以下几种要求："><a href="#在严格模式下有以下几种要求：" class="headerlink" title="在严格模式下有以下几种要求："></a>在严格模式下有以下几种要求：</h6><ol><li>禁止使用with 语句</li><li>创设eval 作用域</li><li>禁止this关键字指向全局对象</li><li>禁止在函数内部遍历调用栈</li><li>禁止删除变量，只有configurable</li><li>设置为true的对象属性才能被删除。</li></ol><h6 id="重名报错"><a href="#重名报错" class="headerlink" title="重名报错"></a>重名报错</h6><ol><li>arguments对象的限制<br>不允许对arguments赋值</li><li>arguments不再追踪参数的变化<br>禁止使用arguments.callee</li></ol><h5 id="DOM-（Document-Obect-Model）"><a href="#DOM-（Document-Obect-Model）" class="headerlink" title="DOM （Document Obect Model）"></a>DOM （Document Obect Model）</h5><ul><li>DOM定义了表示和修改文档的方法，DOM对象即为宿主对象。由浏览器厂商定义，用来操作html 和xml 。</li><li>DOM树中总共分成以下4种节点：Element(元素),Text类型(文本节点),Comment类型(注释节点),Document类型（document节点）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.getElementsByTagName(&#39;div&#39;)[0];  &#x2F;&#x2F;后面这个0一定要选中。</span><br></pre></td></tr></table></figure></li></ul><h6 id="数组去重方法："><a href="#数组去重方法：" class="headerlink" title="数组去重方法："></a>数组去重方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique &#x3D; function() &#123;</span><br><span class="line">var temp &#x3D; &#123;&#125;;</span><br><span class="line">var arr &#x3D; [];</span><br><span class="line">var len &#x3D; this.length;</span><br><span class="line">for (var i &#x3D; 0; i &lt; this.length ; i++)&#123;</span><br><span class="line">if(!temp[this[i]])&#123;</span><br><span class="line">temp[this[i]] &#x3D; &#39;abc&#39;;</span><br><span class="line">arr.push(this[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="DOM的基本操作："><a href="#DOM的基本操作：" class="headerlink" title="DOM的基本操作："></a>DOM的基本操作：</h6><ol><li>对节点的增删改查：<ol><li>查：</li><li>查看元素节点 ：</li></ol></li></ol><h6 id="DOM选择器："><a href="#DOM选择器：" class="headerlink" title="DOM选择器："></a>DOM选择器：</h6><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doucument.getElementById() &#x2F;&#x2F;元素ID在IE8 一下浏览器是不区分大小写的，而且也返回匹配name 属性的元素；就是说写name可以当成id选择器（ie 8浏览器以下可以）</span><br></pre></td></tr></table></figure><ol start="2"><li>getElementsByTagName()      //标签名</li><li>getElemehtsByName()  //只有部分标签name可生效（表单，表 ，img ,iframe）</li><li>getElementsByClassName() 在IE8 及以下的版本中不使用方法。</li><li>.querySelect()    //css选择器，在ie7级一下的版本中没有</li><li>.querySelectorAll()  //css选择器，在ie7 及以下的版本中没有 选一组</li></ol><p>==document 代表整个文档，html只是文档里面的跟标签。==</p><h6 id="遍历节点树："><a href="#遍历节点树：" class="headerlink" title="遍历节点树："></a>遍历节点树：</h6><ol><li>parentNode -&gt;父节点 （最顶端的parentNode 是#document;）</li><li>childNodes -&gt;子节点</li><li>firstChild –&gt;第一个子节点</li><li>lstChild  –&gt;s最后一个子节点</li><li>nextSibling -&gt;后一个兄弟节点previousSiling  -&gt;前一个兄弟节点</li></ol><h6 id="遍历元素节点数："><a href="#遍历元素节点数：" class="headerlink" title="遍历元素节点数："></a>遍历元素节点数：</h6><ol><li>parentElement -&gt;返回当前元素的父元素节点（IE不兼容）</li><li>children -&gt;只返回当前元素的元素子节点</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.childElementCount &#x3D;&#x3D;&#x3D; node.children.length</span><br></pre></td></tr></table></figure><p> 当前元素节点的子元素节点数目<br>4. firstElementChild  5. 第一个元素子节点（IE不兼容）<br>5. lastElementChild 返回最后一个元素子节点（IE 不兼容）<br>6. nextElementSibling /previousElementSibling -&gt;返回后一个/前一个兄弟节点</p><h6 id="节点类型："><a href="#节点类型：" class="headerlink" title="节点类型："></a>节点类型：</h6><pre><code>元素节点属性节点文本节点注释节点doucumentDocumentFragment</code></pre><p>节点的四个属性：</p><ol><li>nodeName   //只能读取，不能写入。</li><li>nodeValue     //text节点或comment节点的文本内容，可读写。</li><li>nodeType     //该节点的类型 只读   判断元素是啥。</li><li>attributes        // element 节点的属性集合</li></ol><p>节点的一个方法:<br>node.hasChildNodes();</p><p>DOM结构树：<br>Document是系统的函数，只能系统自己调用。</p><p>==getElementByTagName () 方法定义在Document.prototype 和Element.prototypes上==</p><p>增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.getElementsTagNmae(‘div’) ；</span><br><span class="line">document.createTextNode();</span><br><span class="line">document.createComment();</span><br><span class="line">document.createDocumentFragment();</span><br></pre></td></tr></table></figure><p>插：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PARENTNODE.appendChild();</span><br><span class="line">PARENTNODE.insertBefore(a,b)  &#x2F;&#x2F;  插入A在插入B之前</span><br></pre></td></tr></table></figure><p>删：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent.removeChild();</span><br><span class="line">child.remove();</span><br></pre></td></tr></table></figure><p>替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.replaceChild(new,origin)</span><br></pre></td></tr></table></figure><h6 id="Element节点的一些属性："><a href="#Element节点的一些属性：" class="headerlink" title="Element节点的一些属性："></a>Element节点的一些属性：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innerHTML</span><br><span class="line">innerText   (火狐不兼容) &#x2F;textContent （老版本IE不好使）</span><br><span class="line">Element节点</span><br><span class="line">ele.setAttribute(&#39;id&#39; ,&#39;only&#39;)</span><br><span class="line">ele.getAttribute(&#39;id&#39;)</span><br></pre></td></tr></table></figure><h6 id="Date-对象方法："><a href="#Date-对象方法：" class="headerlink" title="Date 对象方法："></a>Date 对象方法：</h6><ol><li><p>getTimer:</p></li><li><p>Interval：<br>定时器：但定时器是非常不准的。</p></li><li><p>setInterval: 定时器</p></li><li><p>clearInterval:清理计时器</p></li></ol><p>5.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">&#x2F;&#x2F;用于推迟一段时间之后再执行</span><br><span class="line">&#125;，1000)</span><br><span class="line"></span><br><span class="line">var timer &#x3D; setTimeout(function ()&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">clearTimeout(timer);</span><br></pre></td></tr></table></figure><h6 id="DOM基本操作："><a href="#DOM基本操作：" class="headerlink" title="DOM基本操作："></a>DOM基本操作：</h6><p>查看滚动条的滚动距离：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.pageXOffsize YOffsize</span><br></pre></td></tr></table></figure><p>==IE8及IE8以下不兼容==</p><p>查看视口的尺寸:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.innerWidth &#x2F;inner.Height</span><br></pre></td></tr></table></figure><ul><li>标准模式 /怪异模式也叫混杂模式（向后兼容），可在浏览器查document.compatMode,如果是CSS1Compat则是标准模式，如果是BackCompat则是向后兼容。<br>clintHeight / clientHeight</li></ul><h6 id="查看元素的几何尺寸："><a href="#查看元素的几何尺寸：" class="headerlink" title="查看元素的几何尺寸："></a>查看元素的几何尺寸：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domEle.getBoundingClientRect();</span><br></pre></td></tr></table></figure><p>兼容性很好<br>该方法返回不是实时的；</p><p>查看元素尺寸：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.offsetWidth  dom.offsetHeight</span><br></pre></td></tr></table></figure><p> //求的是视觉上的尺寸，当然不包含margin</p><p>查看元素的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.offsetLeft  dom.offsetTop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.offsetParent</span><br></pre></td></tr></table></figure><p> //查看父级的。能求有定位的父级。</p><h6 id="让滚动条滚动："><a href="#让滚动条滚动：" class="headerlink" title="让滚动条滚动："></a>让滚动条滚动：</h6><p>window上的三个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scroll()</span><br><span class="line">scrollTo() 其实是一样的</span><br><span class="line">scroolBy()  累加滚动距离</span><br></pre></td></tr></table></figure><p>阅读器小demo ，就是reader.js</p><h5 id="脚本化CSS-（就是控制CSS）"><a href="#脚本化CSS-（就是控制CSS）" class="headerlink" title="脚本化CSS  （就是控制CSS）"></a>脚本化CSS  （就是控制CSS）</h5><ol><li>可读写行间样式，没有兼容性问题，遇到float这样的保留字属性，前面应加css</li><li>复合属性必须拆解（borderWidth,borderHeight,borderradius），组合单词变成小驼峰式写法；<br>写入的值必须是字符串格式</li></ol><h6 id="查询计算样式："><a href="#查询计算样式：" class="headerlink" title="查询计算样式："></a>查询计算样式：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.getComputedStyle(ele，null);</span><br></pre></td></tr></table></figure><p> //看到权重最高的，所以这个最准确。这个也不能改样式。<br>计算样式只读</p><p>返回的计算样式的值都是绝对值，没有相对单位<br>ie8 及以下不兼容。</p><p>查询样式：<br>div.currentStyle–&gt; CSSStyleeclaration</p><h5 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h5><h6 id="事件的绑定："><a href="#事件的绑定：" class="headerlink" title="事件的绑定："></a>事件的绑定：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ele.onXXX&#x3D; function(event )&#123;&#125;  &#x2F;&#x2F;程序this指向是dom元素本身</span><br><span class="line">特点：兼容性很好，但是一个元素的同一事件上只能绑定一个处理程序，基本等同于写在HTML行间上</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj.addEventListeber(type, fn,flase);&#x2F;&#x2F;程序this指向是dom元素本身</span><br><span class="line">ie9 以下不兼容，可以为一个时间绑定多个处理程序</span><br><span class="line"></span><br><span class="line">obj.attachEvent(&#39;on&#39;+type ,fn)&#x2F;&#x2F;程序this指向window</span><br><span class="line">IE独有，一个时间同样可以绑定多个处理程序</span><br></pre></td></tr></table></figure><p>绑定事件，当事件在循环里面，就一定要考虑要不要使用闭包。</p><h6 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h6><p>解除事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ele.onclick &#x3D; false &#x2F;null</span><br><span class="line">ele.removeEventListener(type,fn ,false)</span><br><span class="line">ele.detachEvent(&#39;on&#39; +type ,fn);</span><br><span class="line">若绑定匿名函数，则无法解除</span><br></pre></td></tr></table></figure><h6 id="事件处理模型——事件冒泡，捕获"><a href="#事件处理模型——事件冒泡，捕获" class="headerlink" title="事件处理模型——事件冒泡，捕获"></a>事件处理模型——事件冒泡，捕获</h6><p>结构上嵌套关系的元素，会存在事件冒泡的功能。</p><p>事件捕获：<br> 只有chrome上可以用</p><p>把flase 变成ture,从结构的最外面向里面进行捕获.</p><ul><li>一个对象的一个事件，绑定两个函数，分别是冒泡还有捕获。执行的顺序是先触发顺序，先捕获，后冒泡。</li></ul><p>==focus, blur , change  submit  reset  ,select 等事件不冒泡==</p><h6 id="取消冒泡："><a href="#取消冒泡：" class="headerlink" title="取消冒泡："></a>取消冒泡：</h6><p>W3C标准event.stopPropagation</p><h6 id="阻止默认事件："><a href="#阻止默认事件：" class="headerlink" title="阻止默认事件："></a>阻止默认事件：</h6><ol><li>默认事件——表单提交，a标签跳转，右键菜单等<br>return false;     以对象属性的方式注册的时间才有效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault（） IE9以下不兼容</span><br></pre></td></tr></table></figure><h6 id="事件对象："><a href="#事件对象：" class="headerlink" title="事件对象："></a>事件对象：</h6><p>event ||window.event 用于IE</p><h6 id="事件源对象："><a href="#事件源对象：" class="headerlink" title="事件源对象："></a>事件源对象：</h6><ol><li>event.target 火狐只有这个</li><li>event.srcElement ie只有这个</li><li>chorm 全都有</li><li>div.box就是事件源对象</li></ol><h6 id="事件分类："><a href="#事件分类：" class="headerlink" title="事件分类："></a>事件分类：</h6><p>键盘类事件：</p><ol><li>Json就是为了传输数据：<ol><li>以xml这种语言传输数据，xml相对于html比较随性，可以自定义标签。</li><li>规定json 属性名要加双引号，json传输的时候其实传输的是字符串。</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify() ---&gt;把数据传输给后台   json -&gt;string</span><br><span class="line">JSON.parse（) ----&gt;后台把数据传输给前台，string -json</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domtree + csstree &#x3D; randerTree</span><br></pre></td></tr></table></figure><p>==尽量减少dom节点的增加或者删除，以优化性能<br>reflow 是效率最低的。dom节点的宽高变化==，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如说display none---&gt;block</span><br><span class="line">offsetWidth offsetLeft</span><br></pre></td></tr></table></figure><h6 id="repanint-重绘"><a href="#repanint-重绘" class="headerlink" title="repanint 重绘"></a>repanint 重绘</h6><p>效率相对没有这么低，是可以接受的</p><h6 id="异步加载js："><a href="#异步加载js：" class="headerlink" title="异步加载js："></a>异步加载js：</h6><p>加载工具方法没必要阻塞文档。</p><p>三种方法异步加载js：</p><ol><li>defer = “defer”  这个就是异步加载的js了。只有IE能够用。要等到dom文档全部解析完之后才会被执行</li><li>async  异步加载。 async = “async” 也可以实现异步加载。W3C方法。加载完就执行。asynv只能加载外部脚本</li><li>创建script，插入DOM，可以按顺序执行。</li></ol><ul><li>使用onload方法，可以让所有资源加载完之后立即执行,除了IE都兼容。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IE 使用onreadystatechange（） 方法</span><br><span class="line"></span><br><span class="line">$(document).ready(function () &#123;</span><br><span class="line">&#125;)&#x2F;&#x2F;这种是当DOM解析完就执行的部分</span><br><span class="line"></span><br><span class="line">与window.onload 方法之间的区别。 onload是最低的写法</span><br></pre></td></tr></table></figure><h5 id="JS时间线"><a href="#JS时间线" class="headerlink" title="JS时间线"></a>JS时间线</h5><h6 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h6><p>定义borwser Object Model</p><p>定义了操作浏览器的接口</p><h6 id="BOM对象："><a href="#BOM对象：" class="headerlink" title="BOM对象："></a>BOM对象：</h6><p>Window ,History ,Navigator Screen,Location</p><p>由于浏览器不同，Bom对象的兼容性很低，一般情况只用部分功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">转义字符：“\”</span><br><span class="line">多行字符串</span><br><span class="line">字符串换行符 \n</span><br></pre></td></tr></table></figure><h5 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h5><p>匹配特殊字符或特殊搭配原则的字符的最佳选择<br>———例如验证邮箱地址</p><p>两种创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 直接量  var reg &#x3D; new RegExp();</span><br></pre></td></tr></table></figure><p>两种方法：</p><ol><li>text() 只能判断有没有符号要求的片段，只能返回true和 false</li><li>match()<br>可以判断符合的片段，并返回给你</li></ol><h6 id="修饰符："><a href="#修饰符：" class="headerlink" title="修饰符："></a>修饰符：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i  执行对大小写不敏感的匹配</span><br><span class="line"></span><br><span class="line">g 执行全局匹配</span><br><span class="line"></span><br><span class="line">m 执行多行匹配</span><br><span class="line">一个表达式就代表一位 ，里面填的就是区间</span><br></pre></td></tr></table></figure><h6 id="元字符："><a href="#元字符：" class="headerlink" title="元字符："></a>元字符：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\w &#x3D;&#x3D;&#x3D;[0-9A-z_]</span><br><span class="line"></span><br><span class="line">\W &#x3D;&#x3D;&#x3D;[^w]</span><br></pre></td></tr></table></figure><h6 id="量词："><a href="#量词：" class="headerlink" title="量词："></a>量词：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n只是代表这个数，并不是特定的n</span><br><span class="line"></span><br><span class="line">n+ 这个变量可以出现一次到无数次</span><br><span class="line"></span><br><span class="line">n* 区间是零到正无穷</span><br><span class="line"></span><br><span class="line">n? 匹配任何包含零个或一个n的字符串</span><br><span class="line"></span><br><span class="line">n&#123;x&#125;</span><br><span class="line"></span><br><span class="line">n &#123;x,y&#125; &#123;3,5&#125;  先匹配5个，再不行匹配三个</span><br><span class="line"></span><br><span class="line">n$ 结尾  ，是要以这一整个片段结尾</span><br><span class="line">^n  开头</span><br></pre></td></tr></table></figure><h6 id="RegExp对象属性："><a href="#RegExp对象属性：" class="headerlink" title="RegExp对象属性："></a>RegExp对象属性：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">ignoreCase   &#x2F;&#x2F;忽略大小写</span><br><span class="line">multiline &#x2F;&#x2F;多行</span><br><span class="line">lastIndex</span><br></pre></td></tr></table></figure><p>方法；<br>exec()：<br>index 索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;()&#x2F;&#x2F;&#x2F;（）代表字表达式  \1代表反向引用第一个表达式的内容</span><br><span class="line">var reg &#x3D; &#x2F;(\w)\1\1\1&#x2F;   可以匹配aaaaaabbbbb这种</span><br><span class="line"></span><br><span class="line">var reg &#x3D; &#x2F;(\w)\1(\w)\2&#x2F;g 可以匹配aabb这种表达式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">search()</span><br><span class="line"></span><br><span class="line">match() 匹配不到显示-1</span><br><span class="line"></span><br><span class="line">split 可以填字符串，还有正则表达式</span><br><span class="line"></span><br><span class="line">replace(‘a&#39;, &#39;b&#39;); &#x2F;&#x2F;替换字符，</span><br><span class="line">非正则表达式：把前面的替换成后面的 ，因为没有权限所以只能替换一个。</span><br><span class="line">正则表达式：具有访问全局的能力，把两个都能替换。rag &#x3D;&#x2F;a&#x2F;g</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;(\w)\1(\w)\2&#x2F;g;</span><br><span class="line">var str &#x3D; &quot;aabb&quot;;</span><br><span class="line">console.log(str.replace(reg,&#39;$2$2$1$1&#39;)); &#x2F;&#x2F;这种可以把字符把aabb转换成bbaa</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toUpperCase() 可以使字母大写</span><br></pre></td></tr></table></figure><ul><li>正向预查，正向断言</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;a(? &#x3D;b)&#x2F;g 后面就是一个b</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abs() 可以去得正数和负数的绝对值</span><br><span class="line">floor（） 可以进行四舍五入</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JavaScript笔记&quot;&gt;&lt;a href=&quot;#JavaScript笔记&quot; class=&quot;headerlink&quot; title=&quot;JavaScript笔记&quot;&gt;&lt;/a&gt;JavaScript笔记&lt;/h4&gt;&lt;img src=&quot;/blog/blog/2019/05/11/javascript-note/2019/05/11/javascript-note/map.png&quot; class title=&quot;这是js思维导图&quot;&gt;
&lt;h5 id=&quot;Web-发展史：&quot;&gt;&lt;a href=&quot;#Web-发展史：&quot; class=&quot;headerlink&quot; title=&quot;Web 发展史：&quot;&gt;&lt;/a&gt;Web 发展史：&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;Mosaic：是全世界第一款可以显示图片的浏览器&lt;/li&gt;
&lt;li&gt;Netscape Navigator -&amp;gt;2003 firefox 浏览器&lt;/li&gt;
&lt;li&gt;IE6 -&amp;gt;IE6浏览器&lt;/li&gt;
&lt;li&gt;2008 -&amp;gt; Chrome 浏览器&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="https://fengzehe.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染原理</title>
    <link href="https://fengzehe.github.io/blog/2019/05/08/brower-note/"/>
    <id>https://fengzehe.github.io/blog/2019/05/08/brower-note/</id>
    <published>2019-05-08T04:02:16.000Z</published>
    <updated>2020-06-18T10:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h4><p> -步骤：</p><ol><li>清楚HTML 生成DOM树</li><li>处理CSS生成 CSSDOM树</li><li>将两树合并成render 树</li><li>将render 树进行布局计算</li><li>将render树中的每一个节点绘制到屏幕上<a id="more"></a></li></ol><ul><li>重排，重绘</li></ul><ol><li>当render tree 中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变需要重新构建，会回流。每个页面至少需要一次回流，就是在页面的第一次加载的时候。</li><li>重绘。当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格而不影响布局的，例如background-color，就叫做重绘。</li></ol><img src="/blog/blog/2019/05/08/brower-note/2019/05/08/brower-note/1.png" class title="如图"><blockquote><p>蓝色代表网络通信和HTML 解析</p></blockquote><blockquote><p>黄色代表javascipt执行</p></blockquote><blockquote><p>紫色代表样式计算和布局，即重排</p></blockquote><blockquote><p>绿色代表重绘</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;浏览器渲染原理&quot;&gt;&lt;a href=&quot;#浏览器渲染原理&quot; class=&quot;headerlink&quot; title=&quot;浏览器渲染原理&quot;&gt;&lt;/a&gt;浏览器渲染原理&lt;/h4&gt;&lt;p&gt; -步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;清楚HTML 生成DOM树&lt;/li&gt;
&lt;li&gt;处理CSS生成 CSSDOM树&lt;/li&gt;
&lt;li&gt;将两树合并成render 树&lt;/li&gt;
&lt;li&gt;将render 树进行布局计算&lt;/li&gt;
&lt;li&gt;将render树中的每一个节点绘制到屏幕上&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="浏览器渲染原理" scheme="https://fengzehe.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>jonp跨域</title>
    <link href="https://fengzehe.github.io/blog/2019/05/08/jonp/"/>
    <id>https://fengzehe.github.io/blog/2019/05/08/jonp/</id>
    <published>2019-05-08T03:18:14.000Z</published>
    <updated>2020-06-18T10:18:50.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="jsonp可以实现跨域获取数据-其实是get请求-而Ajax跨域受到限制"><a href="#jsonp可以实现跨域获取数据-其实是get请求-而Ajax跨域受到限制" class="headerlink" title="jsonp可以实现跨域获取数据 (其实是get请求),而Ajax跨域受到限制"></a>jsonp可以实现跨域获取数据 (其实是get请求),而Ajax跨域受到限制</h5><blockquote><p>解决跨域问题的几种方法:</p></blockquote><ol><li>Flash (很少了)</li><li>服务器代理中转  （用得还算比较多）通过一个中间域名相同的php文件（借助自己同源的服务器），因为中间php不属于浏览器，因此不存在同源策略，即服务器之间可以互相转发信息。</li><li>Jsonp<a id="more"></a></li></ol><blockquote><p>jsonp跨域的原理</p></blockquote><ol><li>web页面上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>引入js文件时则不受是否跨域的影响（src不受同源策略限制）</li><li>于是我们把数据放到服务器上并且数据位json格式 （因为js可以轻松处理json数据）</li><li>因为我们无法监控<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>的src属性是否把数据获取完成，所以我们需要做一个处理。</li><li>实现定义好处理跨域获取数据的函数， 如function doJSON(data){}</li><li>用src获取数据的时候添加一个参数 cb = ‘doJSON’(服务端会根据参数cb的值返回 对应的内容) 此内容为cb对应的值doJSON为函数真实要传递的数据为函数的参数的一串字符 如doJSON (‘数据’)。</li></ol><blockquote><p>doucument.domain （针对基础域名相同的情况）  //基础域名必须相同</p></blockquote><ul><li>bj.58.com  document.domain  = ‘58.com’</li><li>tj.58.com   document.domain = ‘58.com’</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;jsonp可以实现跨域获取数据-其实是get请求-而Ajax跨域受到限制&quot;&gt;&lt;a href=&quot;#jsonp可以实现跨域获取数据-其实是get请求-而Ajax跨域受到限制&quot; class=&quot;headerlink&quot; title=&quot;jsonp可以实现跨域获取数据 (其实是get请求),而Ajax跨域受到限制&quot;&gt;&lt;/a&gt;jsonp可以实现跨域获取数据 (其实是get请求),而Ajax跨域受到限制&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;解决跨域问题的几种方法:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Flash (很少了)&lt;/li&gt;
&lt;li&gt;服务器代理中转  （用得还算比较多）通过一个中间域名相同的php文件（借助自己同源的服务器），因为中间php不属于浏览器，因此不存在同源策略，即服务器之间可以互相转发信息。&lt;/li&gt;
&lt;li&gt;Jsonp&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="跨域" scheme="https://fengzehe.github.io/blog/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="jsonp" scheme="https://fengzehe.github.io/blog/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>Ajax笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/05/07/Ajax-note/"/>
    <id>https://fengzehe.github.io/blog/2019/05/07/Ajax-note/</id>
    <published>2019-05-07T15:13:13.000Z</published>
    <updated>2020-06-18T10:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h5><blockquote><p>form表单操作起来只会让整个页面刷新。Ajax(Asynchronoud javascript and xml)可以局部的获取数据。异步的过程。异步 javascript，和xml，用异步的javascipt获取xml数据，现在操作的是json。</p></blockquote><a id="more"></a><h6 id="封装Ajax的具体参数"><a href="#封装Ajax的具体参数" class="headerlink" title="封装Ajax的具体参数"></a>封装Ajax的具体参数</h6><ol><li>Mothod : GET POST等。</li><li>action : address;</li><li>enctype : 固定在发送表单数据之前如何对其进行编码，application /x -www-form -urlencoded<br>在发送前编码所有的字符（默认）。</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipart &#x2F; form-data (&lt;input type &#x3D;&#39; file &#39;&gt;)</span><br></pre></td></tr></table></figure>不对字符编码，在使用包含文件上擦黄空间的表单时，必须使用该值。</li></ol><blockquote><p>因为IE中并没有xmlHttpRequest() 这种方法， 所以要使用  new ActiveXObject(‘Microsoft.XMLHttp’)</p></blockquote><h6 id="如何封装一个自己的Ajax"><a href="#如何封装一个自己的Ajax" class="headerlink" title="如何封装一个自己的Ajax"></a>如何封装一个自己的Ajax</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; null;</span><br><span class="line">    if(window.XMLHttpRequest) &#123;</span><br><span class="line">        xhr &#x3D;  new XMLHttpRequest();    &#x2F;&#x2F;判断是否为主流浏览器</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        xhr &#x3D; new ActiveXObject(&#39;Microsoft.XMLHttp&#39;)    &#x2F;&#x2F;IE浏览器</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="Ajax的几种状态"><a href="#Ajax的几种状态" class="headerlink" title="Ajax的几种状态"></a>Ajax的几种状态</h6><ol><li>ajax.open (method , url ,true);</li><li>ajax.send();</li><li>onreadystatechage 4     // ajax状态每次变化都会触发</li></ol><ul><li>0 = 未初始化，未调用send（） 方法</li><li>1= 读取中，已调用send () 发送请求</li><li>2 = 已读取  ,send 方法执行完成，接收到全部相应内容</li><li>3 = 交互中， 正在解析响应内容</li><li>4 = 完成 ，响应内容解析完成   //只关系这个过程</li><li>status == 200 403 503</li><li>200代表成功 ,403代表请求访问的资源被服务器拒绝了,503表明服务器处于超负载或者正在进行停机维护。</li></ul><h5 id="Ajax支持的数据类型："><a href="#Ajax支持的数据类型：" class="headerlink" title="Ajax支持的数据类型："></a>Ajax支持的数据类型：</h5><blockquote><p>dataType选项除了单纯的xml,还可以指定html,json,jsonp,script 或者 text</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;form表单操作起来只会让整个页面刷新。Ajax(Asynchronoud javascript and xml)可以局部的获取数据。异步的过程。异步 javascript，和xml，用异步的javascipt获取xml数据，现在操作的是json。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Ajax" scheme="https://fengzehe.github.io/blog/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>douban</title>
    <link href="https://fengzehe.github.io/blog/2019/05/07/douban/"/>
    <id>https://fengzehe.github.io/blog/2019/05/07/douban/</id>
    <published>2019-05-07T01:03:25.000Z</published>
    <updated>2020-06-18T10:18:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用豆瓣api做联想搜索"><a href="#使用豆瓣api做联想搜索" class="headerlink" title="使用豆瓣api做联想搜索"></a>使用豆瓣api做联想搜索</h2><h6 id="项目目的：进行JQuery和Ajax的练习，仿照豆瓣的输入联想功能。在豆瓣后台返回数据的时候点击选项跳转到相关页面。"><a href="#项目目的：进行JQuery和Ajax的练习，仿照豆瓣的输入联想功能。在豆瓣后台返回数据的时候点击选项跳转到相关页面。" class="headerlink" title="项目目的：进行JQuery和Ajax的练习，仿照豆瓣的输入联想功能。在豆瓣后台返回数据的时候点击选项跳转到相关页面。"></a>项目目的：进行JQuery和Ajax的练习，仿照豆瓣的输入联想功能。在豆瓣后台返回数据的时候点击选项跳转到相关页面。</h6><a id="more"></a><hr><ol><li>首先我们先写一下样式，仿照豆瓣的导航栏还有搜索框写一个样式。<img src="/blog/blog/2019/05/07/douban/2019/05/07/douban/1.png" class title="写好的样式，在搜索框内填入信息进行联想搜索"><blockquote><p>HTML代码</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;src&#x2F;css&#x2F;index.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;nav&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;nav-left&quot;&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;豆瓣&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;li&gt;读书&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;li&gt;电影&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;li&gt;音乐&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;li&gt;同城&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;li&gt;小组&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;li&gt;阅读&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;li&gt;FM&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;li&gt;时间&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;li&gt;豆品&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;li&gt;更多&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;nav-right&quot;&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;下载客户端&lt;&#x2F;li&gt;</span><br><span class="line">                    &lt;li&gt;注册&#x2F;登录&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;main-music&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;main-wrapper&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;main-logo&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;main-search&quot;&gt;</span><br><span class="line">                        &lt;form action&#x3D;&quot;&quot;&gt;</span><br><span class="line">                            &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;唱片名，表演者&quot;  class&#x3D;&quot;search&quot; &gt;</span><br><span class="line">                            &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">                        &lt;&#x2F;form&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;main-list&quot;&gt;</span><br><span class="line">                        &lt;ul&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;&#x2F;ul&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;src&#x2F;js&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><blockquote><p>CSS样式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">    list-style: none;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html body&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.wrapper&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.nav&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 28px;</span><br><span class="line">    min-width: 950px;</span><br><span class="line">    background: #5d5d5d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.nav li&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    color: #d5d5d5;</span><br><span class="line">    line-height: 28px;</span><br><span class="line">    margin-left: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.nav-left&#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    left: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.nav-right&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-music&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border-bottom: 1px solid black;</span><br><span class="line">    background-color: #f0f3ef;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-wrapper&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    left: 100px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-wrapper .main-logo&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    top: 15px;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height:80px;</span><br><span class="line">    background-image: url(&quot;..&#x2F;bg.png&quot;);</span><br><span class="line">    background-size: 100% 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-wrapper .main-search&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">    color: #5d5d5d;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-search .search&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 250px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    border-radius: 20px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    left: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-search .submit&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    border-radius: 20px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    left: 30px;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-list ul&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 500px;</span><br><span class="line">    left: 225px;</span><br><span class="line">    top: 75px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-list li&#123;</span><br><span class="line">    display: block;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">    font-family: &quot;黑体&quot;;</span><br><span class="line">    background: #b1cbe0;</span><br><span class="line">    border: 1px solid #d5d5d5;</span><br><span class="line">    opacity: 0.7;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.main-list img&#123;</span><br><span class="line">    display: block;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="2"><li>上网查找豆瓣开发者API V2, 以前这里有文档写着后台接口，现在没有需要自己摸索（查资料）才能知道豆瓣的后台接口使啥。摸索完接口之后，我们这里用音乐接口作为例子，使用JQuery和封装Ajax,进行后台数据的接受。</li></ol><blockquote><p>javascript代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    (function()&#123;</span><br><span class="line">    var $search &#x3D; $(&#39;.search&#39;);</span><br><span class="line">    var $ul &#x3D; $(&#39;ul&#39;,&#39;.main-list&#39;);</span><br><span class="line">    $search.on(&#39;input&#39;,function()&#123;</span><br><span class="line">        var value &#x3D; $(this).val();</span><br><span class="line">        console.log(value);</span><br><span class="line">        getData(value ,7);</span><br><span class="line">    &#125;)</span><br><span class="line">    function getData(value, num)&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type:&#39;get&#39;,             &#x2F;&#x2F;获取方式为get</span><br><span class="line">            url :&#39;https:&#x2F;&#x2F;api.douban.com&#x2F;v2&#x2F;music&#x2F;search&#39;,  &#x2F;&#x2F;豆瓣音乐后台地址</span><br><span class="line">            data: &#39;q&#x3D;&#39; + value +&#39;&amp;count&#x3D;&#39; + num,    &#x2F;&#x2F;获取的数据</span><br><span class="line">            dataType :&#39;jsonp&#39;,      &#x2F;&#x2F;获取方式为jsonp</span><br><span class="line">            success : addItem       &#x2F;&#x2F;获取成功之后的函数addItem</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    function addItem(data)&#123;</span><br><span class="line">        var list &#x3D; data.musics;</span><br><span class="line">        var str &#x3D; &#39;&#39;;</span><br><span class="line">        list.forEach(function(ele ,index)&#123;</span><br><span class="line">            str +&#x3D; &#39;&lt;li&gt;&quot;&#39;+ele.title+&#39;&quot;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;music.douban.com&#x2F;subject&#x2F;&#39;+ele.id+&#39;&#x2F;&quot;&gt;&lt;img src&#x3D;&quot;&#39;+ele.image+&#39;&quot; &gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        $ul.html($(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><blockquote><p>在数据获取成功之后我们通过foEach循环把获取回来的数据通过JQuery的html()方法插入到指定的文本当中,点击图片会跳转到歌曲页面。</p></blockquote><img src="/blog/blog/2019/05/07/douban/2019/05/07/douban/2.png" class title="根据歌曲id，跳转到歌手页面"><h2 id="豆瓣后台的项目大致就是这样啦。"><a href="#豆瓣后台的项目大致就是这样啦。" class="headerlink" title="豆瓣后台的项目大致就是这样啦。"></a>豆瓣后台的项目大致就是这样啦。</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用豆瓣api做联想搜索&quot;&gt;&lt;a href=&quot;#使用豆瓣api做联想搜索&quot; class=&quot;headerlink&quot; title=&quot;使用豆瓣api做联想搜索&quot;&gt;&lt;/a&gt;使用豆瓣api做联想搜索&lt;/h2&gt;&lt;h6 id=&quot;项目目的：进行JQuery和Ajax的练习，仿照豆瓣的输入联想功能。在豆瓣后台返回数据的时候点击选项跳转到相关页面。&quot;&gt;&lt;a href=&quot;#项目目的：进行JQuery和Ajax的练习，仿照豆瓣的输入联想功能。在豆瓣后台返回数据的时候点击选项跳转到相关页面。&quot; class=&quot;headerlink&quot; title=&quot;项目目的：进行JQuery和Ajax的练习，仿照豆瓣的输入联想功能。在豆瓣后台返回数据的时候点击选项跳转到相关页面。&quot;&gt;&lt;/a&gt;项目目的：进行JQuery和Ajax的练习，仿照豆瓣的输入联想功能。在豆瓣后台返回数据的时候点击选项跳转到相关页面。&lt;/h6&gt;
    
    </summary>
    
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="实战项目" scheme="https://fengzehe.github.io/blog/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP</title>
    <link href="https://fengzehe.github.io/blog/2019/04/27/network-note/"/>
    <id>https://fengzehe.github.io/blog/2019/04/27/network-note/</id>
    <published>2019-04-27T02:36:18.000Z</published>
    <updated>2020-06-18T10:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简单HTTP协议："><a href="#简单HTTP协议：" class="headerlink" title="简单HTTP协议："></a>简单HTTP协议：</h4><blockquote><p>HTTP协议用于客户端和服务器端之间的通信。</p></blockquote><a id="more"></a><p>告知服务器意图的各种HTTP方法：</p><ol><li><p>GET：获取资源</p></li><li><p>POST：用来传输实体的主体，post的主要目的并不是获取响应的主体内容</p></li><li><p>PUT：传输文件，跟FTPyiyang ,但PUT方法自身不带验证机制，因此存在安全性问题而不被使用。</p></li><li><p>HEAD：获得报文首部，用于确认URI的有效性及资源更新的日期时间。</p></li><li><p>ELETE: 删除文件，跟put相反的方法，DELETE方法按请求URI删除指定的资源</p></li><li><p>OPTIONS：询问支持的方法</p></li><li><p>TRACE:追踪路径</p></li><li><p>OPTIONS：询问支持的方法</p></li><li><p>TRACE : 追踪路径，但容易受到跨站追踪的工资，因此很少使用。</p></li><li><p>CONNECT: 要求用隧道协议连接</p></li></ol><ul><li>持久连接：只要任意一方没有明确提出断开连接，则保持TCP连接状态。<blockquote><p>优点：持久连接的好处在于减少了建立和断开所造成的额外开销，减轻了服务器端的负载。因此Web页面现在是速度也就相应提高了。只要任意一端没有明确提出断开连接，则保持TCP连接状态。这样的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减少了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和相应能更早的结束，这样Web页面显示的速度也相应提高了。HTTP1.1具有持久连接。</p></blockquote></li></ul><blockquote><p>HTTP是不保存状态的协议，因此引出了Cookie。</p></blockquote><ul><li>Cookie的状态连接：<blockquote><p>HTTP是无状态协议，可以减少服务器的CPU以及内存资源的消耗，而缺点在于每次跳转新页面都要再次登录或者再请求报文中附加参数来管理登录状态。Cookie会根据从服务器端发送的相应报文内的一个Set-cookie的首部字段信息，通知客户端保存Cookie。当下午客户端再向该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p></blockquote></li></ul><p>HTTP报文的HTTP信息：</p><ul><li><p>HTTP报文：请求端（客户端）的HTTP报文称为请求报文，响应端（服务器端）的叫做响应报文。</p></li><li><p>报文主体和实体主体的差异：</p></li></ul><ol><li>报文是HTTP通信中的基本单位，由8位组字节流组，通过HTTP通信传输。</li><li>实体：作为请求或响应的有效负载数据（补充项）被传输，其内容由实体首部和实体主体组成。</li></ol><ul><li>返回结果的HTTP状态码：<blockquote><p>1XX：信息性状态码，接受的请求正在处理</p></blockquote></li></ul><blockquote><p>2XX：状态成功码，请求正常处理完毕<br>200 ok<br>204 No Content 代表服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主体部分。</p></blockquote><blockquote><p>3XX：重定向状态码，需要进行附加操作以完成请求<br>301 Moved Permanently 永久性重定向，说明请求的资源已经被分配了新的URI。<br>302 Found 临时重定向。该状态码表示请求资源已经被分配了新的URI，希望用户（本次）使用新的URI访问。<br>303 See Other 表示由于请求对应的资源存在另外一个URI，应使用GET方法定向获取请求的资源。<br>304 Not Modified 表示客户端发送附带条件的请求，服务器允许请求访问资源，但未满足条件的情况，304状态码返回。<br>307 Temporary Redirect 临时重定向。与302有相同的含义。</p></blockquote><blockquote><p>4XX：客户端错误状态码，服务器无法处理请求<br>400 Bad Request 表示报文中存在语法错误<br>401 Unauthorized 该状态码表示发送的请求需要通过有HTTP认证（BASIC认证，DIGEST认证）的认证信息<br>403 Forbidden  表明请求资源的访问被服务器拒绝了。<br>404 Not Found 表明服务器上无法找到请求的资源。</p></blockquote><blockquote><p>5XX：服务器错误状态码，服务器处理请求出错<br>500 Internal Server Error 表明服务器端在执行请求时发生了错误，也可能是Web应用存在的bug或某些临时的故障。<br>503 Server Unavailable 表明服务器处于超负载或者正在进行停机维护。</p></blockquote><p>与HTTP协作的Web服务器</p><ul><li>在互联网中，域名听过DNS服务映射到IP地址（域名解析）之后访问目标网站，可见，当请求发送到服务器时已经是以IP地址形式的访问了。</li></ul><p>通信数据转发程序：代理，网关，隧道</p><ol><li>代理——扮演者客户端和服务器的中间人角色，接受客户端发送的请求并转发给服务器，同时也接受服务器返回的响应并转发给客户端。</li><li>网关是转发其他服务器通信数据的服务器，接受从客户端发送过来的请求，它就会像自由拥有资源的源服务器一样对请求进行处理。</li></ol><ul><li>缓存服务器：优势在于利用缓存可避免对此从源服务器转发资源。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简单HTTP协议：&quot;&gt;&lt;a href=&quot;#简单HTTP协议：&quot; class=&quot;headerlink&quot; title=&quot;简单HTTP协议：&quot;&gt;&lt;/a&gt;简单HTTP协议：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;HTTP协议用于客户端和服务器端之间的通信。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="HTTP" scheme="https://fengzehe.github.io/blog/tags/HTTP/"/>
    
      <category term="读书笔记" scheme="https://fengzehe.github.io/blog/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSS2.0学习笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/04/26/CSSnote/"/>
    <id>https://fengzehe.github.io/blog/2019/04/26/CSSnote/</id>
    <published>2019-04-26T07:13:39.000Z</published>
    <updated>2020-06-18T10:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-cascading-style-sheet-层叠样式表"><a href="#CSS-cascading-style-sheet-层叠样式表" class="headerlink" title="CSS (cascading style sheet 层叠样式表)"></a>CSS (cascading style sheet 层叠样式表)</h2><h4 id="引入css"><a href="#引入css" class="headerlink" title="引入css"></a>引入css</h4><ol><li>行间样式，即<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">""</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><a id="more"></a></li><li>页面级CSS，在head里面引入一个style标签，在里面写css代码。</li><li>引用外部css文件,即<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&gt;</span><br></pre></td></tr></table></figure></li><li>link和!import引入的区别<ol><li>Link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务;@import属于CSS范畴，只能加载CSS</li><li>link引用CSS时，在页面载入是同时加载; @import需要页面网页完全载入后再加载</li><li>link是XHTML标签，无兼容问题; @import是CSS2.1提出的 ，低版本浏览器不支持</li><li>link使用Javascript控制DOM改变样式，而@import不支持</li></ol></li></ol><ul><li>把html,css放在服务器上，浏览器下载一行代码并执行一行代码。属于异步执行，因为计算机的异步和同步相对于我们的理解来说是相反的。</li></ul><hr><h4 id="2-选择器"><a href="#2-选择器" class="headerlink" title="(2)选择器"></a>(2)选择器</h4><ol><li>id选择器一个元素只能有一个id选择器。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">""</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>类选择器,一个类选择器可对应对个元素。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">""</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>标签选择器，适用于标签，例如说div a。</li><li>通配符选择器 *{} 选中所有的标签。这个用于初始化标签非常有作用。</li><li>属性选择器</li></ol><ul><li>选择器的权重（从高-低）<blockquote><p>important（正无穷）-&gt;行间样式（1000）–&gt;id（100）–&gt;class 属性选择器 （10） –&gt;标签选择，伪元素（1） ——&gt;通配符（0）</p></blockquote></li></ul><p>父子选择器： div span{}</p><ul><li><p>特点：不在于一定要使用标签选择器，class id 选择器都可以，只要成立父子关系就可以了。</p></li><li><p>注意：浏览器定义父子选择器的顺序为从右到左，因为这样速度更快。</p></li><li><p>子元素选择器：即符号下的直接向下的选择方式，例如h1&gt;strong{;}</p></li><li><p>注意：浏览器定义父子选择器的顺序为从右到左，因为这样速度更快。</p></li></ul><p>并列选择器：<br>特点：当同时存在相同标签及相同类名时，可通过标签名和类名混合使用达到选中区域的效果。</p><p>权重选择器：<br>特点：只要是同一横行想选择器，权重值为相加，若权重值一样，则后面的代码会覆盖前面的代码。</p><p>分组选择器：<br>特点：例如说div span想设置一样的背景颜色，在减少冗余的角度来看，div span{}这样写css。</p><hr><h4 id="3-CSS基础属性："><a href="#3-CSS基础属性：" class="headerlink" title="(3)CSS基础属性："></a>(3)CSS基础属性：</h4><ol><li>字体大小<br>font-size px; 浏览器默认为16px;<br>font-wight:blod 字体加粗<br>font-style:italic；斜体<br>font-family:arial;互联网上的通用字体<br>color:设置字体颜色.</li><li>纯英文字母</li><li>颜色代码 （00-ff，00-ff,00-ff）分别代表rgb，red green,blue.</li><li>颜色函数，color:rgb(0-255,0-255,0-255)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid(dotted点状，dashed 条状) black;（10px粗细，实线，黑色）</span><br><span class="line">text-align:right;文本向右对齐  text-align: center 文本居中显示</span><br><span class="line">line-height: 20px； 行高。因此让单行文本水平居中的做法就是让行高=容器高度</span><br><span class="line">text-indent:2em(2个font-size)</span><br><span class="line">cursor:(pointer 当光标移动到哪个区域，就会变成另外的符号，<span class="built_in">help</span> ,move, pointer)</span><br><span class="line">伪类选择器 a:hover&#123;&#125; 在元素被光标选中的时候触发各种效果。</span><br></pre></td></tr></table></figure><ol start="2"><li>元素的分类：<br>行级元素 inline</li></ol><ul><li>特征：内容决定元素所占位置，不可以通过css改变宽高。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt; &lt;strong&gt; &lt;em&gt; &lt;a&gt; &lt;del&gt;</span><br></pre></td></tr></table></figure></li></ul><p>块级元素 block</p><ul><li>特征：独占一行，可通过css改变宽高<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt; &lt;p&gt; &lt;ul&gt;&lt;li&gt;&lt;ol&gt; &lt;form&gt; &lt;address&gt;</span><br></pre></td></tr></table></figure></li></ul><p>行级块元素 inline-block</p><ul><li>特征：1.内容决定元素所占位置 2.可以通过css改变宽高。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img&gt; &lt;input&gt;</span><br></pre></td></tr></table></figure></li><li>凡是带有inline的都显示文字特性，因此会被分割，导致多张图片并排会有空隙产生。</li><li>注意：在开发的时候先写css样式再写html，因为clas是一对多关系的，所以这些属性都能通过组合加上去——先定义后选样式。</li><li>注意：用标签选择器做初始化，因为标签选择器的权重是0，若是用户想自定义修改那么通过增加权重就可以实现。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS-cascading-style-sheet-层叠样式表&quot;&gt;&lt;a href=&quot;#CSS-cascading-style-sheet-层叠样式表&quot; class=&quot;headerlink&quot; title=&quot;CSS (cascading style sheet 层叠样式表)&quot;&gt;&lt;/a&gt;CSS (cascading style sheet 层叠样式表)&lt;/h2&gt;&lt;h4 id=&quot;引入css&quot;&gt;&lt;a href=&quot;#引入css&quot; class=&quot;headerlink&quot; title=&quot;引入css&quot;&gt;&lt;/a&gt;引入css&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;行间样式，即&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div style=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="CSS" scheme="https://fengzehe.github.io/blog/tags/CSS/"/>
    
  </entry>
  
</feed>
