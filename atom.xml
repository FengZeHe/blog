<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何泽丰的博客</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://fengzehe.github.io/blog/"/>
  <updated>2020-07-30T06:36:44.000Z</updated>
  <id>https://fengzehe.github.io/blog/</id>
  
  <author>
    <name>何泽丰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>菜鸟成长记08 计算base64格式图片大小</title>
    <link href="https://fengzehe.github.io/blog/2020/07/30/record08/"/>
    <id>https://fengzehe.github.io/blog/2020/07/30/record08/</id>
    <published>2020-07-30T06:23:26.000Z</published>
    <updated>2020-07-30T06:36:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言： 我们在使用vant uploader组件的时候，除了需要校验单张图片上传大小，有时候还要验证多张图片一共的大小。</p><p>我们知道uploader组件有max-size和oversize事件，在文件超过限制的时候触发。但图片大小之和怎么计算呢？</p></blockquote><a id="more"></a><h4 id="after-read"><a href="#after-read" class="headerlink" title="after-read"></a>after-read</h4><p>在查看vant官方文档的时候发现当图片读取完成后的回调函数时after-read。</p><p><img src="https://fengzehe.github.io/blog/2020/07/30/record08/after-read.png" alt></p><p>我们把函数传递的参数打印一下，发现里面的content部分是base64格式的图片，一张2.4M大小的图片base64格式看起来就如下图。</p><p><img src="https://fengzehe.github.io/blog/2020/07/30/record08/base64.png" alt></p><h4 id="函数处理"><a href="#函数处理" class="headerlink" title="函数处理"></a>函数处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取base64图片大小，返回kb数字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseSize</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content  = file.content;</span><br><span class="line">  <span class="comment">//把头部去掉</span></span><br><span class="line">  <span class="keyword">var</span> str = content.replace(<span class="string">'data:image/png;base64,'</span>, <span class="string">''</span>);</span><br><span class="line">  <span class="comment">// 找到等号，把等号也去掉</span></span><br><span class="line">  <span class="keyword">var</span> equalIndex = str.indexOf(<span class="string">'='</span>);</span><br><span class="line">  <span class="keyword">if</span>(str.indexOf(<span class="string">'='</span>)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      str=str.substring(<span class="number">0</span>, equalIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原来的字符流大小，单位为字节</span></span><br><span class="line">  <span class="keyword">var</span> strLength=str.length;</span><br><span class="line">  <span class="comment">// 计算后得到的文件流大小，单位为字节</span></span><br><span class="line">  <span class="keyword">var</span> fileLength=<span class="built_in">parseInt</span>(strLength-(strLength/<span class="number">8</span>)*<span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 由字节转换为kb</span></span><br><span class="line">  <span class="keyword">var</span> size = <span class="string">""</span>;</span><br><span class="line">  size = (fileLength / <span class="number">1024</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> sizeStr = size + <span class="string">""</span>; <span class="comment">//转成字符串</span></span><br><span class="line">  <span class="keyword">var</span> index = sizeStr.indexOf(<span class="string">"."</span>); <span class="comment">//获取小数点处的索引</span></span><br><span class="line">  <span class="keyword">var</span> dou = sizeStr.substr(index + <span class="number">1</span>, <span class="number">2</span>) <span class="comment">//获取小数点后两位的值</span></span><br><span class="line">  <span class="keyword">if</span> (dou == <span class="string">"00"</span>) &#123; <span class="comment">//判断后两位是否为00，如果是则删除00                </span></span><br><span class="line">    <span class="keyword">return</span> sizeStr.substring(<span class="number">0</span>, index) + sizeStr.substr(index + <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>如图，我们就能计算这张图片的实际大小了</p><p><img src="https://fengzehe.github.io/blog/2020/07/30/record08/allpic.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言： 我们在使用vant uploader组件的时候，除了需要校验单张图片上传大小，有时候还要验证多张图片一共的大小。&lt;/p&gt;
&lt;p&gt;我们知道uploader组件有max-size和oversize事件，在文件超过限制的时候触发。但图片大小之和怎么计算呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="rookie growth record" scheme="https://fengzehe.github.io/blog/categories/rookie-growth-record/"/>
    
    
      <category term="-- record" scheme="https://fengzehe.github.io/blog/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟成长记07 getElementsByClassName()的实现</title>
    <link href="https://fengzehe.github.io/blog/2020/07/27/record07/"/>
    <id>https://fengzehe.github.io/blog/2020/07/27/record07/</id>
    <published>2020-07-27T07:34:47.000Z</published>
    <updated>2020-08-05T02:34:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：我们在使用js使用DOM选中元素时一般都是document.getElementsByClassName()，那具体此方法是如何实现的呢？</p></blockquote><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li><p>在整个页面中选取某个className，需要拿到整个DOM树。可以这样实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allDomArray = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>);</span><br></pre></td></tr></table></figure></li><li><p>因为拿到的类名不是规整的，有时候我们需要处理一下空格字符串。我们把处理该方法的操作封装在函数上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trimSpace</span>(<span class="params">strClass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\s+/g</span>;</span><br><span class="line"><span class="keyword">var</span> newstrClass = strClass.replace(reg, <span class="string">' '</span>).trim();<span class="comment">//封装好的方法，去除首尾空格</span></span><br><span class="line"><span class="keyword">return</span> newstrClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在处理完类名的格式后，我们大概就能选中DOM结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.getElementsByClassName = Element.prototype.getElementsByClassName = <span class="function"><span class="keyword">function</span> (<span class="params">_className</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> allDomArray = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>);</span><br><span class="line"><span class="keyword">var</span> lastDomArray = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; allDomArray.length; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> lastClassName = trimSpace(allDomArray[i].className).trim();</span><br><span class="line"><span class="keyword">var</span> classArray = lastClassName.split(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; lastClassName.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (classArray[j] == _className) &#123;</span><br><span class="line">lastDomArray = lastDomArray.push(classArray[i]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lastDomArray;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">trimSpace</span>(<span class="params">strClass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\s+/g</span>;</span><br><span class="line"><span class="keyword">var</span> newstrClass = strClass.replace(reg, <span class="string">' '</span>);<span class="comment">//封装好的方法，去除首尾空格</span></span><br><span class="line"><span class="keyword">return</span> newstrClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="效果如下图"><a href="#效果如下图" class="headerlink" title="效果如下图"></a>效果如下图</h4><p><img src="https://fengzehe.github.io/blog/2020/07/27/record07/output.png" alt></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByClassName = <span class="literal">undefined</span>;</span><br><span class="line">Element.prototype.getElementsByClassName = Document.prototype.getElementsByClassName = <span class="built_in">document</span>.getElementsByClassName || <span class="function"><span class="keyword">function</span> (<span class="params">_className</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this DOM</span></span><br><span class="line">    <span class="comment">// 如果 children不兼容的话这里也要通过childNodes来做一下兼容</span></span><br><span class="line">    <span class="keyword">var</span> allDomArray = [].slice.call(<span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> newDomArray = [];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">trimClassName</span>(<span class="params">dom</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/\s+/g</span>;</span><br><span class="line">        <span class="comment">// 把所有的空格变成一个先</span></span><br><span class="line">        <span class="keyword">var</span> newClassStr = dom.className.replace(reg, <span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">return</span> newClassStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allDomArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newClassStr = trimClassName(ele).trim();</span><br><span class="line">        <span class="keyword">var</span> classNameArray = newClassStr.split(<span class="string">' '</span>);</span><br><span class="line">        classNameArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">className, index</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (className == _className) &#123;</span><br><span class="line">                newDomArray.push(ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> newDomArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：我们在使用js使用DOM选中元素时一般都是document.getElementsByClassName()，那具体此方法是如何实现的呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="rookie growth record" scheme="https://fengzehe.github.io/blog/categories/rookie-growth-record/"/>
    
    
      <category term="-- record" scheme="https://fengzehe.github.io/blog/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>人生不止有技术 -- 诚者自成也</title>
    <link href="https://fengzehe.github.io/blog/2020/07/27/technology02/"/>
    <id>https://fengzehe.github.io/blog/2020/07/27/technology02/</id>
    <published>2020-07-27T07:19:10.000Z</published>
    <updated>2020-07-30T06:44:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章分别从内心强大，内在情感与不把事情当做手段进行赘述。这一篇文章将从<strong>内秀</strong>和<strong>做你自己</strong>这两方面展开阐述。</p><a id="more"></a><p><img src="https://fengzehe.github.io/blog/2020/07/27/technology02/book.png" alt></p><h4 id="内秀"><a href="#内秀" class="headerlink" title="内秀"></a>内秀</h4><p>笔者认为成功的内涵是<strong>人的内在精神品质</strong>，但成功是披着金钱地位的外表而来。让我们时常迷惑认为财富与权力即代表着成功。按照耳熟能详的马斯洛需求原理，人在满足最低的温饱及安全需求后才会有更高层次的追求。按照王阳明的话来说<strong>成功固然需要外部的物质条件，但必定是来源于内在的精神品质。</strong>道理都殊途同归。</p><p>当一个人的人格和精神品质得到了完善，他所投射出来的成功才会是健全的，长久的，并且真正值得拥有。传统意义上的成功是人格的镜像。如果一个人能够具备善良，爱心，忠诚，宽容，正直，诚实，坚毅，勇敢，智慧，谦逊，感恩，同情心等这些品质，并能够在与他人交往互动的时候自然表现出来，那么这时候成功已经不自觉来到我们的身边，且不管走到哪里它都跟到哪里。<strong>成功虽然会以财富，权利，地位，名望等诸如此类的东西为外表，但从本质和来源上来讲，它是人格的外化，人格的影子和副产品。正如孔子所言：”谋道不谋食，忧道不忧贫”。意思是说人应该把注意力放在自己的人格是否完善上，不必担忧成功何时会到来。</strong></p><p>但其实我们也会有这种困惑，”为什么xxx他是个坏人还发财了？而好人却没有发财？”啊哈那这个问题我们可以思考下，有什么道理能解释得通。还有..就是或许我们不能苛求还没达到最低安全需求的人有更高精神层面上的追求。</p><h4 id="做你自己"><a href="#做你自己" class="headerlink" title="做你自己"></a>做你自己</h4><p><strong>“慎独”这个概念出自《大学》“诚于中，形于外，故君子必慎其独也”</strong>。意思是：一个人拥有什么样的内在人格，就必然会有什么样的言行表现于外，所以君子在独处的时候，必然会跟在大庭广众之下一样谨慎，始终恪守做人的道德原则。</p><p>笔者在解读王阳明心学是这样解释的，“人如果不在这种‘独知’的地方、在自己的内心世界用力，而只在言行表露于外的时候、在人所共知的地方用功，那就是自欺欺人，就是作伪。《大学》称这种人是‘见君子而后厌然’，这个‘厌’不是厌恶之意，而是‘掩藏’之意，意思是这种人全然不在‘独知’时用功，只会在遇见君子时才极力掩藏自己的毛病。</p><p>这有点像在学校和工作中在外力的监督下能够做好的事情，在家就很难办到了。慎独是在独处时候一种更高的修炼（但我还不可以）。</p><p>笔者认为人在掌握基本生活资料后首先应该关注的就是自己的内心品质，其次才是积累更多的外部生活的资料。<strong>因为人的总体生活质量的高低，或许还是取决于内心的感受和评定</strong>；<strong>而内心品质的好坏，却不能由外部的生活资料的多寡来决定</strong>。用人话来说既在满足基本生活的物质条件下，外部生活资料的多少并不能决定生活质量的高低。当然这里说的物质条件只能自己跟自己比，笔者的意思是内心品质的好坏是很大程度上与内心品质的好坏关联。</p><p>所以我们说一个人要为自己负责，意思是要为自己的内心品质负责。我们在上一章中把人心比作一面镜子，通过心中那面镜子对外部事情好坏的判断——事情好坏的判断就在内心的一念之差。所以说对内心品质只能自己帮自己。</p><p><strong>如果说外部生活是水，那么内心品质就像是容器。容器的大小、形状、颜色，将决定你能装多少水，以及装进去的水最后会呈现出什么样的形状和颜色。</strong></p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>当然在阅读的开头我也问了自己一个问题——传统国学是否是陈腐老旧而已经不符合现代了呢？——当然传统国学存在糟粕，但糟粕并不是全部。不能以糟粕全盘否定传统国学，就像传统国学智慧与精妙也不能用简答一两句话概括。或许我们自己要判断一些观点是否合理（例如说愚孝肯定是非常不合理的，卧冰求鲤，郭巨埋儿）</p><p>阅读传统国学类书籍就好像发现了一个新大陆，在阅读完这本书后我的内心异常平静，像是对精神世界的一次洗礼。我也对自己进行反省，发现自己在许多地方做得很不好，最近一段时间我发现自己能更好的控制自己的情绪，也很少受到外部影响。因此我也能把更多注意力放在工作与学习上，看起来生活也慢慢变得平静和充实——这个过程中也是对我精神世界极大的滋养与丰富。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章分别从内心强大，内在情感与不把事情当做手段进行赘述。这一篇文章将从&lt;strong&gt;内秀&lt;/strong&gt;和&lt;strong&gt;做你自己&lt;/strong&gt;这两方面展开阐述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="not only technology" scheme="https://fengzehe.github.io/blog/categories/not-only-technology/"/>
    
    
      <category term="-- 人生不止有技术" scheme="https://fengzehe.github.io/blog/tags/%E4%BA%BA%E7%94%9F%E4%B8%8D%E6%AD%A2%E6%9C%89%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟成长记06 蒙层是怎么实现的</title>
    <link href="https://fengzehe.github.io/blog/2020/07/27/record06/"/>
    <id>https://fengzehe.github.io/blog/2020/07/27/record06/</id>
    <published>2020-07-27T02:54:24.000Z</published>
    <updated>2020-07-30T06:38:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：用户使用产品时有些小细节需要我们注意，例如显示弹窗时不让用户再点击其他操作。</p></blockquote><a id="more"></a><h4 id="弹窗是怎么实现的呢？"><a href="#弹窗是怎么实现的呢？" class="headerlink" title="弹窗是怎么实现的呢？"></a>弹窗是怎么实现的呢？</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol><li>弹窗不仅仅是一个弹窗，仔细观察会发现后面的背景也暗下来变成了透明的深灰色。</li><li>在弹窗显示后用户不能进行其他操作——可以防止很皮的用户乱点。</li></ol><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ol><li><p>为了不让用户进行其他操作，需要用一个div把整个页面盖住。于是我们这样设置一个div。距离上跟左两边的距离设置为0撑开内容区。并且设置透明度为0.5(如图)</p><p><img src="https://fengzehe.github.io/blog/2020/07/27/record06/2.png" alt></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layer</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: fixed;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">rgba</span>(0, 0, 0, 0.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当我们拥有一个遮罩后需要弄一个真正的弹窗，弹窗出现在屏幕中间。里面有一个内容区以及确定按钮。因为背景是黑色的，我们需要白色背景增强对比</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layerContent</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">0.5rem</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">1rem</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><p><img src="https://fengzehe.github.io/blog/2020/07/27/record06/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言：用户使用产品时有些小细节需要我们注意，例如显示弹窗时不让用户再点击其他操作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="rookie growth record" scheme="https://fengzehe.github.io/blog/categories/rookie-growth-record/"/>
    
    
      <category term="-- record" scheme="https://fengzehe.github.io/blog/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟成长记05 Mac下配置apache</title>
    <link href="https://fengzehe.github.io/blog/2020/07/16/record05/"/>
    <id>https://fengzehe.github.io/blog/2020/07/16/record05/</id>
    <published>2020-07-16T02:20:41.000Z</published>
    <updated>2020-07-30T06:39:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言 平时我们在开发的时候会写一份本地的json假数据。之前我们都用ajax的GET方式来获取</p></blockquote><a id="more"></a><p><img src="https://fengzehe.github.io/blog/2020/07/16/record05/get.png" alt></p><p><img src="https://fengzehe.github.io/blog/2020/07/16/record05/get1.png" alt></p><p>但现在有业务需求需要用post来获取，如果在vscode中使用live server打开就会出现这种错误。</p><p><strong>Failed to load resource: the server responded with a status of 405 (Method Not Allowed)</strong></p><p><img src="https://fengzehe.github.io/blog/2020/07/16/record05/post.png" alt></p><p><img src="https://fengzehe.github.io/blog/2020/07/16/record05/post1.png" alt></p><p>网上许多解决方法都是windows下的解决方案，例如说</p><p>（1）不通过IIS访问，使用其他的访问方式</p><p>（2）修改IIS的“处理程序映射”。</p><p>但在Mac下并没有特别好的解决方法。</p><p>这时候我回想了一下，请求静态资源是要用get请求，使用post请求的时候并且发送url是一个具体的资源的时候，网络会把url当做域名来解析。</p><p>虽然道理是这样的，我想了一下live server是小型服务器，那我或许也可以在apache上跑一下。</p><p>然后配置了一下apache并启动就可以了。</p><p><img src="https://fengzehe.github.io/blog/2020/07/16/record05/start.png" alt></p><p><img src="https://fengzehe.github.io/blog/2020/07/16/record05/post2.png" alt></p><p>Apache的配置</p><p>Mac虽然是自带Apache，但文件根目录非常难找，在<code>/etc/apache2/</code> 的文件夹下</p><p><img src="https://fengzehe.github.io/blog/2020/07/16/record05/apache1.png" alt></p><p>我们找到httpd.conf文件后可以用sublime Text打开。找到DocumentRoot 这两行，修改为自定义路径。</p><p>例如我修改为<code>/Users/hezefeng/Server</code></p><p><img src="https://fengzehe.github.io/blog/2020/07/16/record05/apache2.png" alt></p><p>然后往下找，把<code>Options FollowSymLink</code>修改为<code>Options Indexes FollowSymLinks</code></p><p><img src="https://fengzehe.github.io/blog/2020/07/16/record05/apache3.png" alt></p><p>再往下找，把<code>#LoadModule php7_module libexec/apache2/libphp7.so</code>最前面的#去掉。</p><p><img src="https://fengzehe.github.io/blog/2020/07/16/record05/apache4.png" alt></p><p>事后重启一下服务器就好了，可以通过POST获取本地的json数据了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言 平时我们在开发的时候会写一份本地的json假数据。之前我们都用ajax的GET方式来获取&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="rookie growth record" scheme="https://fengzehe.github.io/blog/categories/rookie-growth-record/"/>
    
    
      <category term="-- record" scheme="https://fengzehe.github.io/blog/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>人生不止有技术 -- 我们的小宇宙</title>
    <link href="https://fengzehe.github.io/blog/2020/07/15/technology01/"/>
    <id>https://fengzehe.github.io/blog/2020/07/15/technology01/</id>
    <published>2020-07-15T01:55:59.000Z</published>
    <updated>2020-07-30T06:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    朋友们，如果你在这时候打开了这篇推文，恰好手头上也没有事情，请静下心来听我娓娓道来。上周阅读的《王阳明心学》，是笔者王觉仁对王阳明部分思想的解读。<strong>如果想看原本的王阳明可以看《传习录》</strong>。书的内容比较杂，但总能予以读者启发。下面是我对书中内容部分的摘录与理解，想与大家分享。</p><a id="more"></a><p><img src="https://fengzehe.github.io/blog/2020/07/15/technology01/book.png" alt></p><p>​    由于内容较多,《王阳明心学》摘录的笔记分为上下两部分。这一篇文章将从<strong>内心强大，内在情感</strong>以及<strong>回归事情本身</strong>进行赘述。</p><h4 id="关于内心强大"><a href="#关于内心强大" class="headerlink" title="关于内心强大"></a>关于内心强大</h4><blockquote><p> ‘’你赤手空拳来到人世间 为找到那片海不顾一切’’                    –生活不止眼前的苟且</p></blockquote><p>​    走出校园的我们会遇到很多人，学会很多知识，掌握许多谋生技巧，了解人情世故，林林总总。但我们真的准备好了吗？或者自己所想的坚持不如想象中那么坚定，受到质疑时会有所动摇。或者在诱惑面前并没有那么清醒，或者说我们还是会因为一句话耿耿于怀，或许会为生活中的琐碎烦心。就像《象与骑象人》中所说，<strong>世界上的事情本没有意义，但通过我们内心的反射便有各种神奇反应。</strong></p><p>​    笔者认为<strong>人的内心就像一面镜子</strong>——外界事物透过这面镜子反射在我们的心上产生各种反应。内心充满各种超出正常需求的欲望时，内心的镜子是充满污垢，不能看清自己的内心，也就是不能倾听自己内心真正需要什么。</p><p>  我们要是能审视自己的内心，认识真正的自我，<strong>能在喧嚣浮躁的世界建立独属于自己的一套价值观</strong>。就像是波涛里沉浮的灯塔，不管惊涛骇浪还能为航行指明方向。例如现实中大多数人所追求的<strong>成功</strong>——<strong>物质条件的富裕程度</strong>。我们想一想这个世界上没有两个完全一样的人，但<strong>为什么大多数人的价值观都单一得可怕呢</strong>？人在世界上需要各种物质条件是太正确了，没有物质根本不能生存。我们是否该在拥有一定物质条件的情况下倾听下自己的内心呢？</p><h4 id="关于内在情感"><a href="#关于内在情感" class="headerlink" title="关于内在情感"></a>关于内在情感</h4><blockquote><p>“未发之中”，语出《中庸》，原文是“喜怒哀乐之未发，谓之中；发而皆中节，谓之和”。意思是，人之喜、怒、哀、乐等情感尚未发动时，内心保持一种寂然不动、不偏不倚的状态，就叫作”中”；情感表现出来时，都能把握一个适当的度，符合自然常理、社会规范和伦理准则，就叫作”和”</p></blockquote><p>  我们的生活节奏很快、工作压力很大、烦恼纠结很多、睡眠很差，本来情绪已经不好了，再遇上拥挤的交通真的很难做到“和”。那我们最简单可以做到什么呢？用慧海禅师的话说“<strong>饥来吃饭，困来既眠</strong>”。</p><p>  吃饭的时候想着工作的问题和生活的琐碎。躺床上的时候想着烦恼或懊悔，或者对现状的不满和焦虑。所谓“<strong>百种需索</strong>”，就是说把各种各样的东西装进内心，同样把烦恼也装进去了。 所谓“<strong>千般计较”</strong>，就是说计较生活中的各种得失利害，或许会错过事情本身。</p><p>  那该怎么办呢？</p><p>  笔者认为应该给自己一段独处的时间，<strong>暂时抛开生活中所有的羁绊和牵挂，进入自己的内心，真诚面对那个被现实遗忘很久的内在自我</strong>。做一些跟心灵有关的事情，例如说静坐，听一些感动心灵的音乐，阅读哲人写的书，尝试培养并加深自己对文学、艺术、美学和哲学等兴趣和感染力。<strong>久而久之，你就能给自己打造一个没有实用性，没有功利性的平净而丰富的内在世界，从而再造一个崭新的自我，重建自己与外部世界的关系。</strong></p><p>  我可以讲一下关于我的真实例子。我喜欢练字，练字的时候只是单纯的喜欢，每次写字的时候只关注字的结构与笔画，写完时都感觉神清气爽。</p><h4 id="回归事情本身"><a href="#回归事情本身" class="headerlink" title="回归事情本身"></a>回归事情本身</h4><p>  笔者认为我们做许多事情容易感到很累，可能不是因为事件本身，<strong>而是这些事情背后的东西</strong>。例如说读书是为了考大学，上大学是为了找工作，找工作是为了赚钱，活着是为了成功。</p><p>  人生中所做的事，林林总总都成了追求别的东西的手段，所以不管做什么事<strong>很少有体会到事情本身的价值和乐趣</strong>。因此有时候会觉得读书很累，上班很累 ，活着很累。想要活得不这么累我们可以换一个角度思考，发现事情本身的乐趣和价值。</p><p>  我们换一个角度思考 。例如说工作除了维持生计外更是磨炼人的能力，让我们更好的实现自身价值。</p><p>  <strong>当然不把事情当做手段不代表不需要设立目标。目标是为了更好的实现**</strong>。**笔者认为做事的过程中可以挖掘事情本身的乐趣与价值。制定目标当然能更好的实现一件事。</p><p>  最后，笔者认为我们可以培养<strong>更宽广更智慧更具兼容性的生活态度</strong>。<strong>这种生活态度不仅能容纳对目标的坚定追求，还能容纳对过程本身的体验，欣赏和享受</strong>；不仅我们朝最终的目标努力，还能让我们富有创造性地面对生活中的每件事，过好生命中的每一天。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a><strong>写在最后</strong></h4><p>​    本人今年毕业刚步入社会，每天匆忙挤着公交地铁，在繁忙喧嚣的广州工作。以后的路定是充满曲折与荆棘，跟所有人一样想着如何披荆斩棘一路过关斩将的我也时常问自己——“<strong>我准备好了吗</strong>？我的内心，思想与精神准备好了吗？”</p><p>​    如果你看到了这里，说明我们或许多少会被外界困扰与迷惑，但同样对未来充满希冀。愿我们心中的热爱与理想带领着我们去追寻，<strong>对吧，同路人。</strong></p><p>​    如果你看到了这里，也感觉对你有所帮助，不妨关注<strong>公众号MyEra或者点个赞点个好看</strong>，对于我来说是很大的帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    朋友们，如果你在这时候打开了这篇推文，恰好手头上也没有事情，请静下心来听我娓娓道来。上周阅读的《王阳明心学》，是笔者王觉仁对王阳明部分思想的解读。&lt;strong&gt;如果想看原本的王阳明可以看《传习录》&lt;/strong&gt;。书的内容比较杂，但总能予以读者启发。下面是我对书中内容部分的摘录与理解，想与大家分享。&lt;/p&gt;
    
    </summary>
    
    
      <category term="not only technology" scheme="https://fengzehe.github.io/blog/categories/not-only-technology/"/>
    
    
      <category term="-- 人生不止有技术" scheme="https://fengzehe.github.io/blog/tags/%E4%BA%BA%E7%94%9F%E4%B8%8D%E6%AD%A2%E6%9C%89%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟成长记 04 vue.js实战题目</title>
    <link href="https://fengzehe.github.io/blog/2020/07/13/record04/"/>
    <id>https://fengzehe.github.io/blog/2020/07/13/record04/</id>
    <published>2020-07-13T14:03:01.000Z</published>
    <updated>2020-07-30T06:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 在看vue.js实战的时候笔者留下了一道题:</p></blockquote><p>  <strong>1. 在当前示例基础上扩展商品列表，新增一项是否选中该商品的功能，总价变为只计算选中商品的总价，同时提供一个全选的按钮。</strong></p><a id="more"></a><p>  <strong>2. “将商品列表list改成一个二维数组来实现商品的分类，比如可分为”电子产品”，”生活用品”和”果蔬”，同类商品聚合在一起，你可能用到两次v-for。</strong></p><p>做出来的效果是这样的：</p><p><img src="https://fengzehe.github.io/blog/2020/07/13/record04/image.png" alt></p><p><strong>|思路：</strong></p><p>  选中商品功能，商品需要添加一个check属性。<strong>通过查询商品的check属性判断是否被选中。</strong></p><p>  总价变为计算选中商品的总价，因此我们可以在 computed计算总价totalPrice加一步验证。商品属性check = true才计算总价。</p><p>  在全选的时候把商品的check属性都遍历一遍  –&gt; <strong>把商品的check属性都设置为true，并把全选属性 isCheckedAll设置为true表示已经全选</strong>。</p><p>  当单件商品取消选中的时候要把i<strong>sCheckedAll设置为fasle，表示已经取消全选。</strong></p><p><strong>|步骤：</strong></p><ol><li><p>收到的数据是一个二维数组，分别显示商品类别以及商品内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">list: [</span><br><span class="line">        &#123;</span><br><span class="line">                title_name: <span class="string">'电子产品'</span>,</span><br><span class="line">                content: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        id: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'iPad Pro'</span>, <span class="attr">price</span>: <span class="number">5799</span>, <span class="attr">count</span>: <span class="number">1</span>, <span class="attr">check</span>: <span class="literal">false</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        id: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'iPhone XS '</span>, <span class="attr">price</span>: <span class="number">5089</span>, <span class="attr">count</span>: <span class="number">1</span>, <span class="attr">check</span>: <span class="literal">false</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        id: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">'Macbook Pro'</span>, <span class="attr">price</span>: <span class="number">13199</span>, <span class="attr">count</span>: <span class="number">1</span>, <span class="attr">check</span>: <span class="literal">false</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure></li><li><p>购物车页面显示商品类别，名称数量以及操作。底部显示总价以及结账。</p></li><li><p>通过计算属性来显示总价。循环二维数组两次，根据是否选中情况计算总价</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">       totalPrice: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.list.length; i++) &#123;</span><br><span class="line">               <span class="keyword">var</span> item = <span class="keyword">this</span>.list[i];</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; item.content.length; j++) &#123;</span><br><span class="line">                   <span class="keyword">var</span> items = item.content[j];</span><br><span class="line">                   <span class="keyword">if</span> (items.check == <span class="literal">true</span>) &#123;</span><br><span class="line">                       total += items.price * items.count;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">this</span>.total = total</span><br><span class="line">           <span class="keyword">return</span> total;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>单选和全选。实现的原理与全选类似，在选中按钮中绑定checked属性，绑定check属性确定绑定状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">check: <span class="function"><span class="keyword">function</span> (<span class="params">index1, index2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.list[index1].content[index2].check) &#123;</span><br><span class="line">                <span class="keyword">this</span>.list[index1].content[index2].check = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">this</span>.isCheckedAll = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.list[index1].content[index2].check = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">checkAll: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isCheckedAll == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.list.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> item = <span class="keyword">this</span>.list[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; item.content.length; j++) &#123;</span><br><span class="line">                        <span class="keyword">var</span> items = item.content[j];</span><br><span class="line">                        items.check = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.isCheckedAll = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.list.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> item = <span class="keyword">this</span>.list[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; item.content.length; j++) &#123;</span><br><span class="line">                        <span class="keyword">var</span> items = item.content[j];</span><br><span class="line">                        items.check = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.isCheckedAll = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>   所以大致就是这样实现的啦。我把题目的代码放在这里：</p><p>   <a href="https://github.com/FengZeHe/vue.jsPracticalsubject/tree/master/shoppingCar/shop_demo" target="_blank" rel="noopener">https://github.com/FengZeHe/vue.jsPracticalsubject/tree/master/shoppingCar/shop_demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 在看vue.js实战的时候笔者留下了一道题:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  &lt;strong&gt;1. 在当前示例基础上扩展商品列表，新增一项是否选中该商品的功能，总价变为只计算选中商品的总价，同时提供一个全选的按钮。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="rookie growth record" scheme="https://fengzehe.github.io/blog/categories/rookie-growth-record/"/>
    
    
      <category term="-- 记录" scheme="https://fengzehe.github.io/blog/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>rem移动端适配</title>
    <link href="https://fengzehe.github.io/blog/2020/07/05/mobile-terminal-rem/"/>
    <id>https://fengzehe.github.io/blog/2020/07/05/mobile-terminal-rem/</id>
    <published>2020-07-05T04:08:58.000Z</published>
    <updated>2020-07-05T07:27:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言：什么是移动端适配？"><a href="#前言：什么是移动端适配？" class="headerlink" title="|前言：什么是移动端适配？"></a>|前言：什么是移动端适配？</h4><p>  web移动端网页跟PC端显示大小与内容不一样，因此需要适配。</p><p>  而且手机设备之间屏幕尺寸不一，需要适配不同屏幕宽度的移动设备。</p><a id="more"></a><h4 id="常见的适配方法"><a href="#常见的适配方法" class="headerlink" title="|常见的适配方法"></a><strong>|常见的适配方法</strong></h4><ol><li>viewport</li><li>rem</li><li>flex</li><li>vm/vh</li></ol><h4 id="物理像素是什么"><a href="#物理像素是什么" class="headerlink" title="|物理像素是什么"></a><strong>|物理像素是什么</strong></h4><p>  显示屏的最佳分辨率，即屏幕实际存在的像素行数乘以列数的数学表达方式，是显示屏固有的参数，不能调节，其含义是指显示屏最高可显示的像素数。物理分辨率也叫标准分辨率，是指LED显示屏显示的图像原始分辨率，也叫真实分辨率。和物理分辨率对应的是压缩分辨率，决定图像清晰程度的是物理分辨率，决定显示屏的适用范围的是压缩分辨率。物理分辨率即LED液晶板的实际分辨率，在LED液晶板上通过网格来划分液晶体，一个液晶体为一个像素点。物理分辨率越高，则可接收分辨率的范围越大，则显示屏的适应范围越广。</p><p>  这里就肯定要提到Retina屏，2560X1600个像素每四个一组，输出原来屏幕的一个像素显示的大小区域内的图像。用户看到的图片与文字大小与1280x800分辨率的显示器相同，但精细度是原来的4倍。所以说<strong>Retina显示目的是为了解决画面精细度的问题而不是增加显示内容。</strong></p><p><img src="https://fengzehe.github.io/blog/2020/07/05/mobile-terminal-rem/1.png" alt></p><p><img src="https://fengzehe.github.io/blog/2020/07/05/mobile-terminal-rem/2.png" alt></p><p>​    上图是Retina屏，下图是旧显示器。上图是我们可以发现像素边缘下图更加平滑，是使用更多的像素点来表示图形的缘故。</p><h4 id="rem移动端适配"><a href="#rem移动端适配" class="headerlink" title="|rem移动端适配"></a><strong>|rem移动端适配</strong></h4><ol><li><p>定义 ：rem是一个css单位，这个单位比em多一个字母所以说多少有点类似。但不同的是<strong>em根据父元素显示大小，rem是相对于根标签对于px的定义来显示大小。</strong>例如说font-size = 16px表示 1rem = 16px;<strong>在移动端适配的时候设置rem可以让元素等比例放大或缩小以达到在不同设备显示一致的效果</strong>。</p></li><li><p>根据设备宽度作为基准 ，设置其根标签大小。我们可以通过函数来设置根标签的rem大小，并且在每次设备窗口宽度改变的时候重新计算根标签的fontsize。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> e = <span class="built_in">document</span>.documentElement.clintWidth, </span><br><span class="line">        t = <span class="built_in">document</span>.querySelector(<span class="string">'html'</span>),</span><br><span class="line">        f = ( e &gt; <span class="number">750</span> ? <span class="number">750</span> : e) /  ??? ;<span class="comment">//根据实际情况设置</span></span><br><span class="line">        t.style.fontSize = f + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e(), <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>,e);</span><br><span class="line">   <span class="comment">// 当调整浏览器窗口的大小时，发生 resize 事件并重新计算参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言：什么是移动端适配？&quot;&gt;&lt;a href=&quot;#前言：什么是移动端适配？&quot; class=&quot;headerlink&quot; title=&quot;|前言：什么是移动端适配？&quot;&gt;&lt;/a&gt;|前言：什么是移动端适配？&lt;/h4&gt;&lt;p&gt;  web移动端网页跟PC端显示大小与内容不一样，因此需要适配。&lt;/p&gt;
&lt;p&gt;  而且手机设备之间屏幕尺寸不一，需要适配不同屏幕宽度的移动设备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="-- record" scheme="https://fengzehe.github.io/blog/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟成长记 03 减少了一点代码冗余</title>
    <link href="https://fengzehe.github.io/blog/2020/07/01/record03/"/>
    <id>https://fengzehe.github.io/blog/2020/07/01/record03/</id>
    <published>2020-07-01T02:26:59.000Z</published>
    <updated>2020-07-30T06:39:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="减少代码冗余"><a href="#减少代码冗余" class="headerlink" title="减少代码冗余"></a>减少代码冗余</h4><blockquote><p>前言    在写一个项目的时候发现一个页面有许多弹窗触发，一开始写的时候通过ID名选中元素并设置显示或不显示。后来发现一个弹窗还好，当出现若干弹窗的时候代码重复度非常高，非常冗余。</p></blockquote><a id="more"></a><p><img src="https://fengzehe.github.io/blog/2020/07/01/record03/before.png" alt></p><p>​    因为每个弹窗固定的位置都有一个关闭按钮，按钮的位置是每个父级div下的一个元素节点。所以我想在点击事件后传入dom元素的父节点的ID，以此来绑定父级ID。因此用show()函数设置元素显示，通过hide()函数设置函数隐藏。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"please_login"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"btn_close "</span> <span class="attr">onclick</span>=<span class="string">"hide(this.parentNode.id)"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"login"</span> <span class="attr">onclick</span>=<span class="string">"login()"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nodeId = <span class="built_in">document</span>.getElementById(node);</span><br><span class="line">    nodeId.style.display = <span class="string">'block'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hide</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nodeId = <span class="built_in">document</span>.getElementById(node);</span><br><span class="line">    nodeId.style.display = <span class="string">'none'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成后减少了40行左右的代码，看起来更加清爽了。</p><p><img src="https://fengzehe.github.io/blog/2020/07/01/record03/1.png" alt></p><p><img src="https://fengzehe.github.io/blog/2020/07/01/record03/3.png" alt></p><p>但我过了一天发现其实可以把两个函数写成一个啊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function ShowHide(state)&#123;</span><br><span class="line">var b &#x3D; document.getElementById(state);</span><br><span class="line">if(b.style.display !&#x3D; &#39;none&#39;)&#123;</span><br><span class="line">b.style.display &#x3D; &#39;none&#39;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">b.style.display &#x3D; &#39;block&#39;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;减少代码冗余&quot;&gt;&lt;a href=&quot;#减少代码冗余&quot; class=&quot;headerlink&quot; title=&quot;减少代码冗余&quot;&gt;&lt;/a&gt;减少代码冗余&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;前言    在写一个项目的时候发现一个页面有许多弹窗触发，一开始写的时候通过ID名选中元素并设置显示或不显示。后来发现一个弹窗还好，当出现若干弹窗的时候代码重复度非常高，非常冗余。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="rookie growth record" scheme="https://fengzehe.github.io/blog/categories/rookie-growth-record/"/>
    
    
      <category term="-- 记录" scheme="https://fengzehe.github.io/blog/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟成长记 02 手动封装一个ajax</title>
    <link href="https://fengzehe.github.io/blog/2020/06/30/record02/"/>
    <id>https://fengzehe.github.io/blog/2020/06/30/record02/</id>
    <published>2020-06-30T13:20:32.000Z</published>
    <updated>2020-07-30T06:39:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现原生JS封装一个AJAS"><a href="#实现原生JS封装一个AJAS" class="headerlink" title="实现原生JS封装一个AJAS"></a>实现原生JS封装一个AJAS</h3><blockquote><p>前言：我们的使用ajax实现异步请求数据的时候，通常都是使用jQuery封装好的方法。</p></blockquote><a id="more"></a><h3 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX?"></a>什么是AJAX?</h3><p>​    A J A X = asynchronous javascript and xml</p><p>​    ajax可以将数据作为纯文本或者json文本传输。ajax允许通过与场景后面web服务器交换数据来异步更新网页，既不需要重新加载整个页面。</p><h3 id="JQuery方法"><a href="#JQuery方法" class="headerlink" title="JQuery方法"></a>JQuery方法</h3><p>简单快捷，是需要几步代码搞定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"data.json"</span>,</span><br><span class="line">    type: <span class="string">"GET"</span>,</span><br><span class="line">    dataType: <span class="string">"json"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        mobile: <span class="number">13500010101</span></span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        temp = data;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'error'</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但我们不用JQuery的时候要怎么使用原生js来封装呢？</p><h3 id="原生JS方法"><a href="#原生JS方法" class="headerlink" title="原生JS方法"></a>原生JS方法</h3><ol><li><p>首先创建XMLHttpRequest对象</p><p>现代浏览器都有内建的XMLHttpRequest对象，老旧浏览器（IE5 ，IE6）需要使用ActiveXObject对象</p></li><li><p>GET请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhttp.open(<span class="string">"GET"</span>, <span class="string">"data.json"</span>, <span class="literal">true</span>);</span><br><span class="line">xhttp.send();</span><br></pre></td></tr></table></figure></li><li><p>POST请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhttp.open(<span class="string">"POST"</span>, <span class="string">"ajax_test.asp"</span>, <span class="literal">true</span>);</span><br><span class="line">xhttp.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">xhttp.send(<span class="string">"fname=Bill&amp;lname=Gates"</span>);</span><br></pre></td></tr></table></figure></li><li><p>最终实现</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> xhttp;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">xhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> xhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHttp"</span>)<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">xhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.readyState == <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">data =  <span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhttp.open(<span class="string">"GET"</span>, <span class="string">"data.json"</span>, <span class="literal">true</span>);</span><br><span class="line">xhttp.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    5. 这里补充一下，response里面存的是JSON类型的字符换，使用JSON.parse()方法可以使JSON字符串转换为js对象，这样调用起来就很方便了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现原生JS封装一个AJAS&quot;&gt;&lt;a href=&quot;#实现原生JS封装一个AJAS&quot; class=&quot;headerlink&quot; title=&quot;实现原生JS封装一个AJAS&quot;&gt;&lt;/a&gt;实现原生JS封装一个AJAS&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;前言：我们的使用ajax实现异步请求数据的时候，通常都是使用jQuery封装好的方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="rookie growth record" scheme="https://fengzehe.github.io/blog/categories/rookie-growth-record/"/>
    
    
      <category term="--  记录" scheme="https://fengzehe.github.io/blog/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟成长记 01 rem移动端适配</title>
    <link href="https://fengzehe.github.io/blog/2020/06/29/record01/"/>
    <id>https://fengzehe.github.io/blog/2020/06/29/record01/</id>
    <published>2020-06-29T14:34:49.000Z</published>
    <updated>2020-07-30T06:40:13.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="移动端适配问题"><a href="#移动端适配问题" class="headerlink" title="移动端适配问题"></a>移动端适配问题</h4><blockquote><p> 前言 当我们拿到750px像素的原型，移动端适配的时候将原型转换成html文件需要像素减半。</p></blockquote><a id="more"></a><p>​    如我拿到一张750px 1206px的psd原型，放在移动端要设置成375px和603px。因为之前我在学习的时候并没有ui设计图让我切，所以在公司练手啥也不会。</p><p>​    另外是要导出一个组合图形的时候，先转换成智能对象，清除栅格化，导出为PNG就可以得到背景是透明度的图形了。</p><p><img src="https://fengzehe.github.io/blog/2020/06/29/record01/change.png" alt></p><p><img src="https://fengzehe.github.io/blog/2020/06/29/record01/output.png" alt></p><p>​    话虽如此，但我在开发过程中发现，虽然图片背景是透明的，但还是看到了一些端倪。</p><p>​    虽然导出了背景是透明的PNG图片，但我们还是能看到按钮的背景图片边角并不是透明的。</p><p>一开始我以为是导出图片的问题.</p><p><img src="https://fengzehe.github.io/blog/2020/06/29/record01/back.png" alt></p><p>​    其实并不是导出图片的问题。因为我使用了一个button包裹里面的a标签，在设置button背景的时候还受到button自身背景的影响，于是在button处设置 background-color : transparent就可以了。对比如下图。</p><p><img src="https://fengzehe.github.io/blog/2020/06/29/record01/after.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;移动端适配问题&quot;&gt;&lt;a href=&quot;#移动端适配问题&quot; class=&quot;headerlink&quot; title=&quot;移动端适配问题&quot;&gt;&lt;/a&gt;移动端适配问题&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt; 前言 当我们拿到750px像素的原型，移动端适配的时候将原型转换成html文件需要像素减半。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="rookie growth record" scheme="https://fengzehe.github.io/blog/categories/rookie-growth-record/"/>
    
    
      <category term="--  记录" scheme="https://fengzehe.github.io/blog/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6异步的解决方案</title>
    <link href="https://fengzehe.github.io/blog/2020/02/27/es6-async/"/>
    <id>https://fengzehe.github.io/blog/2020/02/27/es6-async/</id>
    <published>2020-02-26T23:50:33.000Z</published>
    <updated>2020-06-18T12:43:47.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>js经常会遇到一些异步任务（需要经过一段时间或当某个时机到达后才能得到的任务）<br>例如说：</p><ol><li>使用ajax请求服务器，当服务器完成响应后拿到响应结果</li><li>监听按钮是否被点击，当按钮点击后拿到某个文本框的值</li><li>使用setTimeout 等待一段时间，当时间到达后做某些事情</li></ol><a id="more"></a><p>面对这样的场景，JS没有一种标准的模式来进行处理，我们处理这些问题的方式是杂乱的，这就导致了不同的人书写的异步任务代码使用方式不一致。例如说实用第三方库，不知道要传进去多少个参数，或者各种参数放第几位。</p><h3 id="ES6异步处理模型"><a href="#ES6异步处理模型" class="headerlink" title="ES6异步处理模型"></a>ES6异步处理模型</h3><h4 id="ES6将异步场景分为两个阶段和三种状态"><a href="#ES6将异步场景分为两个阶段和三种状态" class="headerlink" title="ES6将异步场景分为两个阶段和三种状态"></a>ES6将异步场景分为两个阶段和三种状态</h4><ol><li>两个场景： unsettled (未决)  settled (已决)</li><li>三种状态： pending (挂起) resolved(完成) rejected (失败)<br><img src="https://fengzehe.github.io/blog/2020/02/27/es6-async/scene.png" alt></li></ol><h5 id="当任务处于未决时"><a href="#当任务处于未决时" class="headerlink" title="当任务处于未决时"></a>当任务处于未决时</h5><pre><code>状态一定是pending的，表示任务从开始至拿到结果之间的过程。例如说网络完成了各种配置，发送了请求但还没有收到回复</code></pre><h5 id="当任务处于已决时"><a href="#当任务处于已决时" class="headerlink" title="当任务处于已决时"></a>当任务处于已决时</h5><pre><code>它只能是resolved和reject两种状态之间的一种。例如说拿到或者没拿到数据--&gt; resolved状态 。网络不通畅 --&gt; rejected状态</code></pre><p><strong>我们把从未决推向已决的resolved状态的过程，叫做resolve，从未决推向已决的rejected状态的过程，叫做reject</strong>如下图所示</p><h5 id="任务已决后-有了结果"><a href="#任务已决后-有了结果" class="headerlink" title="任务已决后(有了结果)"></a>任务已决后(有了结果)</h5><pre><code>进一步做后续处理，如果任务成功了（resolved）,有后续处理，如果任务失败了（rejected）,仍可能做后续处理</code></pre><p><strong>我们把针对resolved的后续处理称之为thenable，针对rejected的后续处理，称之为catchable</strong><br><img src="https://fengzehe.github.io/blog/2020/02/27/es6-async/catchable.png" alt></p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol><li>任务一旦进入已决后，所有企图改变代码任务状态的代码都将失效</li><li>以下代码可以让任务达到rejected 状态<ol><li>调用reject</li><li>代码执行报错</li><li>抛出错误</li></ol></li><li>后续处理函数一定是异步函数，并且放在微队列中</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;js经常会遇到一些异步任务（需要经过一段时间或当某个时机到达后才能得到的任务）&lt;br&gt;例如说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用ajax请求服务器，当服务器完成响应后拿到响应结果&lt;/li&gt;
&lt;li&gt;监听按钮是否被点击，当按钮点击后拿到某个文本框的值&lt;/li&gt;
&lt;li&gt;使用setTimeout 等待一段时间，当时间到达后做某些事情&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>ES6模块化</title>
    <link href="https://fengzehe.github.io/blog/2020/02/23/ES6-modular/"/>
    <id>https://fengzehe.github.io/blog/2020/02/23/ES6-modular/</id>
    <published>2020-02-23T13:20:35.000Z</published>
    <updated>2020-06-18T10:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6的模块化"><a href="#ES6的模块化" class="headerlink" title="ES6的模块化"></a>ES6的模块化</h3><h4 id="模块（module）-一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件"><a href="#模块（module）-一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件" class="headerlink" title="模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件"></a>模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件</h4><a id="more"></a><h4 id="模块化背景"><a href="#模块化背景" class="headerlink" title="模块化背景"></a>模块化背景</h4><p>过去js很难编写大型应用，因为有以下两个问题：</p><ol><li>全局变量污染</li><li>难以管理的依赖关系<br>这些问题，都导致了JS无法进行精细的模块划分，因为精细的模块划分会导致更多的全局污染更加负载的依赖关系，因为功能精细的划分有利于代码重用</li></ol><h4 id="前端的模块化有两个标准："><a href="#前端的模块化有两个标准：" class="headerlink" title="前端的模块化有两个标准："></a>前端的模块化有两个标准：</h4><ol><li>Commonjs</li><li>ES6 Module<br>注意：上面提到的两个均是模块化标准，具体的实现需要依托于JS的</li></ol><h4 id="ConmomJS"><a href="#ConmomJS" class="headerlink" title="ConmomJS"></a>ConmomJS</h4><p>简介：目前，只有node环境才支持CommonJs模块化标准，所以需要先安装node才能使用CommonJS<br>在CommonJS中，浏览器运行的是html页面，并加载页面通过script元素引入js，node.js直接运行某个js文件，该文件被称之为入口文件。node.js遵循ECMAScript标准，但脱离了浏览器环境：<br>你可以在node.js中使用ECMAScript标准的任何语法或api，例如循环，判断，数组，对象等等<br>但不能在node.js中使用浏览器的web api,例如说dom对象，window对象，document对象</p><h5 id="CommonJS标准和使用"><a href="#CommonJS标准和使用" class="headerlink" title="CommonJS标准和使用"></a>CommonJS标准和使用</h5><p>node中的所有代码均在CommonJS下运行，具体规范如下 ：</p><ol><li><p>一个js文件既为一个模块<br>如果一个模块需要暴露依稀额数据或功能给其他模块使用，需要使用代码<code>module.exports = xxx</code> ,该过程称之为模块的导出</p></li><li><p>如果一个模块需要使用另一个模块导出的内容，需要使用代码require(‘模块路径’)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">路径必须以.&#x2F;或..&#x2F;开头</span><br><span class="line">如果模块文件后缀名为  .js 可以省略后缀名</span><br></pre></td></tr></table></figure><p>require 函数中返回的是模块导出的内容,且模块中所有的全局代码产生的变量、函数均不会对全局造成任何污染，仅在模块内使用</p></li><li><p>模块具有缓存，第一次导入模块时会缓存模块的导出，之后再导入同一个模块 会使用之前缓存的结果</p></li></ol><p>有了CommomJS模块化，代码就会形成以下结构：<br><img src="https://fengzehe.github.io/blog/2020/02/23/ES6-modular/image.png" alt></p><p>原理：node实际上是将模块文件中的代码防止到一个函数环境中执行，可以想象该函数是下面的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function(module)&#123;</span><br><span class="line">    module.exports &#x3D; &#123;&#125;;</span><br><span class="line">    var exports &#x3D; module.exports;</span><br><span class="line">    return module.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h3><blockquote><p>由于种种原因，CommonJS难以在浏览器中实现，因为一直在浏览器端没有合适的模块化标准，直到es6出现。<br>ES6规范了浏览器的模块化标准，一经发布，各大浏览器厂商纷纷在自己的浏览器中实现该规范。</p></blockquote><p>模块的引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在浏览器使用以下方式引入ES6模块文件</span><br><span class="line">&lt;script src &#x3D; &quot;入口文件&quot; type &#x3D; &quot;module&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="标准和使用"><a href="#标准和使用" class="headerlink" title="标准和使用"></a>标准和使用</h4><p>模块的导出分为两种，基本导出和默认导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可以将整个模块的导出想象成一个对象，基本导出导出的是该对象的某个属性，默认导出导出的是该对象的特殊属性default</span><br><span class="line">&#x2F;&#x2F;导出结果：想象成一个对象</span><br><span class="line">&#123;</span><br><span class="line">    a: xxx, &#x2F;&#x2F;基本导出</span><br><span class="line">    b: xxx, &#x2F;&#x2F;基本导出</span><br><span class="line">    default: xxx, &#x2F;&#x2F;默认导出</span><br><span class="line">    c: xxx &#x2F;&#x2F;基本导出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ES6的导出方式："><a href="#ES6的导出方式：" class="headerlink" title="ES6的导出方式："></a>ES6的导出方式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export var a &#x3D; 1 &#x2F;&#x2F;基本导出 a &#x3D; 1</span><br><span class="line">export var b &#x3D; function()&#123;&#125; &#x2F;&#x2F;基本导出 b &#x3D; function()&#123;&#125;</span><br><span class="line">export function method()&#123;&#125;  &#x2F;&#x2F;基本导出 method &#x3D; function()&#123;&#125;</span><br><span class="line">var c &#x3D; 3;</span><br><span class="line">export &#123;c&#125; &#x2F;&#x2F;基本导出 c &#x3D; 3</span><br><span class="line">export &#123; c as temp &#125; &#x2F;&#x2F;基本导出 temp &#x3D; 3</span><br><span class="line"></span><br><span class="line">export default 3 &#x2F;&#x2F;默认导出 default &#x3D; 3</span><br><span class="line">export default function()&#123;&#125; &#x2F;&#x2F;默认导出 default &#x3D; function()&#123;&#125;</span><br><span class="line">export &#123; c as default &#125; &#x2F;&#x2F;默认导出 default &#x3D; 3</span><br><span class="line">export &#123;a, b, c as default&#125; &#x2F;&#x2F;基本导出 a&#x3D;1, b&#x3D;function()&#123;&#125;, 默认导出 default &#x3D; 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">绝大部分时间写代码使用的导出方式是 export default()&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="ES6模块的导入："><a href="#ES6模块的导入：" class="headerlink" title="ES6模块的导入："></a>ES6模块的导入：</h4><p>使用以下的代码导入模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;a,b&#125; from &quot;模块路径&quot;   &#x2F;&#x2F;导入属性 a、b，放到变量a、b中</span><br><span class="line">import &#123;a as temp1, b as temp2&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性a、b，放到变量temp1、temp2 中</span><br><span class="line">import &#123;default as a&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default，放入变量a中，default是关键字，不能作为变量名，必须定义别名</span><br><span class="line">import &#123;default as a, b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default、b，放入变量a、b中</span><br><span class="line">import c from &quot;模块路径&quot;  &#x2F;&#x2F;相当于 import &#123;default as c&#125; from &quot;模块路径&quot;</span><br><span class="line">import c, &#123;a,b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;相当于 import &#123;default as c, a, b&#125; from &quot;模块路径&quot;</span><br><span class="line">import * as obj from &quot;模块路径&quot; &#x2F;&#x2F;将模块对象放入到变量obj中</span><br><span class="line">import &quot;模块路径&quot; &#x2F;&#x2F;不导入任何内容，仅执行一次模块</span><br></pre></td></tr></table></figure><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>导入模块时，注意以下细节</p><ol><li>ES6 module 采用依赖预加载模式，所有模块导入代码均会提升到代码顶部</li><li>不能将导入代码放置到判断、循环中</li><li>导入的内容放置到常量中，不可更改</li><li>ES6 module 使用了缓存，保证每个模块仅加载一次</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ES6的模块化&quot;&gt;&lt;a href=&quot;#ES6的模块化&quot; class=&quot;headerlink&quot; title=&quot;ES6的模块化&quot;&gt;&lt;/a&gt;ES6的模块化&lt;/h3&gt;&lt;h4 id=&quot;模块（module）-一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件&quot;&gt;&lt;a href=&quot;#模块（module）-一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件&quot; class=&quot;headerlink&quot; title=&quot;模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件&quot;&gt;&lt;/a&gt;模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件&lt;/h4&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>当在浏览器输入一个地址发生了什么</title>
    <link href="https://fengzehe.github.io/blog/2020/02/15/when-Enter-an-address/"/>
    <id>https://fengzehe.github.io/blog/2020/02/15/when-Enter-an-address/</id>
    <published>2020-02-15T02:28:28.000Z</published>
    <updated>2020-06-18T10:14:03.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="过程是这样的："><a href="#过程是这样的：" class="headerlink" title="过程是这样的："></a>过程是这样的：</h4><ol><li><p>浏览器将url地址补充完整，如果没有写协议就自动添加上协议（http： / https：）</p><a id="more"></a></li><li><p>浏览器对url地址进行url编码，如果url地址中出现了非ASCII字符，浏览器则会对其进行编码</p><ol><li>例如说在浏览器中搜索”王思聪”，汉字会被编码成ASCII码</li></ol></li><li><p>浏览器构造一个没有消息体的GET请求，发送至服务器，等待服务器响应（此时浏览器标签应该有一个等等的图标–转圈）</p></li><li><p>服务器收到请求，将一个HTML页面代码组装到消息体中（不一定要html文件）响应给浏览器</p></li><li><p>浏览器拿到服务器的响应后，丢弃当前的页面，开始渲染消息体的HTML代码。浏览器之所以知道这是一个HTML代码，是因为服务器的响应头指定了消息类型为text/html</p></li><li><p>浏览器在渲染页面的过程中发现有嵌入的资源如CSS,JS图片等</p></li><li><p>浏览器使用不阻塞的渲染方式，重定向服务器发送该资源的请求，拿到响应结果后根据Content-Type做响应处理</p></li><li><p>当所有资源已经下载并处理好后，浏览器出发window.onload事件</p></li></ol><p>   这里说的Content-Tpye是在http协议消息头中表示具体请求中的媒体类型信息</p><p>   有一下几种类型：</p><p>   <img src="https://fengzehe.github.io/blog/2020/02/15/when-Enter-an-address/content-type.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;过程是这样的：&quot;&gt;&lt;a href=&quot;#过程是这样的：&quot; class=&quot;headerlink&quot; title=&quot;过程是这样的：&quot;&gt;&lt;/a&gt;过程是这样的：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;浏览器将url地址补充完整，如果没有写协议就自动添加上协议（http： / https：）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>实现一个简单的VUE</title>
    <link href="https://fengzehe.github.io/blog/2020/02/12/vue-demo-1/"/>
    <id>https://fengzehe.github.io/blog/2020/02/12/vue-demo-1/</id>
    <published>2020-02-12T00:33:19.000Z</published>
    <updated>2020-06-29T13:23:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实现的效果</p></blockquote><div style="position: relative; width: 100%; height: 100%; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=82283147&cid=140781854&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>​    实现一个简单的vue函数，包括双向数据绑定，数据的响应式</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>1. 首先想到要实现vue的数据绑定，根据vue的双向数据绑定，把{{xxx}} 与data{}里面的值进行绑定。将值绑定后，我们想到要将这些数据渲染出来，这里就需要知道页面的各个节点与各节点的子节点 2. 再到数据响应模块，使用object.defineProperty来实现数据的响应式，用get方法来读取属性的值，用set方法来写入属性的值，以此来实现数据绑定 3. 最后为Vue添加构造函数，例如说this.$el 来表示绑定的元素，$data来表示绑定的数据，$vnode代表虚拟节点</code></pre><h3 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h3><ol><li>编译模块</li><li>虚拟节点模块</li><li>渲染模块</li><li>数据响应模块</li><li>VUE构造函数模块</li></ol><h3 id="编译模块"><a href="#编译模块" class="headerlink" title="编译模块"></a>编译模块</h3><blockquote><p>提供一个compile函数，将一个模板文本(数据)和环境对象（DOM节点）编译成一个结果<br>思想：</p></blockquote><ol><li>使用正则表达式匹配到html代码中包含 括号 的字符串</li><li>拿到字符串之后把两边括号替换掉，把表达式分割成数组</li><li>这需要与envObj环境变量进行配合使用，绑定后变成一个数组</li></ol><p><img src="https://fengzehe.github.io/blog/2020/02/12/vue-demo-1/1.png" alt></p><blockquote><p>compile.js 代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过程： 先拿到&#123;&#123;xxx&#125;&#125;里面的字符串，然后再对字符串进行加工</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFragments</span>(<span class="params">template</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> matches = template.match(<span class="regexp">/&#123;&#123;[^&#125;]+&#125;&#125;/g</span>); <span class="comment">//万一有人的用户名叫12&#125;  所以这里要处理一下</span></span><br><span class="line">    <span class="keyword">return</span> matches || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">fragment, envObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> exp = fragment.replace(<span class="string">"&#123;&#123;"</span>, <span class="string">""</span>).replace(<span class="string">"&#125;&#125;"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">var</span> props = exp.split(<span class="string">"."</span>);<span class="comment">//将表达式分割为属性数组</span></span><br><span class="line">    <span class="keyword">var</span> obj = envObj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">        obj = obj[props[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template, envObj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 提取模板中的&#123;&#123;&#125;&#125;</span></span><br><span class="line">    <span class="keyword">var</span> flags = getFragments(template);</span><br><span class="line">    <span class="keyword">var</span> result = template;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; flags.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> flag = flags[i];</span><br><span class="line">        result = result.replace(flag, getValue(flag, envObj))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM:"></a>虚拟DOM:</h3><blockquote><p>提供一个函数createVNode,根据提供真实的DOM，构建一个虚拟DOM树<br>思想：</p></blockquote><ol><li>需要创建虚拟DOM 以便以后操作数据</li><li>需要判断真实节点是否为文本节点，如果是就要记录到虚拟节点</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">VNode</span>(<span class="params">realDom, template</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// node 构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.realDom = realDom;</span><br><span class="line">    <span class="keyword">this</span>.template = template;</span><br><span class="line">    <span class="keyword">this</span>.children = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createVNode</span>(<span class="params">realDom</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> root = <span class="keyword">new</span> VNode(realDom, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (realDom.nodeType === Node.TEXT_NODE) &#123;</span><br><span class="line">        root.template = realDom.nodeValue;</span><br><span class="line">        <span class="comment">// 判断真实节点是否为文本节点，如果是，就要记录到虚拟节点</span></span><br><span class="line">        <span class="comment">// 文本节点代表的数字是3</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i  = <span class="number">0</span>; i&lt; realDom.childNodes.length;i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> childNode = realDom.childNodes[i];</span><br><span class="line">            <span class="keyword">var</span> vNode = createVNode(childNode)</span><br><span class="line">            root.children.push(vNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染模块"><a href="#渲染模块" class="headerlink" title="渲染模块"></a>渲染模块</h3><blockquote><p>用于提取虚拟节点，将其模板编译结果设置到真实的dom中，对虚拟节点的子节点也做同样的操作<br><img src="https://fengzehe.github.io/blog/2020/02/12/vue-demo-1/vnode.png" alt></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> compile <span class="keyword">from</span> <span class="string">"./compile.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染一个虚拟节点（将文本的虚拟节点进行编译）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, envObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode.realDom.nodeType === Node.TEXT_NODE) &#123;</span><br><span class="line">        vnode.realDom.nodeValue = compile(vnode.template, envObj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vnode.children.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> childNode = vnode.children[i];</span><br><span class="line">            render(childNode, envObj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据响应模块"><a href="#数据响应模块" class="headerlink" title="数据响应模块"></a>数据响应模块</h3><blockquote><p>主要负责将原始对象的数据附加到代理对象上，代理对象能够监听到数据的更改，当数据发生改变时，执行某个回调函数(就可以实现数据响应)</p></blockquote><ol><li><p>使用Object.defineProperty来实现数据的响应式</p></li><li><p>这里有一个关键是当代理一个对象是，发现对象里面还有属性没法代理。这时候就要重新申请一个新的代理（如下图）</p></li></ol><p><img src="https://fengzehe.github.io/blog/2020/02/12/vue-demo-1/newTarget.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将原始对象的prop属性添加到代理对象中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyProp</span>(<span class="params">originalObj, targetObj, prop, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> originalObj[prop] === <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="comment">// 要代理的属性是一个对象,对象要单独处理</span></span><br><span class="line">        <span class="keyword">var</span> newTarget = &#123;&#125;;<span class="comment">//新的 要代理的对象</span></span><br><span class="line">        createResponsive(originalObj[prop], newTarget, callback);</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(targetObj,prop,&#123;</span><br><span class="line">            <span class="keyword">get</span>:function()&#123;</span><br><span class="line">                <span class="keyword">return</span> newTarget;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>:function(value)&#123;</span><br><span class="line">                originalObj[prop] = value;</span><br><span class="line">                newTarget = value;</span><br><span class="line">                callback &amp;&amp; callback(prop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(targetObj, prop, &#123;</span><br><span class="line">            <span class="keyword">get</span>: function () &#123;</span><br><span class="line">                <span class="keyword">return</span> originalObj[prop];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>: function (value) &#123;</span><br><span class="line">                originalObj[prop] = value;</span><br><span class="line">                callback &amp;&amp; callback(prop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将原始对象的属性，提取到代理对象中</span></span><br><span class="line"><span class="comment">// org是原始对象， target是代理对象 当代理对象被赋值的时候要调用回调函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createResponsive</span>(<span class="params">originalObj, targetObj, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> originalObj) &#123;</span><br><span class="line">        proxyProp(originalObj, targetObj, prop, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为vue写一个构造函数"><a href="#为vue写一个构造函数" class="headerlink" title="为vue写一个构造函数"></a>为vue写一个构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createVNode <span class="keyword">from</span> <span class="string">'./vnode.js'</span></span><br><span class="line"><span class="keyword">import</span> createResponsive <span class="keyword">from</span> <span class="string">'./dataResponsive.js'</span></span><br><span class="line"><span class="keyword">import</span> render <span class="keyword">from</span> <span class="string">'./render.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">vue</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$el = option &amp;&amp; option.el;</span><br><span class="line">    <span class="keyword">this</span>.$data = option &amp;&amp; option.data;</span><br><span class="line">    <span class="keyword">this</span>.$vnode = createVNode(<span class="built_in">document</span>.querySelector(<span class="keyword">this</span>.$el))</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    createResponsive(<span class="keyword">this</span>.$data, <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 重新渲染</span></span><br><span class="line">        that.render();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.render()<span class="comment">//初次渲染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vue.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    render(<span class="keyword">this</span>.$vnode, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在前端页面写一个简单的VUE结构"><a href="#在前端页面写一个简单的VUE结构" class="headerlink" title="在前端页面写一个简单的VUE结构"></a>在前端页面写一个简单的VUE结构</h3><blockquote><p>在前端页面写一个简单的VUE结构，测试一下是否正确</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"./vue/index.js"</span></span><br><span class="line">        <span class="built_in">window</span>.vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">"#app"</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                name:<span class="string">"FengZe"</span>,</span><br><span class="line">                age:<span class="number">16</span>,</span><br><span class="line">                addr:&#123;</span><br><span class="line">                    province:<span class="string">"广东"</span>,</span><br><span class="line">                    city:<span class="string">"佛山"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="大概就是这样实现的了"><a href="#大概就是这样实现的了" class="headerlink" title="大概就是这样实现的了."></a>大概就是这样实现的了.</h4><blockquote><p>源码地址：<a href="https://github.com/FengZeHe/vue_demo" target="_blank" rel="noopener">https://github.com/FengZeHe/vue_demo</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;实现的效果&lt;/p&gt;
&lt;/blockquote&gt;


&lt;div style=&quot;position: relative; width: 100%; height: 100%; padding-bottom: 75%;&quot;&gt;
    &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=82283147&amp;cid=140781854&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;
&lt;/div&gt;


&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;​    实现一个简单的vue函数，包括双向数据绑定，数据的响应式&lt;/p&gt;
    
    </summary>
    
    
      <category term="project" scheme="https://fengzehe.github.io/blog/categories/project/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="vue" scheme="https://fengzehe.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简单的ofo微信小程序</title>
    <link href="https://fengzehe.github.io/blog/2020/01/10/ofo_demo/"/>
    <id>https://fengzehe.github.io/blog/2020/01/10/ofo_demo/</id>
    <published>2020-01-10T02:03:40.000Z</published>
    <updated>2020-06-29T13:23:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实现的效果</p></blockquote><div style="position: relative; width: 100%; height: 100%; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=82787506&cid=141641375&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><a id="more"></a><p>实现功能简介：</p><ol><li>扫码骑车记时功能</li><li>用户登录及充值功能</li><li>用户报障功能</li></ol><p>思路：</p><ol><li>要实现这些功能，首先要设置一个首页，首页里面包含所有功能按钮，包括回到当前定位，立即用车，单车报障及个人用户按钮</li><li>回到当前定位功能直接调用this.movetoCenter()函数</li><li>立即用车功能;调用扫码接口获取开锁密码与当前单车编号，完事进入开锁界面并在90秒后跳转到计费页面并开始记录用户当前开始用车时间。<ol><li>不过这里需要注意的是在计费中页面，用户仍然可以切换到首页地图，再次点击扫码用车的时候直接进入计费页面。<img src="https://fengzehe.github.io/blog/2020/01/10/ofo_demo/2020/01/10/ofo_demo/ride_logic.png" class title="是这个意思"></li><li>因为切回首页是把计费页面放在后台,所以使用navtgateTo()方法，而不是使用redirectTo()方法。</li></ol></li><li>单车报障功能<ol><li>这里要说一嘴的是故障类型跟上传照片是必填，要验证内容是否为空。这里我只是判断了input框中的长度是否大于0；</li><li>上传照片这里调用了微信的chooseImage()接口；我使用了一个数组存储上传的照片，所以在删除的时候直接在数组干掉就好了。</li></ol></li><li>用户登录及充值功能<ol><li>用户登录这里要注意下微信新版本是要授权，在按钮处设置open-type 为 getUserInfo才能使用。</li><li>另外我把用户数据存进了storage,这样处理下一次就可以自动登录了。同时在登出的时候也会删除storage.</li></ol></li></ol><blockquote><p>关于后台：<br>    因为时间<del>（技术）</del>问题暂时没有做出来，后续版本就有了嘿。因此这次我在modeHttp在线mock了后台数据。</p></blockquote><blockquote><p>源码地址：<a href="https://github.com/FengZeHe/ofo_demo" target="_blank" rel="noopener">https://github.com/FengZeHe/ofo_demo</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;实现的效果&lt;/p&gt;
&lt;/blockquote&gt;


&lt;div style=&quot;position: relative; width: 100%; height: 100%; padding-bottom: 75%;&quot;&gt;
    &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=82787506&amp;cid=141641375&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="project" scheme="https://fengzehe.github.io/blog/categories/project/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="微信小程序" scheme="https://fengzehe.github.io/blog/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/12/14/spring/"/>
    <id>https://fengzehe.github.io/blog/2019/12/14/spring/</id>
    <published>2019-12-14T12:40:13.000Z</published>
    <updated>2020-06-18T10:16:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring学习笔记"><a href="#Spring学习笔记" class="headerlink" title="Spring学习笔记"></a>Spring学习笔记</h4><h4 id="框架的概念："><a href="#框架的概念：" class="headerlink" title="框架的概念："></a>框架的概念：</h4><ol><li>高度抽取可重用代码的设计</li><li>高度的通用性<a id="more"></a><h4 id="Spring的特点"><a href="#Spring的特点" class="headerlink" title="Spring的特点:"></a>Spring的特点:</h4>优良特性：</li><li>非侵入式</li><li>依赖注入</li><li>面向切面编程</li><li>容器</li><li>组件化</li><li>一站式</li></ol><blockquote><p>Core Container（IOC）核心容器包含Bean Core Context expression 这几个容器</p></blockquote><h4 id="Web：Sping开发Web应用"><a href="#Web：Sping开发Web应用" class="headerlink" title="Web：Sping开发Web应用"></a>Web：Sping开发Web应用</h4><ol><li>WebSocket</li><li>Servlet</li><li>web protlet<blockquote><p>(建议用哪个模块就导哪个包)</p></blockquote></li></ol><h4 id="IOC："><a href="#IOC：" class="headerlink" title="IOC："></a>IOC：</h4><blockquote><p>控制反转;被动式的资源获取方式：资源的获取不是自己创建，而是交给容器创建和设置</p></blockquote><h4 id="DI：（Injevtion-依赖注入）"><a href="#DI：（Injevtion-依赖注入）" class="headerlink" title="DI：（Injevtion  依赖注入）"></a>DI：（Injevtion  依赖注入）</h4><ol><li>容器能知道哪个组件（类运行的时候时候需要另外一个类）</li><li>只要使用管理的组件，都能使用组件提供的强大功能。现在所有的对象交给容器创建，容器中的组件注册。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id &#x3D; &quot;person03&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;lastName&quot; value&#x3D;&quot;小明&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;email&quot; value&#x3D;&quot;skjdhfkjsdfhkd@126.com&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;gender&quot; value&#x3D;&quot;男&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"> &#x2F;&#x2F;有参构造器 &lt;constructor-arg&gt;就代表一个属性</span><br><span class="line"></span><br><span class="line"> &lt;bean id&#x3D;&quot;person01&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;he&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;age&quot; value &#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;hzf@666.com&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;man&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">  &lt;&#x2F;bean&gt;</span><br><span class="line">  &#x2F;&#x2F;通过无参构造器</span><br><span class="line">  &#x2F;&#x2F;如果省略name参数 就要严格按照构造器参数的位置</span><br><span class="line">  &#x2F;&#x2F;在重载的情况下 type可以指定参数的类型</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;名称空间：在xml中名称空间是用来防止标签重复的</span><br><span class="line">  &lt;book&gt;</span><br><span class="line">      &lt;b:name&gt;西游记&lt;&#x2F;name&gt;</span><br><span class="line">      &lt;author&gt;</span><br><span class="line">         &lt;a:name&gt;吴承恩&lt;&#x2F;name&gt;</span><br><span class="line">      &lt;&#x2F;author&gt;</span><br><span class="line">  &lt;&#x2F;book&gt;</span><br><span class="line">  通过标签的前缀，就可以知道name是指哪个name</span><br><span class="line"></span><br><span class="line">  xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;property name&#x3D;&quot;lastName&quot;&gt;</span><br><span class="line">      &lt;&#x2F;null&gt; &#x2F;&#x2F;进行复杂的赋值，在property标签里面</span><br><span class="line">   &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;如果把多个属性赋值给一个对象呢</span><br><span class="line"></span><br><span class="line">  &lt;bean  id &#x3D;&quot;car01&quot; class&#x3D;&quot;com.bean.Car&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;carName&quot; value&#x3D;&quot;宝马&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;color&quot; value&#x3D;&quot;pink&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;price&quot; value&#x3D;&quot;30000&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property name&#x3D;&quot;car&quot; ref&#x3D;&quot;car01&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">  &#x2F;&#x2F;在person01的容器中加入这段代码就ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;在bean里面写property写是引用外部bean， 在property里面写bean是引用内部bean</span><br></pre></td></tr></table></figure><h4 id="Spring在为各种属性赋值："><a href="#Spring在为各种属性赋值：" class="headerlink" title="Spring在为各种属性赋值："></a>Spring在为各种属性赋值：</h4><ol><li>在bean使用ref写是引用外部bean， 在property里面写bean是引用内部bean</li><li>在对list属性进行赋值，写在property里面，同时也可以使用ref引用外部赋值</li><li>在对map属性进行赋值，在property键值对里面<code>&lt;entry&gt;</code>标签，在标签内使用key value进行键值对的赋值。</li><li>util名称空间创建集合类型的bean 方便别人引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;util:map id&#x3D;&quot;myMap&quot;&gt;&#x2F;&#x2F;一定要有Id</span><br><span class="line">    &#x2F;&#x2F;里面写的直接是元素</span><br><span class="line">&lt;&#x2F;util:map&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>级联属性赋值：就是属性的属性</p></blockquote><blockquote><p>通过继承实现bean配置信息的重用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;parent05&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;男&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;akshdajsk&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;person06&quot; class&#x3D;&quot;com.bean.Person&quot; parent&#x3D;&quot;parent05&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;fengZe&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;abstract&#x3D;&quot;true&quot;,这个Bean的配置是一个抽象的，不能获取他的实例，只能被别人用来继承</span><br></pre></td></tr></table></figure><blockquote><p>bean之间的依赖（只是改变创建顺序）如果在创建之前写入 depends-on=‘book,person“，那么就会先创建book 还有person。</p></blockquote><blockquote><p>通过静态工厂方法创建bean，实例工厂方法创建bean<br>bean的创建默认就是框架利用反射new出来的bean实例，工厂模式就是有一个类帮你去创建对象</p></blockquote><ol><li>静态工厂：工厂本身不用创建对象：通过静态方法调用  对象 = 工厂类.工厂方法名（）</li><li>实例工厂：工厂本身需要创建对象：<blockquote><p>工厂类 工厂对象 =  new 工厂类（）；<br>工厂对象.getAirplane</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">factory-method：指定工厂方法</span><br><span class="line">class:指定静态工厂全类名</span><br><span class="line">&lt;constructor-arg value&#x3D;&quot;李四&quot;&gt;&lt;&#x2F;constructor-arg&gt;传参</span><br></pre></td></tr></table></figure><blockquote><p>实例工厂</p></blockquote></li><li>先配出实例工厂对象</li><li>配置我们需要创建的airPlane使用哪个工厂创建</li><li>facotry-bean ：指定使用哪个工厂实例</li><li>factory-method：使用哪个工厂方法</li></ol><blockquote><p>FactoryBean（是Spring规定的一个接口);只要是这个接口的实现类，Spring都认为是一个工厂，ioc容器启动的时候就不会创建实例</p></blockquote><h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h4><ol><li><p>ioc容器中注册的bean：</p><ol><li>单例bean ，容器启动的时候才会创建好，容器关闭也会销毁创建的bean</li><li>多例bean，获取的时候才会创建</li></ol></li><li><p>引用外部属性文件:</p><ol><li>数据库连接池作为单实例是最好的，一个项目就一个连接池，连接池里面管理很多连接。连接直接从连接里拿，可以让spring 帮我们创建连接池对象。</li><li>依赖context名称空间，可以加载外部配置文件</li></ol></li></ol><h4 id="自动装配（自动赋值）"><a href="#自动装配（自动赋值）" class="headerlink" title="自动装配（自动赋值）"></a>自动装配（自动赋值）</h4><ol><li>autowire= “default” ，可以填byName ,byType, constructor,no。</li><li>例如说byName，按照名字，以属性名作为id去容器里找到这个组件，给他赋值。如果找不到就装配null</li></ol><h4 id="Spring有四种注解："><a href="#Spring有四种注解：" class="headerlink" title="Spring有四种注解："></a>Spring有四种注解：</h4><ol><li>@Controller  控制器</li><li>@Service 业务逻辑</li><li>@Respository 数据库（持久化层）</li><li>@Component<blockquote><p>注意：某个类上添加任何一个注解都能快速的将这个组件加入ioc容器的管理</p></blockquote></li></ol><h5 id="添加步骤："><a href="#添加步骤：" class="headerlink" title="添加步骤："></a>添加步骤：</h5><ol><li>加入注释:告诉Spring，自动扫描加注释，依赖名称空间 –context:component-scan<br>base.package:” “填入需要扫描的包，至少填两级目录</li><li>在ioc获取bean的过程中，id是默认是类名的首字母小写， 也可以在注释后加入()来修改名字</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Spring学习笔记&quot;&gt;&lt;a href=&quot;#Spring学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记&quot;&gt;&lt;/a&gt;Spring学习笔记&lt;/h4&gt;&lt;h4 id=&quot;框架的概念：&quot;&gt;&lt;a href=&quot;#框架的概念：&quot; class=&quot;headerlink&quot; title=&quot;框架的概念：&quot;&gt;&lt;/a&gt;框架的概念：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;高度抽取可重用代码的设计&lt;/li&gt;
&lt;li&gt;高度的通用性&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="back-end" scheme="https://fengzehe.github.io/blog/categories/back-end/"/>
    
    
      <category term="后端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用CSS3做LoadIng动画</title>
    <link href="https://fengzehe.github.io/blog/2019/12/12/frontEnd_Loading/"/>
    <id>https://fengzehe.github.io/blog/2019/12/12/frontEnd_Loading/</id>
    <published>2019-12-12T06:47:13.000Z</published>
    <updated>2020-06-12T01:45:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用CSS3做Loading动画"><a href="#使用CSS3做Loading动画" class="headerlink" title="使用CSS3做Loading动画"></a>使用CSS3做Loading动画</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用CSS3做Loading动画&quot;&gt;&lt;a href=&quot;#使用CSS3做Loading动画&quot; class=&quot;headerlink&quot; title=&quot;使用CSS3做Loading动画&quot;&gt;&lt;/a&gt;使用CSS3做Loading动画&lt;/h3&gt;
      
    
    </summary>
    
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="CSS3" scheme="https://fengzehe.github.io/blog/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>vue学习笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/10/02/vue/"/>
    <id>https://fengzehe.github.io/blog/2019/10/02/vue/</id>
    <published>2019-10-02T01:03:25.000Z</published>
    <updated>2020-06-18T10:17:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue学习笔记"><a href="#vue学习笔记" class="headerlink" title="vue学习笔记"></a>vue学习笔记</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><pre><code>Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现在话的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</code></pre><a id="more"></a><h3 id="vue的特点："><a href="#vue的特点：" class="headerlink" title="vue的特点："></a>vue的特点：</h3><ol><li>渐进式：vue的侵入性很少，可以与很多其他前端技术联用</li><li>组件化</li><li>响应式：数据响应式，vue会监控数据变化。当数据变化时</li></ol><h3 id="vue的核心功能："><a href="#vue的核心功能：" class="headerlink" title="vue的核心功能："></a>vue的核心功能：</h3><h4 id="关于创建vue工程"><a href="#关于创建vue工程" class="headerlink" title="关于创建vue工程"></a>关于创建vue工程</h4><ol><li>直接在页面上引用vue.js</li><li>使用构建工具vue-cli脚手架</li></ol><h4 id="vue实例"><a href="#vue实例" class="headerlink" title="vue实例"></a>vue实例</h4><h4 id="vue实例：通过new-vue（配置对象）得到的对象"><a href="#vue实例：通过new-vue（配置对象）得到的对象" class="headerlink" title="vue实例：通过new vue（配置对象）得到的对象"></a>vue实例：通过new vue（配置对象）得到的对象</h4><ol><li>当创建vue实例的时候，vue将会把data（为了实现响应式）methods配置（为了在模板中方便使用）等配置成员提升到vue实例中.</li><li>由于有提升的存在，为了防止命名冲突，vue会将自身的成员名称前加上$ 或 _ , 为了防止命名冲突，vue会将自身的成员加上$(可以使用),_符号就不用用了</li></ol><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="插值：在模板的元素内部使用"><a href="#插值：在模板的元素内部使用" class="headerlink" title="插值：在模板的元素内部使用"></a>插值：在模板的元素内部使用</h4><h4 id="指令：通常作为元素的属性存在，名称上以v-开头"><a href="#指令：通常作为元素的属性存在，名称上以v-开头" class="headerlink" title="指令：通常作为元素的属性存在，名称上以v- 开头"></a>指令：通常作为元素的属性存在，名称上以v- 开头</h4><p>v-for:用于循环生成元素<br>v-on :用于注册事件。 语法糖@<br>v-if :用于判断该玄素是否可以生成,可以与v-else 或者v-else-if联用<br>v-show:元素已经显示,display:none<br>v-bind:用于绑定属性, 语法糖:<br>v-model：用于事件双向绑定，实际上是自动绑定用了value值,和注册了input事件</p><h4 id="模板中的配置"><a href="#模板中的配置" class="headerlink" title="模板中的配置"></a>模板中的配置</h4><ol><li>页面中直接书写</li><li>在template配置中书写（常见）</li><li>在render中手动配置用函数创建，render函数的参数是一个创建虚拟DOM对象，为什么要创建虚拟DOM,因为真实DOM操作特别慢</li></ol><h3 id="配置对象"><a href="#配置对象" class="headerlink" title="配置对象"></a>配置对象</h3><ol><li>template:字符串，配置模板</li><li>el:配置控制的元素，css选择器</li><li>data: 管理的数据，该数据是响应式的</li><li>mothods:配置方法，方法中的this指向vue实例，不能会用箭头函数,会干扰vue绑定this<h3 id="挂在的配置"><a href="#挂在的配置" class="headerlink" title="挂在的配置"></a>挂在的配置</h3></li><li>通过el进行配置</li><li>使用vue实例中的$mount函数进行配置</li></ol><h3 id="关于computed-–计算属性"><a href="#关于computed-–计算属性" class="headerlink" title="关于computed –计算属性"></a>关于computed –计算属性</h3><ol><li>计算属性，其中的配置会提升到vue实例中，因为在模板中可以直接当做属性使用，使用时，实际上调用的是对应的方法。通常，计算属性用户通过data或其他计算属性得到的数据。</li><li>与方法的区别：vue会检查计算属性的依赖，当依赖没有发生变化时，vue会直接使用之前缓存的结果，而不会重新计算</li><li>能用计算属性尽量使用，因为效率很高。依赖不变时不会重新加载。（计算属性的读取函数不可以有参数，有参数没意义）</li><li>计算属性可以配置get和set. 分别用于读取时和设置时。 get读取属性的时候可以监听到，然后检查那张表函数有没有变化。</li></ol><h3 id="关于v-html指令："><a href="#关于v-html指令：" class="headerlink" title="关于v-html指令："></a>关于v-html指令：</h3><ol><li>vue为了安全，会将元素内部的插值进行实体编码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-html &#x3D; &quot;html&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">config &#x3D; &#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        html:&lt;p&gt;带标签的元素&lt;&#x2F;p&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;这样就可以把html标签渲染出来了</span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是页面中可复用的功能单元</p><h4 id="VUE中的组建"><a href="#VUE中的组建" class="headerlink" title="VUE中的组建"></a>VUE中的组建</h4><ol><li>组件的创建：组件对于开发者，是一个普通的配置对象</li><li>组件的注册：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局注册组件</span><br><span class="line">Vue.component(&quot;组件形成&quot;,pager)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;局部注册组件 在使用的组件和vue实例配置中进行注册</span><br><span class="line">const config &#x3D; &#123;</span><br><span class="line">    template:&#96;&lt;div&gt;</span><br><span class="line">        &lt;MyPager&gt;&lt;&#x2F;MyPager&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;,</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        MyPager :pager</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="组件名称的规范，以下命名的方式任选其一："><a href="#组件名称的规范，以下命名的方式任选其一：" class="headerlink" title="组件名称的规范，以下命名的方式任选其一："></a>组件名称的规范，以下命名的方式任选其一：</h4><ol><li>使用短横线命名</li><li>使用大驼峰命名<h4 id="组件的使用：把组件当成标签使用即可，标签名任选其一"><a href="#组件的使用：把组件当成标签使用即可，标签名任选其一" class="headerlink" title="组件的使用：把组件当成标签使用即可，标签名任选其一"></a>组件的使用：把组件当成标签使用即可，标签名任选其一</h4></li><li>短横线命名</li><li>大驼峰命名</li></ol><p>组件可以嵌套，因为会形成一个组件树，组件树的根叫做根组件</p><h3 id="组件中的数据通信："><a href="#组件中的数据通信：" class="headerlink" title="组件中的数据通信："></a>组件中的数据通信：</h3><ol><li>prevent修饰符用于v-on指令，表示阻止默认行为</li><li>stop修饰符用于v-on指令，表示阻止事件冒泡</li></ol><h4 id="组件的状态和属性："><a href="#组件的状态和属性：" class="headerlink" title="组件的状态和属性："></a>组件的状态和属性：</h4><ol><li>通常讲组件中需要自身管理的数据（组件配置中的data）叫做组件状态（component state），组件状态只能在组件内部使用，外部原则上不可以使用.</li><li>data(state 状态)在组件中的配置和在vue实例中配置的区别：<br>在组件中data必须是一个函数，而VUE实例中心必须是一个对象。因为组件是可以被复用的，每一个组件都是独立的，所以data必须是一个函数.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在组件中</span><br><span class="line">export default&#123;</span><br><span class="line">    template,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x2F;&#x2F;返回的结果是组件的状态</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组件中可以有属性（component-props），而vue实例中没有"><a href="#组件中可以有属性（component-props），而vue实例中没有" class="headerlink" title="组件中可以有属性（component props），而vue实例中没有"></a>组件中可以有属性（component props），而vue实例中没有</h4><ol><li>声明组件属性时，使用短横线或小驼峰命名法</li><li>传递组件属性时，使用短横线或小驼峰命名法</li><li>属性会被提升到vue组件实例中</li></ol><p>==组件的属性时只读的，不允许更改，根本原因是要保证单向数据流==</p><h3 id="自定义事件："><a href="#自定义事件：" class="headerlink" title="自定义事件："></a>自定义事件：</h3><ol><li>在组件中触发事件： this.$emit(“事件名”,事件参数…)</li><li>当一个组件状态发生变化时，该组件会重新渲染，在渲染的过程中，可能会导致其子组件的属性发生变化，而属性的变化会导致组件重新渲染。但根本原因，是状态的变化.</li><li>v-model 的本质是一个语法糖，实际上是绑定value属性，同时监听input事件</li></ol><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><ol><li>beforeCreate(){}  –&gt;这个是自动执行的</li><li>created()  –&gt;组件实例中已经提升到实例总，但是没有渲染页面</li><li>beforeMount   –&gt; 组件即将进行渲染，但还没有渲染，此时已经编译好模板</li><li>mounted【常用】  –&gt;组件已经完成渲染（页面可见）</li><li>beforeUpdate –&gt;组件即将更新，还没有更新，此时得到的数据是新的，但页面依旧是旧的</li><li>updated –&gt; 数据，界面都是新的</li><li>beforeDestory –&gt; 当组件即将被销毁  调用vm.$destroy()函数</li><li>destoryed  –&gt; 解除绑定，销毁子组件以及事件监听器</li></ol><h3 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h3><p>vue路由，可以简单理解为，当访问某个地址时，渲染某个组件</p><p>使用路由</p><ol><li>根据一个配置对象创建路由，得到路由对象</li><li>在创建vue实例时，将路由对象配置到实例配置的router中</li><li>在合适的位置写上router-view组件，表示路由匹配到组件渲染的位置，它实际上是vue-router做好的一个组件，并且做好了全局注册</li></ol><p>路由配置对象</p><ol><li>routes:路由规则配置</li><li>mode:配置模式<ol><li>hash模式，兼容性最好，地址出现#号后，切换地址不会导致页面刷新</li><li>history模式，使用的是HTML5 history API，地址直接变化，并且页面不刷新</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vue学习笔记&quot;&gt;&lt;a href=&quot;#vue学习笔记&quot; class=&quot;headerlink&quot; title=&quot;vue学习笔记&quot;&gt;&lt;/a&gt;vue学习笔记&lt;/h2&gt;&lt;h3 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;headerlink&quot; title=&quot;概念：&quot;&gt;&lt;/a&gt;概念：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现在话的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://fengzehe.github.io/blog/categories/front-end/"/>
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2019-09-03 实习笔记</title>
    <link href="https://fengzehe.github.io/blog/2019/09/03/2019.09.03/"/>
    <id>https://fengzehe.github.io/blog/2019/09/03/2019.09.03/</id>
    <published>2019-09-03T14:58:13.000Z</published>
    <updated>2020-06-18T10:17:14.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h5><blockquote><p>今天刷面试题的时候，遇到一个问题——如何判断一段字符串里面出现最多的字符以及出现次数。</p></blockquote><h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><ol><li>利用javascript对象的属性特征，可以实现每个字符与出现次数的绑定</li><li>通过遍历和累加，计算得出每个字符出现的次数</li><li>通过对比出现的次数，返回出现次数最多的字符<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">const str &#x3D; &#39;asddfgdfwwqeweqwezczxcsdfgdgd&#39;;</span><br><span class="line"></span><br><span class="line">   var obj &#x3D; &#123;&#125;;</span><br><span class="line">   var max &#x3D; 0;</span><br><span class="line">   var maxStr &#x3D; &quot;&quot;;</span><br><span class="line">   for(let i &#x3D; 0; i &lt; str.length ; i++)&#123;</span><br><span class="line">     var word &#x3D; str.charAt(i);</span><br><span class="line">     if(obj[word] !&#x3D; null)&#123;</span><br><span class="line">       obj[word]++;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">       obj[word] &#x3D; 1</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     for(let i in obj)&#123;</span><br><span class="line">       if(obj[i]&gt;max)&#123;</span><br><span class="line">         max &#x3D; obj[i];</span><br><span class="line">         maxStr &#x3D; i</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&#39;出现最多次:&#39; + max +&#39;的字符是：&#39;+ maxStr)</span><br><span class="line">   console.log(obj);</span><br><span class="line">   &#x2F;&#x2F; &#123;a: 1, s: 2, d: 6, f: 3, g: 3, …&#125;</span><br><span class="line">   &#x2F;&#x2F; a: 1</span><br><span class="line">   &#x2F;&#x2F; c: 2</span><br><span class="line">   &#x2F;&#x2F; d: 6</span><br><span class="line">   &#x2F;&#x2F; e: 3</span><br><span class="line">   &#x2F;&#x2F; f: 3</span><br><span class="line">   &#x2F;&#x2F; g: 3</span><br><span class="line">   &#x2F;&#x2F; q: 2</span><br><span class="line">   &#x2F;&#x2F; s: 2</span><br><span class="line">   &#x2F;&#x2F; w: 4</span><br><span class="line">   &#x2F;&#x2F; x: 1</span><br><span class="line">   &#x2F;&#x2F; z: 2</span><br><span class="line">   &#x2F;&#x2F; __proto__: Object</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;今天刷面试题的时候，遇到一个问题——如何判断一段字符串里面出现最多的字符以及出现次数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;利用javascript对象的属性特征，可以实现每个字符与出现次数的绑定&lt;/li&gt;
&lt;li&gt;通过遍历和累加，计算得出每个字符出现的次数&lt;/li&gt;
&lt;li&gt;通过对比出现的次数，返回出现次数最多的字符&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="前端技术" scheme="https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
