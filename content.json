{"meta":{"title":"何泽丰的博客","subtitle":null,"description":"怕，你就输一辈子","author":"何泽丰","url":"https://fengzehe.github.io/blog","root":"/blog/"},"pages":[{"title":"categories","date":"2019-05-11T00:07:16.000Z","updated":"2020-01-17T02:22:19.000Z","comments":true,"path":"categories/index.html","permalink":"https://fengzehe.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2020-06-20T01:16:10.000Z","updated":"2020-06-17T13:15:36.000Z","comments":false,"path":"about/index.html","permalink":"https://fengzehe.github.io/blog/about/index.html","excerpt":"","text":"人生如棋 , 落子无悔剑未佩妥 , 出门已是江湖​ 我是何泽丰，毕业于吉林大学珠海学院，来自计算机学院。以下这些话是写给我自己的： ​ 2020年6月，我翻过了大学生活的最后一页，步入社会开启了新的人生篇章。 ​ 时光发生在学校东门的地球仪、教学楼、食堂、操场、图书馆，再到学校热闹的南门，再到延伸着海岸线能看到飞机起降的阳光咀沙滩。回想起毕业设计最后的致谢，回想起在大学里面的点点滴滴，脑海里是课堂上和蔼可亲尽职尽责的老师的，是图书馆里对着电脑沉思认真学习，或是在操场挥洒汗水的同学。读大学的时候总是伴随着热辣的太阳与狂风暴雨，像极了青春活力的大学生，却时而欢乐时而忧愁。大学期间的我对未来有着美好憧憬，也在憧憬中孕育着规划。我知道，大学吹过的风流过的汗，或是奋斗过的日夜终究像逝去的青春一样回不来，只希望能好好的记住这些闪闪发光的日子，也希望能自己永远记得大学里对未来充满活力与希望的自己。 ​ 所以，你好，再见！ ​ ——摄于 广东珠海金湾区 吉林大学珠海学院 2019年5月某日傍晚 ​ ——摄于 广东珠海金湾区 阳光咀 2019年5月某日傍晚"},{"title":"tags","date":"2019-05-11T00:05:36.000Z","updated":"2019-05-11T00:18:48.000Z","comments":false,"path":"tags/index.html","permalink":"https://fengzehe.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"菜鸟成长记05","slug":"record05","date":"2020-07-16T02:20:41.000Z","updated":"2020-07-16T03:58:15.000Z","comments":true,"path":"2020/07/16/record05/","link":"","permalink":"https://fengzehe.github.io/blog/2020/07/16/record05/","excerpt":"|前言 平时我们在开发的时候会写一份本地的json假数据。之前我们都用ajax的GET方式来获取","text":"|前言 平时我们在开发的时候会写一份本地的json假数据。之前我们都用ajax的GET方式来获取 但现在有业务需求需要用post来获取，如果在vscode中使用live server打开就会出现这种错误。 Failed to load resource: the server responded with a status of 405 (Method Not Allowed) 网上许多解决方法都是windows下的解决方案，例如说 （1）不通过IIS访问，使用其他的访问方式 （2）修改IIS的“处理程序映射”。 但在Mac下并没有特别好的解决方法。 这时候我回想了一下，请求静态资源是要用get请求，使用post请求的时候并且发送url是一个具体的资源的时候，网络会把url当做域名来解析。 虽然道理是这样的，我想了一下live server是小型服务器，那我或许也可以在apache上跑一下。 然后配置了一下apache并启动就可以了。 Apache的配置 Mac虽然是自带Apache，但文件根目录非常难找，在/etc/apache2/ 的文件夹下 我们找到httpd.conf文件后可以用sublime Text打开。找到DocumentRoot 这两行，修改为自定义路径。 例如我修改为/Users/hezefeng/Server 然后往下找，把Options FollowSymLink修改为Options Indexes FollowSymLinks 再往下找，把#LoadModule php7_module libexec/apache2/libphp7.so最前面的#去掉。 事后重启一下服务器就好了","categories":[{"name":"rookie growth record","slug":"rookie-growth-record","permalink":"https://fengzehe.github.io/blog/categories/rookie-growth-record/"}],"tags":[{"name":"-- record","slug":"record","permalink":"https://fengzehe.github.io/blog/tags/record/"}]},{"title":"人生不止有技术01","slug":"technology01","date":"2020-07-15T01:55:59.000Z","updated":"2020-07-15T01:56:37.000Z","comments":true,"path":"2020/07/15/technology01/","link":"","permalink":"https://fengzehe.github.io/blog/2020/07/15/technology01/","excerpt":"人生不止有技术","text":"人生不止有技术 还有生活和远方","categories":[{"name":"not only technology","slug":"not-only-technology","permalink":"https://fengzehe.github.io/blog/categories/not-only-technology/"}],"tags":[{"name":"-- 人生不止有技术","slug":"人生不止有技术","permalink":"https://fengzehe.github.io/blog/tags/%E4%BA%BA%E7%94%9F%E4%B8%8D%E6%AD%A2%E6%9C%89%E6%8A%80%E6%9C%AF/"}]},{"title":"菜鸟成长记 04","slug":"record04","date":"2020-07-13T14:03:01.000Z","updated":"2020-07-13T14:20:37.000Z","comments":true,"path":"2020/07/13/record04/","link":"","permalink":"https://fengzehe.github.io/blog/2020/07/13/record04/","excerpt":"在看vue.js实战的时候笔者留下了一道题: 1. 在当前示例基础上扩展商品列表，新增一项是否选中该商品的功能，总价变为只计算选中商品的总价，同时提供一个全选的按钮。","text":"在看vue.js实战的时候笔者留下了一道题: 1. 在当前示例基础上扩展商品列表，新增一项是否选中该商品的功能，总价变为只计算选中商品的总价，同时提供一个全选的按钮。 2. “将商品列表list改成一个二维数组来实现商品的分类，比如可分为”电子产品”，”生活用品”和”果蔬”，同类商品聚合在一起，你可能用到两次v-for。 做出来的效果是这样的： |思路： 选中商品功能，商品需要添加一个check属性。通过查询商品的check属性判断是否被选中。 总价变为计算选中商品的总价，因此我们可以在 computed计算总价totalPrice加一步验证。商品属性check = true才计算总价。 在全选的时候把商品的check属性都遍历一遍 –&gt; 把商品的check属性都设置为true，并把全选属性 isCheckedAll设置为true表示已经全选。 当单件商品取消选中的时候要把isCheckedAll设置为fasle，表示已经取消全选。 |步骤： 收到的数据是一个二维数组，分别显示商品类别以及商品内容。 12345678910111213141516list: [ &#123; title_name: '电子产品', content: [ &#123; id: 1, name: 'iPad Pro', price: 5799, count: 1, check: false, &#125;, &#123; id: 2, name: 'iPhone XS ', price: 5089, count: 1, check: false, &#125;, &#123; id: 3, name: 'Macbook Pro', price: 13199, count: 1, check: false, &#125;, ] &#125; ] 购物车页面显示商品类别，名称数量以及操作。底部显示总价以及结账。 通过计算属性来显示总价。循环二维数组两次，根据是否选中情况计算总价 12345678910111213141516computed: &#123; totalPrice: function () &#123; var total = 0; for (var i = 0; i &lt; this.list.length; i++) &#123; var item = this.list[i]; for (var j = 0; j &lt; item.content.length; j++) &#123; var items = item.content[j]; if (items.check == true) &#123; total += items.price * items.count; &#125; &#125; &#125; this.total = total return total; &#125; &#125; 单选和全选。实现的原理与全选类似，在选中按钮中绑定checked属性，绑定check属性确定绑定状态 123456789101112131415161718192021222324252627282930check: function (index1, index2) &#123; if (this.list[index1].content[index2].check) &#123; this.list[index1].content[index2].check = false; this.isCheckedAll = false; &#125; else &#123; this.list[index1].content[index2].check = true; &#125; &#125;,checkAll: function () &#123; if (this.isCheckedAll == false) &#123; for (var i = 0; i &lt; this.list.length; i++) &#123; var item = this.list[i]; for (var j = 0; j &lt; item.content.length; j++) &#123; var items = item.content[j]; items.check = true; &#125; &#125; this.isCheckedAll = true; &#125; else &#123; for (var i = 0; i &lt; this.list.length; i++) &#123; var item = this.list[i]; for (var j = 0; j &lt; item.content.length; j++) &#123; var items = item.content[j]; items.check = false; &#125; &#125; this.isCheckedAll = false; &#125; &#125; 所以大致就是这样实现的啦。我把题目的代码放在这里： https://github.com/FengZeHe/vue.jsPracticalsubject/tree/master/shoppingCar/shop_demo","categories":[{"name":"rookie growth record","slug":"rookie-growth-record","permalink":"https://fengzehe.github.io/blog/categories/rookie-growth-record/"}],"tags":[{"name":"-- 记录","slug":"记录","permalink":"https://fengzehe.github.io/blog/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"rem移动端适配","slug":"mobile-terminal-rem","date":"2020-07-05T04:08:58.000Z","updated":"2020-07-05T07:27:06.000Z","comments":true,"path":"2020/07/05/mobile-terminal-rem/","link":"","permalink":"https://fengzehe.github.io/blog/2020/07/05/mobile-terminal-rem/","excerpt":"|前言：什么是移动端适配？ web移动端网页跟PC端显示大小与内容不一样，因此需要适配。 而且手机设备之间屏幕尺寸不一，需要适配不同屏幕宽度的移动设备。","text":"|前言：什么是移动端适配？ web移动端网页跟PC端显示大小与内容不一样，因此需要适配。 而且手机设备之间屏幕尺寸不一，需要适配不同屏幕宽度的移动设备。 |常见的适配方法 viewport rem flex vm/vh |物理像素是什么 显示屏的最佳分辨率，即屏幕实际存在的像素行数乘以列数的数学表达方式，是显示屏固有的参数，不能调节，其含义是指显示屏最高可显示的像素数。物理分辨率也叫标准分辨率，是指LED显示屏显示的图像原始分辨率，也叫真实分辨率。和物理分辨率对应的是压缩分辨率，决定图像清晰程度的是物理分辨率，决定显示屏的适用范围的是压缩分辨率。物理分辨率即LED液晶板的实际分辨率，在LED液晶板上通过网格来划分液晶体，一个液晶体为一个像素点。物理分辨率越高，则可接收分辨率的范围越大，则显示屏的适应范围越广。 这里就肯定要提到Retina屏，2560X1600个像素每四个一组，输出原来屏幕的一个像素显示的大小区域内的图像。用户看到的图片与文字大小与1280x800分辨率的显示器相同，但精细度是原来的4倍。所以说Retina显示目的是为了解决画面精细度的问题而不是增加显示内容。 ​ 上图是Retina屏，下图是旧显示器。上图是我们可以发现像素边缘下图更加平滑，是使用更多的像素点来表示图形的缘故。 |rem移动端适配 定义 ：rem是一个css单位，这个单位比em多一个字母所以说多少有点类似。但不同的是em根据父元素显示大小，rem是相对于根标签对于px的定义来显示大小。例如说font-size = 16px表示 1rem = 16px;在移动端适配的时候设置rem可以让元素等比例放大或缩小以达到在不同设备显示一致的效果。 根据设备宽度作为基准 ，设置其根标签大小。我们可以通过函数来设置根标签的rem大小，并且在每次设备窗口宽度改变的时候重新计算根标签的fontsize。 1234567891011!function()&#123; function e()&#123; var e = document.documentElement.clintWidth, t = document.querySelector('html'), f = ( e &gt; 750 ? 750 : e) / ??? ;//根据实际情况设置 t.style.fontSize = f + 'px'; &#125; e(), window.addEventListener('resize',e); // 当调整浏览器窗口的大小时，发生 resize 事件并重新计算参数&#125;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"-- record","slug":"record","permalink":"https://fengzehe.github.io/blog/tags/record/"}]},{"title":"菜鸟成长记 03","slug":"record03","date":"2020-07-01T02:26:59.000Z","updated":"2020-07-03T08:14:47.000Z","comments":true,"path":"2020/07/01/record03/","link":"","permalink":"https://fengzehe.github.io/blog/2020/07/01/record03/","excerpt":"减少代码冗余​ 在写一个项目的时候发现一个页面有许多弹窗触发，一开始写的时候通过ID名选中元素并设置显示或不显示。后来发现一个弹窗还好，当出现若干弹窗的时候代码重复度非常高，非常冗余。","text":"减少代码冗余​ 在写一个项目的时候发现一个页面有许多弹窗触发，一开始写的时候通过ID名选中元素并设置显示或不显示。后来发现一个弹窗还好，当出现若干弹窗的时候代码重复度非常高，非常冗余。 ​ 因为每个弹窗固定的位置都有一个关闭按钮，按钮的位置是每个父级div下的一个元素节点。所以我想在点击事件后传入dom元素的父节点的ID，以此来绑定父级ID。因此用show()函数设置元素显示，通过hide()函数设置函数隐藏。 1234&lt;div id=\"please_login\"&gt; &lt;div class=\"btn_close \" onclick=\"hide(this.parentNode.id)\"&gt;&lt;/div&gt; &lt;div class=\"login\" onclick=\"login()\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910function show(node) &#123; var nodeId = document.getElementById(node); nodeId.style.display = 'block';&#125;function hide(node) &#123; var nodeId = document.getElementById(node); nodeId.style.display = 'none'&#125; 完成后减少了40行左右的代码，看起来更加清爽了。 但我过了一天发现其实可以把两个函数写成一个啊 12345678function ShowHide(state)&#123; var b &#x3D; document.getElementById(state); if(b.style.display !&#x3D; &#39;none&#39;)&#123; b.style.display &#x3D; &#39;none&#39; &#125;else&#123; b.style.display &#x3D; &#39;block&#39;; &#125;&#125;","categories":[{"name":"rookie growth record","slug":"rookie-growth-record","permalink":"https://fengzehe.github.io/blog/categories/rookie-growth-record/"}],"tags":[{"name":"-- 记录","slug":"记录","permalink":"https://fengzehe.github.io/blog/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"菜鸟成长记 02","slug":"record02","date":"2020-06-30T13:20:32.000Z","updated":"2020-07-01T01:14:46.000Z","comments":true,"path":"2020/06/30/record02/","link":"","permalink":"https://fengzehe.github.io/blog/2020/06/30/record02/","excerpt":"实现原生JS封装一个AJAS 前言：我们的使用ajax实现异步请求数据的时候，通常都是使用jQuery封装好的方法。","text":"实现原生JS封装一个AJAS 前言：我们的使用ajax实现异步请求数据的时候，通常都是使用jQuery封装好的方法。 什么是AJAX?​ A J A X = asynchronous javascript and xml ​ ajax可以将数据作为纯文本或者json文本传输。ajax允许通过与场景后面web服务器交换数据来异步更新网页，既不需要重新加载整个页面。 JQuery方法简单快捷，是需要几步代码搞定 123456789101112131415$.ajax(&#123; url: \"data.json\", type: \"GET\", dataType: \"json\", data: &#123; mobile: 13500010101 &#125;, success: function (data) &#123; temp = data; return temp; &#125;, error: function (data) &#123; console.log('error', data); &#125;&#125;) 但我们不用JQuery的时候要怎么使用原生js来封装呢？ 原生JS方法 首先创建XMLHttpRequest对象 现代浏览器都有内建的XMLHttpRequest对象，老旧浏览器（IE5 ，IE6）需要使用ActiveXObject对象 GET请求 12xhttp.open(\"GET\", \"data.json\", true);xhttp.send(); POST请求 123xhttp.open(\"POST\", \"ajax_test.asp\", true);xhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");xhttp.send(\"fname=Bill&amp;lname=Gates\"); 最终实现 123456789101112131415function fn() &#123; var xhttp; if(window.XMLHttpRequest)&#123; xhttp = new XMLHttpRequest(); &#125;else&#123; xhttp = new ActiveXObject(\"Microsoft.XMLHttp\")'' &#125; xhttp.onreadystatechange = function () &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; data = JSON.parse(this.response); &#125; &#125; xhttp.open(\"GET\", \"data.json\", true); xhttp.send(); &#125; ​ 5. 这里补充一下，response里面存的是JSON类型的字符换，使用JSON.parse()方法可以使JSON字符串转换为js对象，这样调用起来就很方便了。","categories":[{"name":"rookie growth record","slug":"rookie-growth-record","permalink":"https://fengzehe.github.io/blog/categories/rookie-growth-record/"}],"tags":[{"name":"--  记录","slug":"记录","permalink":"https://fengzehe.github.io/blog/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"菜鸟成长记 01","slug":"record01","date":"2020-06-29T14:34:49.000Z","updated":"2020-06-30T01:38:09.000Z","comments":true,"path":"2020/06/29/record01/","link":"","permalink":"https://fengzehe.github.io/blog/2020/06/29/record01/","excerpt":"移动端适配问题当我们拿到750px像素的原型，移动端适配的时候将原型转换成html文件需要像素减半。","text":"移动端适配问题当我们拿到750px像素的原型，移动端适配的时候将原型转换成html文件需要像素减半。 ​ 如我拿到一张750px 1206px的psd原型，放在移动端要设置成375px和603px。因为之前我在学习的时候并没有ui设计图让我切，所以在公司练手啥也不会。 ​ 另外是要导出一个组合图形的时候，先转换成智能对象，清除栅格化，导出为PNG就可以得到背景是透明度的图形了。 ​ 话虽如此，但我在开发过程中发现，虽然图片背景是透明的，但还是看到了一些端倪。 ​ 虽然导出了背景是透明的PNG图片，但我们还是能看到按钮的背景图片边角并不是透明的。 一开始我以为是导出图片的问题. ​ 其实并不是导出图片的问题。因为我使用了一个button包裹里面的a标签，在设置button背景的时候还受到button自身背景的影响，于是在button处设置 background-color : transparent就可以了。对比如下图。","categories":[{"name":"rookie growth record","slug":"rookie-growth-record","permalink":"https://fengzehe.github.io/blog/categories/rookie-growth-record/"}],"tags":[{"name":"--  记录","slug":"记录","permalink":"https://fengzehe.github.io/blog/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"ES6异步的解决方案","slug":"es6-async","date":"2020-02-26T23:50:33.000Z","updated":"2020-06-18T12:43:47.000Z","comments":true,"path":"2020/02/27/es6-async/","link":"","permalink":"https://fengzehe.github.io/blog/2020/02/27/es6-async/","excerpt":"背景js经常会遇到一些异步任务（需要经过一段时间或当某个时机到达后才能得到的任务）例如说： 使用ajax请求服务器，当服务器完成响应后拿到响应结果 监听按钮是否被点击，当按钮点击后拿到某个文本框的值 使用setTimeout 等待一段时间，当时间到达后做某些事情","text":"背景js经常会遇到一些异步任务（需要经过一段时间或当某个时机到达后才能得到的任务）例如说： 使用ajax请求服务器，当服务器完成响应后拿到响应结果 监听按钮是否被点击，当按钮点击后拿到某个文本框的值 使用setTimeout 等待一段时间，当时间到达后做某些事情 面对这样的场景，JS没有一种标准的模式来进行处理，我们处理这些问题的方式是杂乱的，这就导致了不同的人书写的异步任务代码使用方式不一致。例如说实用第三方库，不知道要传进去多少个参数，或者各种参数放第几位。 ES6异步处理模型ES6将异步场景分为两个阶段和三种状态 两个场景： unsettled (未决) settled (已决) 三种状态： pending (挂起) resolved(完成) rejected (失败) 当任务处于未决时状态一定是pending的，表示任务从开始至拿到结果之间的过程。例如说网络完成了各种配置，发送了请求但还没有收到回复当任务处于已决时它只能是resolved和reject两种状态之间的一种。例如说拿到或者没拿到数据--&gt; resolved状态 。网络不通畅 --&gt; rejected状态我们把从未决推向已决的resolved状态的过程，叫做resolve，从未决推向已决的rejected状态的过程，叫做reject如下图所示 任务已决后(有了结果)进一步做后续处理，如果任务成功了（resolved）,有后续处理，如果任务失败了（rejected）,仍可能做后续处理我们把针对resolved的后续处理称之为thenable，针对rejected的后续处理，称之为catchable 注意事项 任务一旦进入已决后，所有企图改变代码任务状态的代码都将失效 以下代码可以让任务达到rejected 状态 调用reject 代码执行报错 抛出错误 后续处理函数一定是异步函数，并且放在微队列中","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}]},{"title":"ES6模块化","slug":"ES6-modular","date":"2020-02-23T13:20:35.000Z","updated":"2020-06-18T10:13:29.000Z","comments":true,"path":"2020/02/23/ES6-modular/","link":"","permalink":"https://fengzehe.github.io/blog/2020/02/23/ES6-modular/","excerpt":"ES6的模块化模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件","text":"ES6的模块化模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件 模块化背景过去js很难编写大型应用，因为有以下两个问题： 全局变量污染 难以管理的依赖关系这些问题，都导致了JS无法进行精细的模块划分，因为精细的模块划分会导致更多的全局污染更加负载的依赖关系，因为功能精细的划分有利于代码重用 前端的模块化有两个标准： Commonjs ES6 Module注意：上面提到的两个均是模块化标准，具体的实现需要依托于JS的 ConmomJS简介：目前，只有node环境才支持CommonJs模块化标准，所以需要先安装node才能使用CommonJS在CommonJS中，浏览器运行的是html页面，并加载页面通过script元素引入js，node.js直接运行某个js文件，该文件被称之为入口文件。node.js遵循ECMAScript标准，但脱离了浏览器环境：你可以在node.js中使用ECMAScript标准的任何语法或api，例如循环，判断，数组，对象等等但不能在node.js中使用浏览器的web api,例如说dom对象，window对象，document对象 CommonJS标准和使用node中的所有代码均在CommonJS下运行，具体规范如下 ： 一个js文件既为一个模块如果一个模块需要暴露依稀额数据或功能给其他模块使用，需要使用代码module.exports = xxx ,该过程称之为模块的导出 如果一个模块需要使用另一个模块导出的内容，需要使用代码require(‘模块路径’) 12路径必须以.&#x2F;或..&#x2F;开头如果模块文件后缀名为 .js 可以省略后缀名 require 函数中返回的是模块导出的内容,且模块中所有的全局代码产生的变量、函数均不会对全局造成任何污染，仅在模块内使用 模块具有缓存，第一次导入模块时会缓存模块的导出，之后再导入同一个模块 会使用之前缓存的结果 有了CommomJS模块化，代码就会形成以下结构： 原理：node实际上是将模块文件中的代码防止到一个函数环境中执行，可以想象该函数是下面的样子： 12345function(module)&#123; module.exports &#x3D; &#123;&#125;; var exports &#x3D; module.exports; return module.exports;&#125; ES6 module 由于种种原因，CommonJS难以在浏览器中实现，因为一直在浏览器端没有合适的模块化标准，直到es6出现。ES6规范了浏览器的模块化标准，一经发布，各大浏览器厂商纷纷在自己的浏览器中实现该规范。 模块的引入： 12&#x2F;&#x2F;在浏览器使用以下方式引入ES6模块文件&lt;script src &#x3D; &quot;入口文件&quot; type &#x3D; &quot;module&quot;&gt; 标准和使用模块的导出分为两种，基本导出和默认导出 12345678可以将整个模块的导出想象成一个对象，基本导出导出的是该对象的某个属性，默认导出导出的是该对象的特殊属性default&#x2F;&#x2F;导出结果：想象成一个对象&#123; a: xxx, &#x2F;&#x2F;基本导出 b: xxx, &#x2F;&#x2F;基本导出 default: xxx, &#x2F;&#x2F;默认导出 c: xxx &#x2F;&#x2F;基本导出&#125; ES6的导出方式：1234567891011121314export var a &#x3D; 1 &#x2F;&#x2F;基本导出 a &#x3D; 1export var b &#x3D; function()&#123;&#125; &#x2F;&#x2F;基本导出 b &#x3D; function()&#123;&#125;export function method()&#123;&#125; &#x2F;&#x2F;基本导出 method &#x3D; function()&#123;&#125;var c &#x3D; 3;export &#123;c&#125; &#x2F;&#x2F;基本导出 c &#x3D; 3export &#123; c as temp &#125; &#x2F;&#x2F;基本导出 temp &#x3D; 3export default 3 &#x2F;&#x2F;默认导出 default &#x3D; 3export default function()&#123;&#125; &#x2F;&#x2F;默认导出 default &#x3D; function()&#123;&#125;export &#123; c as default &#125; &#x2F;&#x2F;默认导出 default &#x3D; 3export &#123;a, b, c as default&#125; &#x2F;&#x2F;基本导出 a&#x3D;1, b&#x3D;function()&#123;&#125;, 默认导出 default &#x3D; 3绝大部分时间写代码使用的导出方式是 export default()&#123;&#125; ES6模块的导入：使用以下的代码导入模块 12345678import &#123;a,b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性 a、b，放到变量a、b中import &#123;a as temp1, b as temp2&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性a、b，放到变量temp1、temp2 中import &#123;default as a&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default，放入变量a中，default是关键字，不能作为变量名，必须定义别名import &#123;default as a, b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default、b，放入变量a、b中import c from &quot;模块路径&quot; &#x2F;&#x2F;相当于 import &#123;default as c&#125; from &quot;模块路径&quot;import c, &#123;a,b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;相当于 import &#123;default as c, a, b&#125; from &quot;模块路径&quot;import * as obj from &quot;模块路径&quot; &#x2F;&#x2F;将模块对象放入到变量obj中import &quot;模块路径&quot; &#x2F;&#x2F;不导入任何内容，仅执行一次模块 细节导入模块时，注意以下细节 ES6 module 采用依赖预加载模式，所有模块导入代码均会提升到代码顶部 不能将导入代码放置到判断、循环中 导入的内容放置到常量中，不可更改 ES6 module 使用了缓存，保证每个模块仅加载一次","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}]},{"title":"当在浏览器输入一个地址发生了什么","slug":"when-Enter-an-address","date":"2020-02-15T02:28:28.000Z","updated":"2020-06-18T10:14:03.000Z","comments":true,"path":"2020/02/15/when-Enter-an-address/","link":"","permalink":"https://fengzehe.github.io/blog/2020/02/15/when-Enter-an-address/","excerpt":"过程是这样的： 浏览器将url地址补充完整，如果没有写协议就自动添加上协议（http： / https：）","text":"过程是这样的： 浏览器将url地址补充完整，如果没有写协议就自动添加上协议（http： / https：） 浏览器对url地址进行url编码，如果url地址中出现了非ASCII字符，浏览器则会对其进行编码 例如说在浏览器中搜索”王思聪”，汉字会被编码成ASCII码 浏览器构造一个没有消息体的GET请求，发送至服务器，等待服务器响应（此时浏览器标签应该有一个等等的图标–转圈） 服务器收到请求，将一个HTML页面代码组装到消息体中（不一定要html文件）响应给浏览器 浏览器拿到服务器的响应后，丢弃当前的页面，开始渲染消息体的HTML代码。浏览器之所以知道这是一个HTML代码，是因为服务器的响应头指定了消息类型为text/html 浏览器在渲染页面的过程中发现有嵌入的资源如CSS,JS图片等 浏览器使用不阻塞的渲染方式，重定向服务器发送该资源的请求，拿到响应结果后根据Content-Type做响应处理 当所有资源已经下载并处理好后，浏览器出发window.onload事件 这里说的Content-Tpye是在http协议消息头中表示具体请求中的媒体类型信息 有一下几种类型：","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}]},{"title":"实现一个简单的VUE","slug":"vue-demo-1","date":"2020-02-12T00:33:19.000Z","updated":"2020-06-29T13:23:06.000Z","comments":true,"path":"2020/02/12/vue-demo-1/","link":"","permalink":"https://fengzehe.github.io/blog/2020/02/12/vue-demo-1/","excerpt":"实现的效果 目标​ 实现一个简单的vue函数，包括双向数据绑定，数据的响应式","text":"实现的效果 目标​ 实现一个简单的vue函数，包括双向数据绑定，数据的响应式 思路1. 首先想到要实现vue的数据绑定，根据vue的双向数据绑定，把{{xxx}} 与data{}里面的值进行绑定。将值绑定后，我们想到要将这些数据渲染出来，这里就需要知道页面的各个节点与各节点的子节点 2. 再到数据响应模块，使用object.defineProperty来实现数据的响应式，用get方法来读取属性的值，用set方法来写入属性的值，以此来实现数据绑定 3. 最后为Vue添加构造函数，例如说this.$el 来表示绑定的元素，$data来表示绑定的数据，$vnode代表虚拟节点模块划分 编译模块 虚拟节点模块 渲染模块 数据响应模块 VUE构造函数模块 编译模块 提供一个compile函数，将一个模板文本(数据)和环境对象（DOM节点）编译成一个结果思想： 使用正则表达式匹配到html代码中包含 括号 的字符串 拿到字符串之后把两边括号替换掉，把表达式分割成数组 这需要与envObj环境变量进行配合使用，绑定后变成一个数组 compile.js 代码 1234567891011121314151617181920212223242526//过程： 先拿到&#123;&#123;xxx&#125;&#125;里面的字符串，然后再对字符串进行加工function getFragments(template) &#123; var matches = template.match(/&#123;&#123;[^&#125;]+&#125;&#125;/g); //万一有人的用户名叫12&#125; 所以这里要处理一下 return matches || [];&#125;function getValue(fragment, envObj) &#123; var exp = fragment.replace(\"&#123;&#123;\", \"\").replace(\"&#125;&#125;\", \"\"); var props = exp.split(\".\");//将表达式分割为属性数组 var obj = envObj; for (var i = 0; i &lt; props.length; i++) &#123; obj = obj[props[i]]; &#125; return obj;&#125;export default function compile(template, envObj) &#123; // 提取模板中的&#123;&#123;&#125;&#125; var flags = getFragments(template); var result = template; for (var i = 0; i &lt; flags.length; i++) &#123; var flag = flags[i]; result = result.replace(flag, getValue(flag, envObj)) &#125; return result;&#125; 虚拟DOM: 提供一个函数createVNode,根据提供真实的DOM，构建一个虚拟DOM树思想： 需要创建虚拟DOM 以便以后操作数据 需要判断真实节点是否为文本节点，如果是就要记录到虚拟节点 12345678910111213141516171819202122232425function VNode(realDom, template) &#123; // node 构造函数 this.realDom = realDom; this.template = template; this.children = [];&#125;export default function createVNode(realDom) &#123; var root = new VNode(realDom, \"\"); if (realDom.nodeType === Node.TEXT_NODE) &#123; root.template = realDom.nodeValue; // 判断真实节点是否为文本节点，如果是，就要记录到虚拟节点 // 文本节点代表的数字是3 &#125; else &#123; for(var i = 0; i&lt; realDom.childNodes.length;i++)&#123; var childNode = realDom.childNodes[i]; var vNode = createVNode(childNode) root.children.push(vNode); &#125; &#125; return root;&#125; 渲染模块 用于提取虚拟节点，将其模板编译结果设置到真实的dom中，对虚拟节点的子节点也做同样的操作 123456789101112131415import compile from \"./compile.js\";// 渲染一个虚拟节点（将文本的虚拟节点进行编译）export default function render(vnode, envObj) &#123; if (vnode.realDom.nodeType === Node.TEXT_NODE) &#123; vnode.realDom.nodeValue = compile(vnode.template, envObj); &#125; else &#123; for (var i = 0; i &lt; vnode.children.length; i++) &#123; var childNode = vnode.children[i]; render(childNode, envObj); &#125; &#125;&#125; 数据响应模块 主要负责将原始对象的数据附加到代理对象上，代理对象能够监听到数据的更改，当数据发生改变时，执行某个回调函数(就可以实现数据响应) 使用Object.defineProperty来实现数据的响应式 这里有一个关键是当代理一个对象是，发现对象里面还有属性没法代理。这时候就要重新申请一个新的代理（如下图） 123456789101112131415161718192021222324252627282930313233343536373839404142// 将原始对象的prop属性添加到代理对象中function proxyProp(originalObj, targetObj, prop, callback) &#123; if (typeof originalObj[prop] === \"object\") &#123; // 要代理的属性是一个对象,对象要单独处理 var newTarget = &#123;&#125;;//新的 要代理的对象 createResponsive(originalObj[prop], newTarget, callback); Object.defineProperty(targetObj,prop,&#123; get:function()&#123; return newTarget; &#125;, set:function(value)&#123; originalObj[prop] = value; newTarget = value; callback &amp;&amp; callback(prop); &#125; &#125;) &#125; else &#123; Object.defineProperty(targetObj, prop, &#123; get: function () &#123; return originalObj[prop]; &#125;, set: function (value) &#123; originalObj[prop] = value; callback &amp;&amp; callback(prop); &#125; &#125;) &#125;&#125;// 将原始对象的属性，提取到代理对象中// org是原始对象， target是代理对象 当代理对象被赋值的时候要调用回调函数export default function createResponsive(originalObj, targetObj, callback) &#123; for (var prop in originalObj) &#123; proxyProp(originalObj, targetObj, prop, callback); &#125;&#125; 为vue写一个构造函数12345678910111213141516171819import createVNode from './vnode.js'import createResponsive from './dataResponsive.js'import render from './render.js'export default function vue(option) &#123; this.$el = option &amp;&amp; option.el; this.$data = option &amp;&amp; option.data; this.$vnode = createVNode(document.querySelector(this.$el)) var that = this; createResponsive(this.$data, this, function () &#123; // 重新渲染 that.render(); &#125;) this.render()//初次渲染&#125;vue.prototype.render = function () &#123; render(this.$vnode, this);&#125; 在前端页面写一个简单的VUE结构 在前端页面写一个简单的VUE结构，测试一下是否正确 1234567891011121314&lt;script&gt; import Vue from \"./vue/index.js\" window.vm = new Vue(&#123; el: \"#app\", data: &#123; name:\"FengZe\", age:16, addr:&#123; province:\"广东\", city:\"佛山\" &#125; &#125; &#125;)&lt;/script&gt; 大概就是这样实现的了. 源码地址：https://github.com/FengZeHe/vue_demo","categories":[{"name":"project","slug":"project","permalink":"https://fengzehe.github.io/blog/categories/project/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"vue","slug":"vue","permalink":"https://fengzehe.github.io/blog/tags/vue/"}]},{"title":"如何实现一个简单的ofo微信小程序","slug":"ofo_demo","date":"2020-01-10T02:03:40.000Z","updated":"2020-06-29T13:23:20.000Z","comments":true,"path":"2020/01/10/ofo_demo/","link":"","permalink":"https://fengzehe.github.io/blog/2020/01/10/ofo_demo/","excerpt":"实现的效果","text":"实现的效果 实现功能简介： 扫码骑车记时功能 用户登录及充值功能 用户报障功能 思路： 要实现这些功能，首先要设置一个首页，首页里面包含所有功能按钮，包括回到当前定位，立即用车，单车报障及个人用户按钮 回到当前定位功能直接调用this.movetoCenter()函数 立即用车功能;调用扫码接口获取开锁密码与当前单车编号，完事进入开锁界面并在90秒后跳转到计费页面并开始记录用户当前开始用车时间。 不过这里需要注意的是在计费中页面，用户仍然可以切换到首页地图，再次点击扫码用车的时候直接进入计费页面。 因为切回首页是把计费页面放在后台,所以使用navtgateTo()方法，而不是使用redirectTo()方法。 单车报障功能 这里要说一嘴的是故障类型跟上传照片是必填，要验证内容是否为空。这里我只是判断了input框中的长度是否大于0； 上传照片这里调用了微信的chooseImage()接口；我使用了一个数组存储上传的照片，所以在删除的时候直接在数组干掉就好了。 用户登录及充值功能 用户登录这里要注意下微信新版本是要授权，在按钮处设置open-type 为 getUserInfo才能使用。 另外我把用户数据存进了storage,这样处理下一次就可以自动登录了。同时在登出的时候也会删除storage. 关于后台： 因为时间（技术）问题暂时没有做出来，后续版本就有了嘿。因此这次我在modeHttp在线mock了后台数据。 源码地址：https://github.com/FengZeHe/ofo_demo","categories":[{"name":"project","slug":"project","permalink":"https://fengzehe.github.io/blog/categories/project/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://fengzehe.github.io/blog/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Spring学习笔记","slug":"spring","date":"2019-12-14T12:40:13.000Z","updated":"2020-06-18T10:16:53.000Z","comments":true,"path":"2019/12/14/spring/","link":"","permalink":"https://fengzehe.github.io/blog/2019/12/14/spring/","excerpt":"Spring学习笔记框架的概念： 高度抽取可重用代码的设计 高度的通用性","text":"Spring学习笔记框架的概念： 高度抽取可重用代码的设计 高度的通用性 Spring的特点:优良特性： 非侵入式 依赖注入 面向切面编程 容器 组件化 一站式 Core Container（IOC）核心容器包含Bean Core Context expression 这几个容器 Web：Sping开发Web应用 WebSocket Servlet web protlet (建议用哪个模块就导哪个包) IOC： 控制反转;被动式的资源获取方式：资源的获取不是自己创建，而是交给容器创建和设置 DI：（Injevtion 依赖注入） 容器能知道哪个组件（类运行的时候时候需要另外一个类） 只要使用管理的组件，都能使用组件提供的强大功能。现在所有的对象交给容器创建，容器中的组件注册。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;bean id &#x3D; &quot;person03&quot; class&#x3D;&quot;com.bean.Person&quot;&gt; &lt;constructor-arg name&#x3D;&quot;lastName&quot; value&#x3D;&quot;小明&quot;&gt;&lt;&#x2F;constructor-arg&gt; &lt;constructor-arg name&#x3D;&quot;email&quot; value&#x3D;&quot;skjdhfkjsdfhkd@126.com&quot;&gt;&lt;&#x2F;constructor-arg&gt; &lt;constructor-arg name&#x3D;&quot;gender&quot; value&#x3D;&quot;男&quot;&gt;&lt;&#x2F;constructor-arg&gt; &lt;constructor-arg name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;constructor-arg&gt; &lt;&#x2F;bean&gt; &#x2F;&#x2F;有参构造器 &lt;constructor-arg&gt;就代表一个属性 &lt;bean id&#x3D;&quot;person01&quot; class&#x3D;&quot;com.bean.Person&quot;&gt; &lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;he&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;age&quot; value &#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;hzf@666.com&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;man&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &#x2F;&#x2F;通过无参构造器 &#x2F;&#x2F;如果省略name参数 就要严格按照构造器参数的位置 &#x2F;&#x2F;在重载的情况下 type可以指定参数的类型 &#x2F;&#x2F;名称空间：在xml中名称空间是用来防止标签重复的 &lt;book&gt; &lt;b:name&gt;西游记&lt;&#x2F;name&gt; &lt;author&gt; &lt;a:name&gt;吴承恩&lt;&#x2F;name&gt; &lt;&#x2F;author&gt; &lt;&#x2F;book&gt; 通过标签的前缀，就可以知道name是指哪个name xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot; &lt;property name&#x3D;&quot;lastName&quot;&gt; &lt;&#x2F;null&gt; &#x2F;&#x2F;进行复杂的赋值，在property标签里面 &lt;&#x2F;property&gt; &#x2F;&#x2F;如果把多个属性赋值给一个对象呢 &lt;bean id &#x3D;&quot;car01&quot; class&#x3D;&quot;com.bean.Car&quot;&gt; &lt;property name&#x3D;&quot;carName&quot; value&#x3D;&quot;宝马&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;color&quot; value&#x3D;&quot;pink&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;price&quot; value&#x3D;&quot;30000&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;property name&#x3D;&quot;car&quot; ref&#x3D;&quot;car01&quot;&gt;&lt;&#x2F;property&gt; &#x2F;&#x2F;在person01的容器中加入这段代码就ok &#x2F;&#x2F;在bean里面写property写是引用外部bean， 在property里面写bean是引用内部bean Spring在为各种属性赋值： 在bean使用ref写是引用外部bean， 在property里面写bean是引用内部bean 在对list属性进行赋值，写在property里面，同时也可以使用ref引用外部赋值 在对map属性进行赋值，在property键值对里面&lt;entry&gt;标签，在标签内使用key value进行键值对的赋值。 util名称空间创建集合类型的bean 方便别人引用123&lt;util:map id&#x3D;&quot;myMap&quot;&gt;&#x2F;&#x2F;一定要有Id &#x2F;&#x2F;里面写的直接是元素&lt;&#x2F;util:map&gt; 级联属性赋值：就是属性的属性 通过继承实现bean配置信息的重用 123456789101112&lt;bean id&#x3D;&quot;parent05&quot; class&#x3D;&quot;com.bean.Person&quot;&gt; &lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;男&quot;&gt;&lt;&#x2F;property&gt; &lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;akshdajsk&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;bean id&#x3D;&quot;person06&quot; class&#x3D;&quot;com.bean.Person&quot; parent&#x3D;&quot;parent05&quot;&gt; &lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;fengZe&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &#x2F;&#x2F;abstract&#x3D;&quot;true&quot;,这个Bean的配置是一个抽象的，不能获取他的实例，只能被别人用来继承 bean之间的依赖（只是改变创建顺序）如果在创建之前写入 depends-on=‘book,person“，那么就会先创建book 还有person。 通过静态工厂方法创建bean，实例工厂方法创建beanbean的创建默认就是框架利用反射new出来的bean实例，工厂模式就是有一个类帮你去创建对象 静态工厂：工厂本身不用创建对象：通过静态方法调用 对象 = 工厂类.工厂方法名（） 实例工厂：工厂本身需要创建对象： 工厂类 工厂对象 = new 工厂类（）；工厂对象.getAirplane 123factory-method：指定工厂方法class:指定静态工厂全类名&lt;constructor-arg value&#x3D;&quot;李四&quot;&gt;&lt;&#x2F;constructor-arg&gt;传参 实例工厂 先配出实例工厂对象 配置我们需要创建的airPlane使用哪个工厂创建 facotry-bean ：指定使用哪个工厂实例 factory-method：使用哪个工厂方法 FactoryBean（是Spring规定的一个接口);只要是这个接口的实现类，Spring都认为是一个工厂，ioc容器启动的时候就不会创建实例 bean的生命周期 ioc容器中注册的bean： 单例bean ，容器启动的时候才会创建好，容器关闭也会销毁创建的bean 多例bean，获取的时候才会创建 引用外部属性文件: 数据库连接池作为单实例是最好的，一个项目就一个连接池，连接池里面管理很多连接。连接直接从连接里拿，可以让spring 帮我们创建连接池对象。 依赖context名称空间，可以加载外部配置文件 自动装配（自动赋值） autowire= “default” ，可以填byName ,byType, constructor,no。 例如说byName，按照名字，以属性名作为id去容器里找到这个组件，给他赋值。如果找不到就装配null Spring有四种注解： @Controller 控制器 @Service 业务逻辑 @Respository 数据库（持久化层） @Component 注意：某个类上添加任何一个注解都能快速的将这个组件加入ioc容器的管理 添加步骤： 加入注释:告诉Spring，自动扫描加注释，依赖名称空间 –context:component-scanbase.package:” “填入需要扫描的包，至少填两级目录 在ioc获取bean的过程中，id是默认是类名的首字母小写， 也可以在注释后加入()来修改名字","categories":[{"name":"back-end","slug":"back-end","permalink":"https://fengzehe.github.io/blog/categories/back-end/"}],"tags":[{"name":"后端技术","slug":"后端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"}]},{"title":"用CSS3做LoadIng动画","slug":"frontEnd_Loading","date":"2019-12-12T06:47:13.000Z","updated":"2020-06-12T01:45:48.000Z","comments":true,"path":"2019/12/12/frontEnd_Loading/","link":"","permalink":"https://fengzehe.github.io/blog/2019/12/12/frontEnd_Loading/","excerpt":"","text":"使用CSS3做Loading动画","categories":[],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"CSS3","slug":"CSS3","permalink":"https://fengzehe.github.io/blog/tags/CSS3/"}]},{"title":"vue学习笔记","slug":"vue","date":"2019-10-02T01:03:25.000Z","updated":"2020-06-18T10:17:03.000Z","comments":true,"path":"2019/10/02/vue/","link":"","permalink":"https://fengzehe.github.io/blog/2019/10/02/vue/","excerpt":"vue学习笔记概念：Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现在话的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。","text":"vue学习笔记概念：Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现在话的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 vue的特点： 渐进式：vue的侵入性很少，可以与很多其他前端技术联用 组件化 响应式：数据响应式，vue会监控数据变化。当数据变化时 vue的核心功能：关于创建vue工程 直接在页面上引用vue.js 使用构建工具vue-cli脚手架 vue实例vue实例：通过new vue（配置对象）得到的对象 当创建vue实例的时候，vue将会把data（为了实现响应式）methods配置（为了在模板中方便使用）等配置成员提升到vue实例中. 由于有提升的存在，为了防止命名冲突，vue会将自身的成员名称前加上$ 或 _ , 为了防止命名冲突，vue会将自身的成员加上$(可以使用),_符号就不用用了 模板插值：在模板的元素内部使用指令：通常作为元素的属性存在，名称上以v- 开头v-for:用于循环生成元素v-on :用于注册事件。 语法糖@v-if :用于判断该玄素是否可以生成,可以与v-else 或者v-else-if联用v-show:元素已经显示,display:nonev-bind:用于绑定属性, 语法糖:v-model：用于事件双向绑定，实际上是自动绑定用了value值,和注册了input事件 模板中的配置 页面中直接书写 在template配置中书写（常见） 在render中手动配置用函数创建，render函数的参数是一个创建虚拟DOM对象，为什么要创建虚拟DOM,因为真实DOM操作特别慢 配置对象 template:字符串，配置模板 el:配置控制的元素，css选择器 data: 管理的数据，该数据是响应式的 mothods:配置方法，方法中的this指向vue实例，不能会用箭头函数,会干扰vue绑定this挂在的配置 通过el进行配置 使用vue实例中的$mount函数进行配置 关于computed –计算属性 计算属性，其中的配置会提升到vue实例中，因为在模板中可以直接当做属性使用，使用时，实际上调用的是对应的方法。通常，计算属性用户通过data或其他计算属性得到的数据。 与方法的区别：vue会检查计算属性的依赖，当依赖没有发生变化时，vue会直接使用之前缓存的结果，而不会重新计算 能用计算属性尽量使用，因为效率很高。依赖不变时不会重新加载。（计算属性的读取函数不可以有参数，有参数没意义） 计算属性可以配置get和set. 分别用于读取时和设置时。 get读取属性的时候可以监听到，然后检查那张表函数有没有变化。 关于v-html指令： vue为了安全，会将元素内部的插值进行实体编码 12345678910&lt;div v-html &#x3D; &quot;html&quot;&gt;&lt;&#x2F;div&gt;config &#x3D; &#123; data:&#123; html:&lt;p&gt;带标签的元素&lt;&#x2F;p&gt; &#125;&#125;&#x2F;&#x2F;这样就可以把html标签渲染出来了 组件组件是页面中可复用的功能单元 VUE中的组建 组件的创建：组件对于开发者，是一个普通的配置对象 组件的注册：1234567891011121314&#x2F;&#x2F;全局注册组件Vue.component(&quot;组件形成&quot;,pager)&#x2F;&#x2F;局部注册组件 在使用的组件和vue实例配置中进行注册const config &#x3D; &#123; template:&#96;&lt;div&gt; &lt;MyPager&gt;&lt;&#x2F;MyPager&gt; &lt;&#x2F;div&gt;&#96;, el:&quot;#app&quot;, components:&#123; MyPager :pager &#125;&#125; 组件名称的规范，以下命名的方式任选其一： 使用短横线命名 使用大驼峰命名组件的使用：把组件当成标签使用即可，标签名任选其一 短横线命名 大驼峰命名 组件可以嵌套，因为会形成一个组件树，组件树的根叫做根组件 组件中的数据通信： prevent修饰符用于v-on指令，表示阻止默认行为 stop修饰符用于v-on指令，表示阻止事件冒泡 组件的状态和属性： 通常讲组件中需要自身管理的数据（组件配置中的data）叫做组件状态（component state），组件状态只能在组件内部使用，外部原则上不可以使用. data(state 状态)在组件中的配置和在vue实例中配置的区别：在组件中data必须是一个函数，而VUE实例中心必须是一个对象。因为组件是可以被复用的，每一个组件都是独立的，所以data必须是一个函数. 123456789&#x2F;&#x2F;在组件中export default&#123; template, data()&#123; return &#123; &#x2F;&#x2F;返回的结果是组件的状态 &#125; &#125;&#125; 组件中可以有属性（component props），而vue实例中没有 声明组件属性时，使用短横线或小驼峰命名法 传递组件属性时，使用短横线或小驼峰命名法 属性会被提升到vue组件实例中 ==组件的属性时只读的，不允许更改，根本原因是要保证单向数据流== 自定义事件： 在组件中触发事件： this.$emit(“事件名”,事件参数…) 当一个组件状态发生变化时，该组件会重新渲染，在渲染的过程中，可能会导致其子组件的属性发生变化，而属性的变化会导致组件重新渲染。但根本原因，是状态的变化. v-model 的本质是一个语法糖，实际上是绑定value属性，同时监听input事件 组件的生命周期 beforeCreate(){} –&gt;这个是自动执行的 created() –&gt;组件实例中已经提升到实例总，但是没有渲染页面 beforeMount –&gt; 组件即将进行渲染，但还没有渲染，此时已经编译好模板 mounted【常用】 –&gt;组件已经完成渲染（页面可见） beforeUpdate –&gt;组件即将更新，还没有更新，此时得到的数据是新的，但页面依旧是旧的 updated –&gt; 数据，界面都是新的 beforeDestory –&gt; 当组件即将被销毁 调用vm.$destroy()函数 destoryed –&gt; 解除绑定，销毁子组件以及事件监听器 vue路由vue路由，可以简单理解为，当访问某个地址时，渲染某个组件 使用路由 根据一个配置对象创建路由，得到路由对象 在创建vue实例时，将路由对象配置到实例配置的router中 在合适的位置写上router-view组件，表示路由匹配到组件渲染的位置，它实际上是vue-router做好的一个组件，并且做好了全局注册 路由配置对象 routes:路由规则配置 mode:配置模式 hash模式，兼容性最好，地址出现#号后，切换地址不会导致页面刷新 history模式，使用的是HTML5 history API，地址直接变化，并且页面不刷新","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}]},{"title":"2019-09-03 实习笔记","slug":"2019.09.03","date":"2019-09-03T14:58:13.000Z","updated":"2020-06-18T10:17:14.000Z","comments":true,"path":"2019/09/03/2019.09.03/","link":"","permalink":"https://fengzehe.github.io/blog/2019/09/03/2019.09.03/","excerpt":"背景： 今天刷面试题的时候，遇到一个问题——如何判断一段字符串里面出现最多的字符以及出现次数。 思路 利用javascript对象的属性特征，可以实现每个字符与出现次数的绑定 通过遍历和累加，计算得出每个字符出现的次数 通过对比出现的次数，返回出现次数最多的字符","text":"背景： 今天刷面试题的时候，遇到一个问题——如何判断一段字符串里面出现最多的字符以及出现次数。 思路 利用javascript对象的属性特征，可以实现每个字符与出现次数的绑定 通过遍历和累加，计算得出每个字符出现的次数 通过对比出现的次数，返回出现次数最多的字符 12345678910111213141516171819202122232425262728293031323334353637const str &#x3D; &#39;asddfgdfwwqeweqwezczxcsdfgdgd&#39;; var obj &#x3D; &#123;&#125;; var max &#x3D; 0; var maxStr &#x3D; &quot;&quot;; for(let i &#x3D; 0; i &lt; str.length ; i++)&#123; var word &#x3D; str.charAt(i); if(obj[word] !&#x3D; null)&#123; obj[word]++; &#125;else&#123; obj[word] &#x3D; 1 &#125; for(let i in obj)&#123; if(obj[i]&gt;max)&#123; max &#x3D; obj[i]; maxStr &#x3D; i &#125; &#125; &#125; console.log(&#39;出现最多次:&#39; + max +&#39;的字符是：&#39;+ maxStr) console.log(obj); &#x2F;&#x2F; &#123;a: 1, s: 2, d: 6, f: 3, g: 3, …&#125; &#x2F;&#x2F; a: 1 &#x2F;&#x2F; c: 2 &#x2F;&#x2F; d: 6 &#x2F;&#x2F; e: 3 &#x2F;&#x2F; f: 3 &#x2F;&#x2F; g: 3 &#x2F;&#x2F; q: 2 &#x2F;&#x2F; s: 2 &#x2F;&#x2F; w: 4 &#x2F;&#x2F; x: 1 &#x2F;&#x2F; z: 2 &#x2F;&#x2F; __proto__: Object","categories":[],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}]},{"title":"HTML5学习笔记","slug":"HTML5-note","date":"2019-09-02T01:03:25.000Z","updated":"2020-06-18T10:16:29.000Z","comments":true,"path":"2019/09/02/HTML5-note/","link":"","permalink":"https://fengzehe.github.io/blog/2019/09/02/HTML5-note/","excerpt":"HTML5学习笔记Canvas 画布Canvas应用场景： 游戏 图表 动画 condepen.io（HTML5动效）","text":"HTML5学习笔记Canvas 画布Canvas应用场景： 游戏 图表 动画 condepen.io（HTML5动效） Canvas 发展史 最早在apple Safari1.3中引入，ie9之前的浏览器不支持canvas 如何使用canvas添加canvas标签1234567&lt;canvas width &#x3D; 500 height &#x3D; 500&gt;&lt;&#x2F;canvas&gt;获取cancas元素var canvas &#x3D; document.getElementById(&#39;myCanvas&#39;)获取canvas上下文对象var ctx &#x3D; camvas.getContext(&#39;2d&#39;); 如何画线段123456ctx.moveTo(x,y) 移动到x,y坐标点ctx.lineTo(x,y) 从当前点描绘直线到x,y点ctx.stroke();描边ctx.lineWidth &#x3D; 20 设置线条宽度ctx.closePath(); 闭合当前路径ctx.fill() 填充 fill和stroke方法都是作用在当前的所有子路径 完成一条路径后重新开始另一条路径时必须使用beginPath()开始子路径的一个新集合 如何使用Canvas画矩阵123ctx.rect(x, y,dx,dy)ctx.fillRect(x,y ,dx,dy)ctx.strockeRect(x, y ,w, h) 如何擦除当前区域： ctx.clearRect 如何画圆角：12345678ctx.arcTo(x1,y1,x2,y2,r)&#x2F;&#x2F;绘制的弧线与当前点和x1,y1连线，x1,y1和x2,y2连线都相切贝塞尔曲线：quadraticCureveTo(x1 ,x2,ex,ey) 二次贝塞尔曲线 x1,y1控制点，ex,ey结束点bezierCureveTo(x1,y1,x2,y2,ex,ey) 三次贝塞尔曲线x1 y1 x2 y2 控制点ex ey结束点 坐标轴的抓换12345678tanslate(dx,dy) 重新映射到画板上的（0,0）位置scale(sx,sy) 缩放当前绘图rotate(Math.PI) 旋转当前的绘图save() restore()保存当前图像状态的一份拷贝从栈中弹出存储的图形状态并恢复setTransform(a,b,c,d,e,f)transform(a,b,c,d,e,f) &#x2F;&#x2F;在之前的基础上变换 渐变 createLinearGradubt(x1,y1,x2,y2);线性渐变，必须在填充渐变区域里定义渐变，否则没有效果 createRadialGradient(x1, y1, r1, x2, y2, r2); 径向渐变bg.addColorStop(p.color) 阴影：1234ctx.shadowColorctx.shadowOffsetXctx.shadowOffsetYctx.shadowBlur 文本： fillText(); strokeText(); measureText(‘helloworld’） 线段样式 lineCap lineJoion 绘制图片：12ctx.drawImage();&#x2F;&#x2F;第一个参数是img(Image,canvas,video) 将canvas内容导出 canvas.toDataURL(); 是canvas自身方法不是上下文对象 将canvas的内容抽取成一张照片，base64编码格式（注意同源策略） 将canvas内容放进img元素里 获取canvas像素信息123ctx.getImageData(x,y,dx,dy)crx.createImageData(w,h) 创建新的空白ImageData对象ctx.putImageData(imgData,x,y) 将图像数据放回画布上 SVG（Scalable Vector Graphics）可缩放适量图形 SVG应用场景: 图表 图标icon 动效 矢量图 使用svg画各种各样的图形：123456789101112131415161. 直线&lt;line x1&#x3D;&quot;100&quot; y1&#x3D;&quot;100&quot; x2&#x3D;&quot;200&quot; y2&#x3D;”100”&gt;&lt;&#x2F;line&gt;2. 矩形&lt;rect x&#x3D;&quot;50&quot; y&#x3D;&quot;50&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;100&quot; rx&#x3D;&quot;10&quot;ry&#x3D;&quot;20&quot;&gt;&lt;&#x2F;rect&gt;3. 圆形&lt;circle r&#x3D;&quot;50&quot; cx&#x3D;&quot;220&quot; cy&#x3D;&quot;100&quot;&gt;&lt;&#x2F;circle&gt;4. 椭圆&lt;ellipse rx&#x3D;&quot;100&quot; ry&#x3D;&quot;50&quot; cx&#x3D;&quot;100&quot; cy&#x3D;&quot;200&quot;&gt;&lt;&#x2F;ellipse&gt;5. 折线&lt;polyline points&#x3D;&quot;60 50, 75 35, 100 50, 125 35, 150 50,175 35, 190 50&quot;&gt;&lt;&#x2F;polyline&gt;6. 多边形&lt;polygon points&#x3D;&quot;125 125,130 140,120 140&quot;&gt;&lt;&#x2F;polygon&gt;7. ⽂本&lt;text x&#x3D;&quot;125&quot; y&#x3D;&quot;220&quot;&gt;hello,world&lt;&#x2F;text&gt; path指令：（大写代表绝对定位，小写表示相对定位）12345678910M &#x3D; movetoL &#x3D; linetoH &#x3D; horizontal lineto 水平线V &#x3D; vertical lineto 垂直线C &#x3D; curveto 曲线S &#x3D; smooth curveto 平滑的曲线Q &#x3D; quadratic Belzier curve 二次贝塞尔曲线T &#x3D; smooth quadratic Belzier curveto 光滑贝塞尔曲线A &#x3D; elliptical Arc 椭圆弧Z &#x3D; closepath SVG渐变 线性渐变 径向渐变 HTML5动画api requestAnimationFrame 页面刷新钱执行一次 1000ms 60fps -&gt; 16ms cancelAnimationFrame 用法和setTimeout类似 兼容性(只在IE10以上的浏览器)用老浏览器就用setTimeout 123456789101112131415161718window.requestAnimFrame &#x3D; (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function( callback )&#123; window.setTimeout(callback, 1000 &#x2F; 60); &#125;;&#125;)();&#x2F;&#x2F;cancelAnimFrame()window.cancelAnimFrame &#x3D; (function()&#123; return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function( id)&#123; window.clearTimeout(id); &#125;;&#125;)(); 客户端存储 Storage localstorage (永久的) sessionstorage(关闭浏览器就没有了) cookie（存储容量很小，4K左右） 如何使用storage存储和读取数据12345localStorage.name &#x3D; &#39;admin&#39; &#x2F;&#x2F;存字符串localStorage.info &#x3D; JSON.stringify(&#123;name:&#39;admin&#39;，company:&#39;jizhu&#39;&#125;) &#x2F;&#x2F;存对象 var info &#x3D; JSON.parse(localStorage.obj);&#x2F;&#x2F;取出数据 console.log(info); storage作用域 localSotrage -&gt; 文档源限制 sessionStorage -&gt; 文档源显示 + 窗口 storage 的API setItem(name,val) 设置属性值 getItem(name) 获得属性值 removeItem(name) 移除属性 clear() 清除属性 cookie 存储信息到用户的设备上，数据量比较小 navigator.cookieEnable 监测是否开启了cookie 设置cookie值12345678910111213141516document.cookie &#x3D; “name&#x3D;aimee”&#x2F;&#x2F;（每次只能设置一个值，因为浏览器会认为后面的键值对是这个cookie的属性）document.cookie &#x3D; “name&#x3D;aimee”&#x2F;&#x2F;（每次只能设置一个值，因为浏览器会认为后面的键值对是这个cookie的属性）function getCookie(name) &#123; var name &#x3D; name + &quot;&#x3D;&quot;; var ca &#x3D; document.cookie.split(&#39;;&#39;); for(var i&#x3D;0; i&lt;ca.length; i++) &#123; var c &#x3D; ca[i]; while (c.charAt(0)&#x3D;&#x3D;&#39; &#39;) c &#x3D; c.substring(1); if (c.indexOf(name) !&#x3D; -1) return c.substring(name.length, c.length); &#125; return &quot;&quot;;&#125; cookie 与 storage的对比 history history.back(); history.forward(); history.go(n) 通过修改hash和hashchange事件来实现历史纪录管理12345&#x2F;&#x2F;1、pushStatehistory.pushState(state, title, url); &#x2F;&#x2F;添加一条历史记录&#x2F;&#x2F;2、replaceStatehistory.replaceState(state, title, url);&#x2F;&#x2F; 替换当前的历史记录 worker(异步操作的api)12var worker &#x3D; new Worker(&#39;workder.js&#39;)&#x2F;&#x2F;https:&#x2F;&#x2F;www.w3school.com.cn&#x2F;html5&#x2F;html_5_webworkers.asp geolocation getCurrentPosition() //获取当前的位置信息 getCurrentPosition(s,e,p) success 回调 必须的 error 回调 option 参数 watchPosition() //监视位置变化, 和1参数一样 clearWatch() //清除位置监视 1window.navigator.geolocation.getCurrentPosition(suc) PositionError对象 用户拒绝code = 1; 获取不到 code = 2; 连接超时 code = 3; 配置参数enableHighAccuracy 是否需要高精度位置默认falsetimeout 单位ms 请求超时时间 默认infinitymaximumAge 单位ms，位置信息过期时间 设置为0就无条件获取新的地理位置信息 默认0https://dev.w3.org/geo/api/spec-source.html#position_options_interface watchPosition12var id &#x3D; geolocation.watchPostion() &#x2F;&#x2F;用于注册监听器，在设备的地理位置发生个改变的时候自动被调用clearWatch(id) &#x2F;&#x2F;使用clearWatch 清除监听 devicemotion事件所包含的属性 accelerationIncludingGravity （包括重心引力）重力加速度 acceleration 重力加速度（需要陀螺仪支持） rotationRate(alpha, beta, gamma)旋转速率 interval // 获取的时间间隔均为只读属性 多媒体： audio 音频 video 视频12345678&lt;audio src&#x3D; &quot;.&#x2F;demo.mp3&quot; controls &#x3D; &gt;&lt;&#x2F;audio&gt;autoplay &#x2F;&#x2F;自动播放控件controls &#x2F;&#x2F;设置控件preload(none&#x2F;metadata&#x2F;auto)预加载metadata :元数据 诸如时长、比特率、帧大小这样的原数据而不是媒体内容需要加载的loop： 是否循环播放音频or视频poster:(video独有)，当视频不可用的时候，使用一张图片替代 多类型选择器：1234&lt;audio id&#x3D;&quot;music&quot;&gt; &lt;source src&#x3D;&quot;成都.mp3&quot; type&#x3D;&quot;audio&#x2F;mpeg&quot;&gt; &#x2F;&#x2F;如果没有第一个，就播放第二个 &lt;source src&#x3D;&quot;成都.ogg&quot; type&#x3D;&#39;audio&#x2F;ogg&quot;&#39;&gt; &lt;&#x2F;audio&gt; 脚本化：12345var audio &#x3D; document.getElementById(&#39;audio&#39;);var audio &#x3D; new Audio(&#39;.&#x2F;laojie.mp3&#39;);var audio &#x3D; document.createElement(&#39;video&#39;); 播放的方法 play() 方法 pause() 方法 //用于暂停 load()方法 用于重新加载视频/音频元素 表示播放音量，介于0(静音)~1(最大音量)之间，默认1。将muted属性设置为true则会进入静音模式，设置为false则会恢复之前指定的音量继续播放。超过范围会报错[0, 1] 播放速率playbackRate：用于指定媒体播放的速度。该属性值为1.0表示正常播放，大于1则表示快进，0-1之间表示慢放，负值表示回放。 currentTime/duration 属性 currentTime设置或返回音频视频的当前位置 duration 返回当前音频/视频的时常12345678910audio.currentTime &#x3D; 50;button.addEventLidtener(&#39;clkick&#39;,function()&#123; consoloe.log(audio.currentTime) &#125;)window.onload &#x3D; function(&#123; console.log(audio.duration);&#125;) played/buffered/seekable played属性返回已经播放(看过)的时间段，buffered属性返回当前已经缓冲的时间段，seekable属性则返回用户可以跳转的时间段。这三个属性都是TimeRanges对象，每个对象都有一个length属性以及start()和end()方法，length属性表示当前的一个时间段，start()与end()分别返回当前时间段的起始时间点和结束时间点(单位是秒，起始参数是0) paused/seeking/ended这三个属性用来查询媒体播放状态，paused为true表示播放器暂停。seeking为true表示播放器正在调到一个新的播放点，如果播放器播放完媒体并且停下来，则ended属性为true。 canPlayType()方法12345var a &#x3D; new Audio();if(a.canPlayType(&quot;audio&#x2F;mp3&quot;))&#123; a.src &#x3D; &quot;.&#x2F;chengdu.mp3&quot;; a.play();&#125; 事件 play 开始播放触发 pause 暂停触发 loadedmetadata 浏览器获取完媒体的元数据触发 loadedata 浏览器已经加载完当前帧数据，准备播放时触发，注意兼容IE8 ended 当前播放结束后触发 readyState属性音频的当前就绪状态 drap ＆ drop(常用语各种拖动操作中)创建可拖动元素1&lt;div id&#x3D;&quot;abc&quot; draggable&#x3D;&quot;true&quot;&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F;使用draggable之后就能够拖拽元素了关于拖拽的相关事件： dragstart 被拖拽元素 开始被拖拽时触发 e.dataTransfer.setData(“data”,e.target.id) dragend 被拖拽元素 拖拽完成时 dragenter 目标元素 拖曳元素进入目标元素 dragover 目标元素 拖拽元素在目标元素上移动 drop 目标元素 被拖拽的元素在目标元素上同时鼠标放开触发的事件 e.dataTransfer.getData(“data”)需要阻止dragover的默认行为才会触发drop事件123456789101112131415161718192021 &lt;script&gt; var item &#x3D; document.getElementById(&quot;abc&quot;); item.addEventListener(&#39;dragstart&#39;,function()&#123; console.log(&quot;akshd&quot;) &#125;) var itemO &#x3D; document.getElementById(&quot;wrapper&quot;); itemO.addEventListener(&#39;dragenter&#39;,function()&#123; console.log(&#39;dragenter&#39;) &#125;)&#x2F;&#x2F;这个是写在被进入的元素里面 &lt;&#x2F;script&gt;DragEvent 事件对象&#x2F;&#x2F;传值e.dataTranSfer.setData(&quot;data&quot;,e.target.id)&#x2F;&#x2F;取值 e.dataTransfer.getData(&quot;data&quot;) FileReader 读取文件 abrot() 终止读取 readAsBinaryString(file) 将文件读取为二进制编码 readAsDataURL(file) 将文件读取为DataURL编码 readAsText(file,[encoding]) 将文件读取为文本 readAsArrayBuffer(file) 将文本读取为arraybuffer 通过不同的方式读取文件 FileReader 事件 onloadstart 读取开始时触发 onprogress 读取中 onloadend 读取完成，无论成功或失败 onload 文件读取成功完成时触发 onabort 中断时触发 onerror 出错时触发1234获取读取的结果fr.onload &#x3D; function()&#123; tihs.result;&#125; Web Socket（是一个新的协议） WebSocket 对象提供了一组 API，用于创建和管理 WebSocket 连接,​​​​​​​以及通过连接发送和接收数据.Websocket 其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已.借用了HTTP的协议来完成握手 产生背景： 在 HTTP/1.0 中,大多实现为每个请求/响应交换使用新的连接 在 HTTP/1.1 中,一个连接可用于一次或多次请求/响应交换 HTTP协议中，服务端不能主动联系客户端，只能有客户端发起。 webSoket服务器和客户端均可主动发送数据 建立连接的握手： 当Web应用程序调用new WebSocket(url)接口时，Browser就开始了与地址为url的WebServer建立握手连接的过程。 Browser与WebSocket服务器通过TCP握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用程序将收到错误消息通知。 在TCP建立连接成功后，Browser通过http协议传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端。 WebSocket服务器收到Browser发送来的请求后，如果数据包数据和格式正确，客户端和服务器端的协议版本号匹配等等，就接受本次握手连接，并给出相应的数据回复，同样回复的数据包也是采用http协议传输。 Browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发onopen消息，此时Web开发者就可以在此时通过send接口向服务器发送数据。否则，握手连接失败，Web应用程序会收到onerror消息，并且能知道连接失败的原因。 12创建webSocketvar Socket &#x3D; new WebSocket(url) webSocket方法12Socket.send() 方法使用连接传输数据socket.close() 方法用于终止任何现有连接 webSocket的优点 客户端与服务器都可以主动传递数据给对方 不用频率创建TCP请求及销毁请求，减少网络带宽资源的占用，同时也节省服务器资源","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}]},{"title":"ES6","slug":"ES6","date":"2019-08-12T13:10:57.000Z","updated":"2020-06-18T10:18:21.000Z","comments":true,"path":"2019/08/12/ES6/","link":"","permalink":"https://fengzehe.github.io/blog/2019/08/12/ES6/","excerpt":"ES6学习笔记","text":"ES6学习笔记 ES6语法的一个特性块级作用域：{ } LET命令 LET声明的变量具有块级作用域的概念12345678&#123; console.log(typeof a)&#x2F;&#x2F;Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization let a &#x3D; 42; var b &#x3D; 1212; console.log(typeof a) &#x2F;&#x2F;number&#125; console.log(typeof a) &#x2F;&#x2F;underfind 不存在变量提升。在Let声明之前使用就会报错 暂时性死区：只要块级作用域内存在let命令，它所在的变量就“绑定”这个区域，不再受外部的影响 不允许重复声明 注意：因为let的不存在变量提升和暂时性死区，因此在let之前使用该变量会报错，在此变量作用域外使用会无效。 const命令1. const声明一个只读常量，一旦声明，常量的值就不能更改 2. const变量只声明不赋值就会报错 3. 只在作用域内生效以及不允许重复声明 4. const变量不能更改的实质是变量指向的那个内存地址所保存的数据不得改动.12345678910111213141516171819202122 const foo &#x3D; &#123;&#125;; foo.prop &#x3D; 123;&#x2F;&#x2F;添加一个属性，没有问题 console.log(foo.prop) foo&#x3D; 123;&#x2F;&#x2F;就会报错&#x2F;&#x2F; 浏览器的 ES6 环境function f() &#123; console.log(&#39;I am outside!&#39;); &#125;(function () &#123; if (false) &#123; &#x2F;&#x2F; 重复声明一次函数f function f() &#123; console.log(&#39;I am inside!&#39;); &#125; &#125; f();&#125;());&#x2F;&#x2F;上面在ES6代码当中会报错，ES6规定，浏览器始兴县要遵循一些规定&#x2F;&#x2F;1.允许在块级作用于内声明函数&#x2F;&#x2F;2.函数声明类似于var ,即会提升到全局作用于函数作用于的头部&#x2F;&#x2F;3.同时，函数声明还会提升到所在的块级作用于的头部注意：以上三条规则只对ES6浏览器内有效，其他环境还是将块级作用于的函数声明当做let处理 注意：在ES6中一共有6种赋值的方式，有var 和 function 命令，还有let 和const命令，以及import和class命令。var 和 function 命令声明的全局变量是顶层对象的属性；let、const和class命令声明全局变量，不属于顶层对象的属性。 变量的解构赋值 数组的解构赋值 概念：ES6允许按照一定的模式，从数组和对象中提取，对变量进行赋值注意：要是被赋值一边有一项没有被赋值或者赋值underfind，则被称为解构失败；要是赋值一边有三个值，被赋值一边只有两个变量，则被称为不完全解构 匹配模式其实是懒散匹配，如第6行代码，如果赋值一方对应位置有值，x就不会管默认值是10,而当赋值一边【】啥都没有的时候，才取默认值123456789101112131415161718192021222324252627&#x2F;&#x2F;模式匹配let [a , b, c] &#x3D; [1, 2, 3]let [a ,[b,[c]]] &#x3D; [1,[2,[3]]]let [x &#x3D; 10] &#x3D;[20] &#x2F;&#x2F;x &#x3D; 20对象的解构赋值无序性：只要变量与属性同名，就能取到正确的值。当右边没有同名的属性，那么不叫取不到值而取得underfindlet &#123;bar ,foo &#125; &#x3D; &#123;foo :234, bar:123&#125;&#x2F;&#x2F;无论赋值的一方的顺序是怎么样的，赋值都不影响let &#123;foo:bar&#125; &#x3D; &#123;foo:123&#125; console.log(bar);&#x2F;&#x2F;123 console.log(foo);&#x2F;&#x2F; foo is not defined let&#123;length&#125; &#x3D; &quot;123&quot; &#x2F;&#x2F;length &#x3D; 3 &#x2F;&#x2F;可用于嵌套let obj &#x3D; &#123; p: [ &#39;abcabc&#39;, &#123; y: &#39;123123&#39; &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; &#x3D; obj;&#x2F;&#x2F;&#39;abcabc&#39; &#39;123123&#39; 字符串的解构赋值123456789const [a,b,c,d,e] &#x3D; &#39;hello&#39;; console.log(a); console.log(b); console.log(d); let&#123; length :len&#125; &#x3D; &#39;hello&#39; console.log(len)&#x2F;&#x2F; a b l 5 数值和布尔值的解构赋值1234567解构赋值时，如果等号右边是数值和布尔值，则会先转换成对象函数参数的解构赋值 function add([x,y])&#123; return x + y; &#125; add([1,2]) 不能使用圆括号的情况：使用场景： 交换变量的值 从函数返回多个值 123456function example()&#123; return [1,2,3];&#125;let [a,b,c] &#x3D; example();console.log(a,b,c) &#x2F;&#x2F;1 2 3 提取JSON数据–解构赋值对提取JSON对象中的数据，尤其有用 便利Map结构：部署了Iterator接口的对象，都可以用for…of循环遍历。配合变量的解构赋值，获取键名和键值就肥肠方便 字符串的扩展 字符串的遍历器接口 123456a &#x3D; &#96;hzfnb&#96;;for(let condePoint of a )&#123; console.log(condePoint)&#125;&#x2F;&#x2F; h z f n b 模板字符串 增强字符串:可以保留字符串在编辑器的模式 ，如果代码中的模板字符串都要用反引号表示，则前面需要用反斜杠转义 在字符串中添加变量（表达式） 赋值 ${}对变量进行抓取 ${} 对变量进行运算 12345678910111213141516171819202122232425262728var str &#x3D; &#39;hello&#39;;var newStr &#x3D; &#96;hello world&#96;; var xm &#x3D; &#123; age :19, height:180, name :&#39;xiaoming&#39; &#125; var &#123;age ,name, height&#125; &#x3D; xm; var newstr &#x3D;&#96;name: $&#123;name&#125; age: $&#123;age&#125; &#96; console.log(newstr);&#x2F;&#x2F;通过对象的解构拿到对象的值， 再通过$&#123;&#125;直接取得这个值 &#x2F;&#x2F;$&#123;&#125;也是可以进行运算的，还可以添加方法 var x &#x3D; 3, y &#x3D; 5; function getName()&#123; return &#39;xiaoming&#39;; &#125; var str &#x3D; &#96;my name is $&#123;getName()&#125;&#96;; console.log(str); var arr &#x3D; [1,2,3,4,5]; var resStr &#x3D;&#96;$&#123;arr.map(function(item,index)&#123; return &#96;$&#123;item&#125;: $&#123;index&#125;&#96; &#125;)&#125;&#96;&#x2F;&#x2F;通过增强字符串与函数把值赋给另外一个变量（对象） 标签模板 它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串标签模板的实质，函数调用的特殊形式重要应用，过滤HTML字符串–防止用户恶意注意内容12345678910safeHtml &#96;&lt;p&gt;$&#123;name&#125; Welcome&lt;&#x2F;p&gt;&#96;function safeHtml(data)&#123; var str &#x3D; data[0] for(let i &#x3D; 1; i&lt;arguments.length;i++)&#123; var arg &#x3D; String(arguments[i]) str +&#x3D; arg.replace(&#x2F;&amp;&#x2F;g,&#39;&amp;&#39;).replace(&#39;&#x2F;&lt;&#x2F;&#39;) &#125;&#125; 字符串的新增方法12345678String.fromCodePoint() --用于从Unicode编码返回对应的字符串String.raw() --用于转义字符串，往往用于模板字符串的处理方法 a &#x3D; String.raw&#96;hi\\n\\n$&#123;5&#125;!&#96; console.log(a); &#x2F;&#x2F;hi\\n\\n5! &#x2F;&#x2F;String.raw 作为正常的函数使用 a &#x3D; String.raw(&#123;raw:&#39;hzfnb&#39;&#125;,0,1,2) console.log(a); &#x2F;&#x2F;h0z1f2nb 实例方法：codePointAt() –测试一个字符由两字节还是四个字节组成的最简单方法 实例方法：normailza() includes(): 返回布尔值，表示是否找到了参数字符串 startsWith() ： 返回布尔值，表示参数字符串是否在原字符串的头部 endWith(): 返回布尔值，表示参数字符串是否在原字符串尾部123456var a &#x3D; &quot;hzfnb zf&quot;var r1 &#x3D; a.includes(&#39;hzfnb&#39;)var r2 &#x3D; a.startsWith(&#39;h&#39;)var r3 &#x3D; a.endsWith(&#39;f&#39;)console.log(r1,r2,r3)&#x2F;&#x2F;true true true 实例方法： repeat()返回一个新的字符串，并将原字符串重复N次 实例方法：padStart() padEnd()：接受两个参数，第一个参数是字符串补全的位数，第二个填的是要补全的字符串123padStart() 用于补全头部padEnd() 用于补全尾部 console.log(&#39;hzf&#39;.padStart(5,&#39;nb&#39;)) &#x2F;&#x2F;hzfnb 实例方法：trimStart() , trimEnd();分别用于消除字符串最前面的空格以及最后面的空格 实例方法：matchAll()方法返回一个正则表达式在当前字符串的所有匹配 正则表达式的扩展字符串的正则方法 match() replace() search() split() u修饰符:含义为unicode模式，用来处理四个字节的UTF-16编码 点字符 i修饰符 y修饰符 函数的扩展函数的默认值 12345678910111213141516171819202122232425262728293031323334353637383940414243function Persion(name ,age &#x3D; 100)&#123; console.log(name,age) &#125;Persion(&#39;hs&#39;); &#x2F;&#x2F; hs 100Persion(&#39;hs&#39;,12); &#x2F;&#x2F; hs 12默认值与解构赋值的使用 function f1( &#123;x &#x3D; 0, y &#x3D; 0&#125; &#x3D;&#123;&#125;)&#123; console.log(x,y) &#125; function f2(&#123;x,y&#125; &#x3D; &#123;x:0,y:0&#125;)&#123; console.log(x,y) &#125; f1() f2() f1(&#123;x:1,y:2&#125;) f2(&#123;x:1,y:2&#125;) f1(&#123;x:1&#125;) f2(&#123;x:1&#125;) &#x2F;&#x2F;0 0 &#x2F;&#x2F;0 0 &#x2F;&#x2F;1 2&#x2F;&#x2F;1 2&#x2F;&#x2F;1 0&#x2F;&#x2F;1 undefined 最后一个解构赋值之后表示为 &#123;x:1&#125; 所以y &#x3D; underfined参数作用域已经注意事项在函数体内用let定义的变量，不能提前当做参数（放在括号内）es6在参数默认值方面是使用let来定义的RESTvar arr &#x3D; [1,2,3,4,5]; fn.call(null,...arr) &#x2F;&#x2F;...相当于把括号去掉 fn.apply(null,arr) &#x2F;&#x2F;apply 要用数组的形式引入 &#x2F;&#x2F; (5) [1, 2, 3, 4, 5] &#x2F;&#x2F; (5) [1, 2, 3, 4, 5] function fn(...args)&#123; console.log(args) &#125; 箭头函数 注意事项：箭头函数里面没有this这个对象，它只会依次找到父级，也没有arguments 1234567891011var f &#x3D; () &#x3D;&gt; numvar f &#x3D; function 参数 return 参数&#x2F;&#x2F;箭头函数的嵌套 function fn(str)&#123; return function()&#123; return str.splite(&#96;&#96;) &#125; &#125; var fn &#x3D; str &#x3D;&gt; () &#x3D;&gt;str.splite(&#96;&#96;) 数组的扩展数组的合并123456789101112131415161718var arr &#x3D; [&#39;dy1&#39;] var arr1 &#x3D; [&#39;1,2,3,4,5&#39;] var arr2 &#x3D; [&#39;false&#39;,NaN] var newArr &#x3D; [...arr,...arr1,...arr2] console.log(newArr)&#x2F;&#x2F;[&quot;dy1&quot;, &quot;1,2,3,4,5&quot;, &quot;false&quot;, NaN] var arr3 &#x3D; [...&#39;hzf&#39;] console.log(arr3);&#x2F;&#x2F;[&quot;h&quot;, &quot;z&quot;, &quot;f&quot;]Array.from()把类数组和可遍历的对象转换成数组Array.of() 数组实例的方法copyWithin() var arr &#x3D; [1,2,3,4,5] &#x2F;&#x2F; Array.prototype.copyWithin(target ,start &#x3D; 0,end &#x3D; this.length)) console.log (arr.copyWithin(0,3)) &#x2F;&#x2F; 0 3 还有一位end没写出来，0代表从第0位开始，3代表start&#x3D;3, 第三位是4 end 没写表示到一直最后， &#x2F;&#x2F;表示从4,5替换掉从0开始的两位 因此结果 &#x3D; 4,5,3,4,5 数组实例方法fill() , entries()，keys() values() entries() 是对键值对的遍历 values() 是对键值的遍历 key() 是对键名的遍历123456789101112131415161718192021var arr &#x3D; [1,2,3,4,5] var a &#x3D; arr.keys() console.log(a) &#x2F;&#x2F;Array Iterator &#123;&#125; var arr1 &#x3D; new Array(5); arr1.fill(7,3,4) console.log(arr1) &#x2F;&#x2F;(5) [empty x 3 ,7 empty x 3] &#x2F;&#x2F;fill的用法是添加某个数，用法跟copywithin()差不多， &#x2F;&#x2F;添加7这个数字，在第3跟第4个数之间插入数字7 var arr2 &#x3D; [&#39;2&#39;,2,3,4,5] var a &#x3D; arr2.keys() for([item, index] of arr.entries()) &#123; console.log(item ,index) &#125; &#x2F;&#x2F;entries 可以用于遍历数组，列出是第几位的并且把值打印出来 &#x2F;&#x2F; 0 &quot;2&quot; &#x2F;&#x2F; 1 2 &#x2F;&#x2F; 2 3 数组的实例方法includes() find() findIndex() includes() ——返回一个布尔值，表示某个数组是否包含给定的值。如果包含则返回true，否则返回false find() ——找到第一个符合条件的数组成员 findIndex() 返回第一个负荷而条件的数组成员的位置123var arr &#x3D; [20 , 4, -5, 10] var str &#x3D; [arr.find((n) &#x3D;&gt; n &lt;19)] console.log(str) &#x2F;&#x2F;[4] 对象的扩展123属性的简洁表示法 var foo &#x3D; &#39;123&#39; var bar &#x3D; &#123;foo&#125; 属性的可枚举性以及属性的遍历 对象的每个属性都有一个遍历对象（Descriptor）用来控制该属性的行为1234var obj &#x3D; &#123;age :123,name:&#39;dv&#39;&#125;console.log(Object.getOwnPropertyDescriptor(Object.prototype,&#39;toString&#39;))&#x2F;&#x2F;enumerable: false 说明不可枚举 但是有4种操作会忽略enumerable 为flase的属性 for… in 循环：遍历对象自身的和继承的可枚举属性 object.keys() 返回对象自身的所有可枚举的属性的键名 JSON.stringify() 只串行话独享自身的可枚举属性 object.assign() （ES6新增） 对象的新增方法 Object.is() ES5判断两个值知否相等只有 == 和 ===。它们的缺点在于， == 回自动转换数据类型， === 会使得Nan不等于自身，-0 不等于 +0 123object.is() console.log (Object.is(-0,+0)) &#x2F;&#x2F;false console.log (Object.is(NaN,NaN)) &#x2F;&#x2F;true Class类 class 一定要先定义再使用 12345678910111213141516 class Person&#123; constructor( name&#x3D;&#39;zf&#39;,age &#x3D; 18)&#123; this.name &#x3D; name this.age &#x3D; age &#125; &#x2F;&#x2F;这里不能写 &#39;,&#39; 写了就报错 show()&#123; console.log(this.age,this.name) &#125; &#125; var per &#x3D; new Person() &#x2F;&#x2F; per.name 表示实例属性立即执行classvar p &#x3D; new class&#123; &#x2F;&#x2F;这个类只能使用一次 &#125; this指向 =&gt; 指向父级作用域，跟ES5里面的this指向有些不同 静态方法静态属性继承 与es5的不同之处 子类 proto表示构造函数的继承 子类 proto.prototype 表示方法的继承 注意：proto并不属实语言本身的特征，目前很多浏览器的JS引擎都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，推荐使用Object.getPrototypeof()来获取实例对象的原型，再为原型添加属性 12345678910111213141516171819202122class A&#123; constructor()&#123; this.name &#x3D; &#39;zf&#39; &#125; print()&#123; console.log(this.name)&#x2F;&#x2F;console.log(&#39;father A&#39;) &#125; &#125; class B extends A&#123; constructor()&#123; super() &#x2F;&#x2F;为啥要调用super？ &#x2F;&#x2F;子类要调用super方法，才能使用this，给父级绑定才有this this.name &#x3D; &#39;aasda&#39; &#125; print()&#123; super.print() &#x2F;&#x2F;b.print() -&gt; father A &#125; &#125; var b &#x3D; new B() &#x2F;&#x2F; b.name &#x3D; &#39;aasda&#39; &#x2F;&#x2F; b.print() aasda Promise对象Promise的含义：简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常来说是一个异步操作。） 基本用法 三种状态 pending 就绪状态 resolved 成功状态 rejected 失败状态12实例方法Promise.all Promise.race","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}]},{"title":"CSS3学习笔记","slug":"CSS3-note","date":"2019-05-12T06:47:13.000Z","updated":"2020-06-18T10:17:46.000Z","comments":true,"path":"2019/05/12/CSS3-note/","link":"","permalink":"https://fengzehe.github.io/blog/2019/05/12/CSS3-note/","excerpt":"CSS3学习笔记CSS33只是版本号，目前主流浏览器都支持了，IE10以后也开始全面支持CSS3。 CSS3提供了更加强大的且精准的选择器，提供多种背景填充方案，可以实现渐变颜色，可以改变元素的形状，角度等。可以加阴影效果，报纸布局，弹性盒子，ie6混杂模式的盒模型，新的计量单位，动画效果等但CSS3并不是所有属性都通过了W3C标准，要查兼容性手册。","text":"CSS3学习笔记CSS33只是版本号，目前主流浏览器都支持了，IE10以后也开始全面支持CSS3。 CSS3提供了更加强大的且精准的选择器，提供多种背景填充方案，可以实现渐变颜色，可以改变元素的形状，角度等。可以加阴影效果，报纸布局，弹性盒子，ie6混杂模式的盒模型，新的计量单位，动画效果等但CSS3并不是所有属性都通过了W3C标准，要查兼容性手册。 CSS3的特性 border-radius –圆角，实现一个叶子的形状，画一个半圆 1100px 100px 0 0； box-shadow 盒子的阴影 box-shadow x代表偏移量，y代表偏移量， ，阴影模糊半径，阴影扩展半径，阴影颜色，投影方式text-shadow==不过shodow都是性能杀手== 线性渐变 语法：linear-gradient[方向，颜色，颜色，颜色…] 径向渐变 语法： 1radial-gradient(shape at position ,color[percent ] ,color) shape ：放射的形状，可以为原型circle 或拖延ellipse,position 为圆心位置 border-image border-origin:content-box / border-box / padding-box background-clip : 1border-box &#x2F; padding-box &#x2F;conteent-box &#x2F;no-clip 参数分别从边框，或内填充，或内容区域向外剪裁背景 text :background-clip :text; background-size :auto |&lt;长度值&gt;|&lt;百分比&gt; background-position: center CSS3 选择器：属性选择器 E[att ^= “val” ]{….} 选择匹配元素E，且E元素定义了属性att ，其属性值以val 开头的任何字符串 E[att $= “val”]{….} 选择匹配元素E ，且E元素定义了属性att ,其属性以val为结尾的任何字符串 E[att *= “val”]{….} 选择匹配元素E， 且E元素定义了属性att ，其属性值任意位置出现了’val’ ,即属性值包含了“val”，位置不限。 ~=的意思是只要有item 的元素都被选中了。 伪类选择器伪元素选择：伪元素的效果是需要通过添加一个实际的元素才能达到的. CSS3 对伪元素进行一定的调整，在以前的基础上增加了一个：也就是 1::first-letter, ::first-line ,::before ::after 另外还增加了一个 ::selection root选择器等同于html ,但权重比html更高 not 选择器除了那一个，其他都选中 empty 空标签选择器target 目标元素选择器被锚点的元素，被选中的元素被进行操作。 伪类选择器： first-child 第一个子元素 last-child 最后一个子元素 :nth-child（）{} 第XXX个子元素，n代表变量自然数 first-of-type 第一个子元素 :last-of-child 最后一个子元素 :only-of-type 唯一一个子元素 表示状态的伪类选择器 12:enabled 可用的元素:disabled 禁用的元素 有些表单元素才会有这样的元素，例如输入框，密码框，复选框 :check 已经被选中的状态 check-boxread-only 选中只读的元素 伪元素选择器::first-letter 首个字母:first-line 首行::selection 被选中时候的文本 条件选择器E &gt; F 直接子元素选择器 E + F 后面紧挨着的兄弟节点 E ~ F 后面的兄弟节点 例如单选框旁的div ，被选中的时候隔壁也被选中。 input:checked + div CSS3 动画形状变换 transform 可以实现元素的形状，角度，位置等变化（包括旋转）。transform: rotateX /Y/ Z( deg);不写默认是Z。 rotate3d(x , y, z, Angel) scale () 以x/y 轴进行缩放 scale(x,y)接受两个值，如果第二个参数未提供，则第二个参数使用第一个参数的值。 skew() 对元素进行倾斜扭曲shew（） 接受两个值，分别对应X轴 和Y轴， 如果第二个参数未提供，则默认为0； translate(x ,[y]) 移动 使用CSS3属性实现水平垂直居中当使用： 12top: 50%;left: 50%;， 是以左上角为原点，故不处于中心位置。 translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。 transition 过渡动画 1transition 第一项选择属性(什么width height fontsize opacity ，就是一项属性，用于监听)，第二项选择时间，第三项选择速度，第四项指定过渡函数，第五项为动画的延迟时间 animation 动画 animation-iteration-count 属性主要用来定义动画的播放次数 animation-direction 。normal 正常播放， reverse 反向播放 animation-play-state 用来控制动画的播放状态 running播放，paused 暂停。 CSS 多列布局为了能在Web页面中方便实现类似报纸，杂志那种多列排版的布局，W3C特意给CSS3增加了一个多列布局。语法： 12columns:[column-width][column-count] columns:2; 变成两列column-gap ： 设置列与列之间的宽度，直接用数值即可（eg:10px）column-span 设置多列布局的子元素可以跨列，类似标题效果。 CSS3 盒模型：IE6混杂模式，首先要触发一个怪异模式。 在IE6混杂模式盒模型下(IE6及以下浏览器)，内容宽度（盒子） = width - padding -border.width包含padding 和 borderW3C标准下的空间高度（盒子）= width +padding +border; width 为内容宽度，不包括padding 和 border CSS3 弹性盒子 display :flex==flex为复合属性，必须配合父元素display :flex使用==如图 6个属性 flex-grow 把盒子分成多少份，要是1 的话就分成1分自己独占。默认是0； flex-shrink 多出盒子的部分，按照比例的大小砍掉相应的大小，即比例越大，被砍的越大。 flex-basis 伸缩基准值，占据主轴空间。 flex order 可以进行排序，从小到大进行排列 1234align-self &#123;auto &#x2F; flex-start &#x2F;flex-end &#x2F; center &#x2F;baseline（基准线对齐） &#x2F;stretch&#125;主轴 &#x2F;侧轴&#x2F;交叉轴 flex-direction 决定主轴的方向row 从左向右， row-reverse , column ,column-reverse flex-wrap 是否换行 flex-flow 是dirction 和 wrap的简写方式 justify-content 1.flex-start 左对齐 flex-end 右对齐 conter 居中 space-between 两端对齐，项目之间的间隔都相等 space-around 每个项目两侧的间隔相等。 align-items 属性如何在侧轴上对齐 flex-start 交叉轴的起点对齐。 flex-end 交叉轴终点对齐 center 交叉轴中点对齐 baseline 项目的第一行文字基准线对齐 stretch 如果未设置高度或设为auton ,将占满整个容器的高度 transparent 透明色颜色值。 CSS3响应式布局通过设备不同的宽度，相应出不同的布局。这就叫做响应式布局。 123&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;width&#x3D;device-width 意思是宽度等于设备的宽度，user-scalable &#x3D; no 意思是不允许用户缩放 媒体查询：媒体查询是向不同设备提供不同样式的一种方式，为每种类型的用户提供了更佳的体验。CSS2 :mdeia type 是CSS2中一个非常有用的属性，通过media type 我们可以对不同设备执行不同的样式CSS3 mdeia query 是CSS3对meida type的增强。 添加方式： 12第一种插入样式，需要多个CSS文件&lt;link rel&#x3D;&quot;stylesheet&quot; media&#x3D;&quot;screen and (max-width:800px)&quot; href&#x3D;&quot;.&#x2F;text.css&quot;&gt; 第二种插入方式 123456789101112131415@media screen and (max-width:300px)&#123; div&#123; width: 200px; height: 200px; background-color: blue; &#125;&#125;@media screen and (min-width:301px)&#123; div&#123; width: 499px; height: 293px; background-color: aqua; &#125;&#125; and not only 这三个值。only是仅有的意思。 and是再添加这个属性的意思 demo–&gt;从四列变三列再变成两列一列的CSS3响应式布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124.wrapper&#123; display: flex; width: 100%; flex-wrap: wrap;&#125;.wrapper div&#123; width: 20%; display: inline-block; flex-grow: 1;&#125;.wrapper div img&#123; width:100%;&#125;@media screen and (max-width:1000px)&#123; .wrapper div&#123; width: 25%; &#125;&#125;@media screen and (max-width:800px)&#123; .wrapper div&#123; width: 33.33%; &#125;&#125;@media screen and (max-width:400px)&#123; .wrapper div&#123; width: 50%; &#125;&#125;@media screen and (max-width:200px)&#123; .wrapper div&#123; width: 100%; &#125;&#125;CSS3动画transform-style ：flat | preserve-3d；注意：属性需要设置在父元素中，高于任何嵌套的变形元素。设置了tranform-style :preserve-3d的原型，就不能设置overflow:hidden 否则preserve-3d失效元素旋转，其他轴也在旋转translate3d 这样写好了之后浏览器就会使用GPU加速。下图代码块为爱的魔力转圈圈 &lt;style&gt; .wrapper&#123; position: relative; width: 200px; height: 200px; margin: 0 auto; transform-style: preserve-3d; &#x2F;* transform: rotateX(-20deg); *&#x2F; margin-top: 200px; animation: turn 5s linear infinite; &#125; .wrapper div&#123; position: absolute; top: 0; width: 200px; height: 200px; opacity: 0.5; text-align: center; line-height: 200px; color :#fff; font-size: 30px; &#125; .wrapper .item:nth-of-type(1)&#123; background-color: red; transform: rotateY(0deg) translateZ(200px); &#125; .wrapper .item:nth-of-type(2)&#123; background-color: yellow; transform: rotateY(60deg) translateZ(200px); &#125; .wrapper .item:nth-of-type(3)&#123; background-color: green; transform: rotateY(120deg) translateZ(200px); &#125; .wrapper .item:nth-of-type(4)&#123; background-color: blueviolet; transform: rotateY(180deg) translateZ(200px); &#125; .wrapper .item:nth-of-type(5)&#123; background-color: pink; transform: rotateY(240deg)translateZ(200px); &#125; .wrapper .item:nth-of-type(6)&#123; background-color: yellowgreen; transform: rotateY(300deg) translateZ(200px); &#125; @keyframes turn&#123; 0%&#123; transform:rotateX(-20deg) rotateY(0deg); &#125; 100%&#123; transform:rotateX(-20deg) rotateY(-360deg); &#125; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;wrapper&quot;&gt; &lt;div class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;item&quot;&gt;6&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"CSS3","slug":"CSS3","permalink":"https://fengzehe.github.io/blog/tags/CSS3/"}]},{"title":"JQuery笔记","slug":"JQuery-note","date":"2019-05-12T06:20:06.000Z","updated":"2020-06-18T10:19:01.000Z","comments":true,"path":"2019/05/12/JQuery-note/","link":"","permalink":"https://fengzehe.github.io/blog/2019/05/12/JQuery-note/","excerpt":"JQuery学习笔记jQuery是啥呢？它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。","text":"JQuery学习笔记jQuery是啥呢？它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery的用法：选择元素： $(); 里面和CSS一样，不过对选择出的一组元素，一起处理，省略循环，这里是js不允许的。 里面可以写CSS选择器原生dmo,jQuery对象、 null /undefind / function(){} selector/content等 jQuery特有的选择规则，选出来是jquery对象 filter可以用来筛选，例如说筛选类名。not的话可以用来反向选择，没有这一项的就被选中，is则相反。has说明里面有这一项的选项被选中。find跟has的区别是，找到这里有这一项的然后选中。 jQuery可以进行链式操作。 sizzle是用来选择特殊写法的，是查到dom最快的方式。 函数写法： 都是函数式的写法。 CSS取值相当于getComputed，赋值相当于1dom.style.*** ，就写width，然后啥也不写 css赋值一组，取值取一个（） xxx.setAttribute(‘son’,’’Feng) 这样就可以给对象添加属性了。 attr() 用于设置或返回被选中元素的属性值 prop() 如果是检索html元素则使用attr()替代。 next()下一个兄弟节点。 prev()上一个兄弟节点 index 当前兄弟节点 addClass removeClass toggleClass 删除或者添加类名 没有的话帮你添加，有话帮你删除 insertBefore 插入到谁谁的前面。 appendTo() –这个比较常用12A添加到B的里面（添加到最后一个子元素后） $(&#39;p&#39;).appendTo($(&#39;ul&#39;)D.append（C） D里加上C remove detach 可以删除元素并且可以return 删除的元素。remove的话点击删除之后也删除了方法，因此第二次点击不能再删除了，而detach则可以。不断的进行删除和添加 on方法绑定时间 1.on(&#39;click&#39; ,&#39;a&#39;, function()&#123;&#125;) &#x2F;&#x2F;off可以解除绑定 $(&#39;.item&#39;).off(&#39;click&#39;), 如果想指定解绑的元素，那就要传值以更精准 one() 只绑定之间一次scrollTop() 滚出去的高度 动态生成标签1$(&#39;&lt;div&gt;&lt;&#x2F;div&gt;&#39;) 经常用于动态添加图片或者选项框 关于事件： 时间对象 e-&gt;e.pageX 相对文档而言，e.clinetX 相对于浏览窗口而言。 e.which 哪个键或按钮 e.button哪个鼠标按键被按 e.preventDefalut() s.stopPrpagation() return false; 这些都是用来解绑事件的 offset().left/top position().left/top。 offset()方法返回或设置匹配元素相对于文档的偏移（位置）。 parent() 返回父节点 offsetParent() 返回离它最近有定位的父级 paerents() 返回多个父级 closet() 查找最近的祖先节点 val是jQuery里面代表.value的参数 each 遍历 1$(&#39;li&#39;)each(function (index , ele )&#123;&#125; ) end() 回退操作,可以使jQuery 可以连续实现点操作。就说可以用一行代码搞定。 slblings() 当前元素节点的所有兄弟节点1. 1$(&#39;li.third-item&#39;).siblings().css(&#39;background-color&#39;, &#39;red&#39;); prevAll() 当前元素上面的所有兄弟节点 nextAll() 当前元素下面的所有兄弟节点 prevUntil() nextUntil() 掐头去尾选中元素，传jQuery 对象dom clone 克隆节点，参数为true的时候，事件也能克隆 wrap 包裹的意思 wrapall 包裹选中所有的元素 会破坏结构 unwrap 接触包装，接过话标签不能删除。 A.add(B) 选中元素A和B集中操作。 slice(0，2) 截取，算头不算尾 serialize 串联表单数据 serializeArray 串联数据成数组 animate() 参数target 参数durition 参数代表速度变化方式 回调函数 stop(true, true) 停止当前所有的运动，停在当前目标带点 ,后面的参数决定是否立即到达目标点上 是否停止后续所有运动 false：不停止，继续运动 true :停止后续所有运动 是否立即到达当前目标点 flase :不到达 true：到达 22.stop（flase ,true） 跳过当前运动并到达目标点，执行后续运动 finish() 停止当前运动 delay （）延迟，参数，延迟运动 1jquery.easing.js 是专门用来做jQuery 运动的. slideToggle(speed ,callback) 通过滑动效果来切换元素的可见状态 sildeUp sildedown 隐藏起来元素/显示元素——根据之前的不同状态进行切换- none–block or block–none toggleClass(active) 对设置或移除备选元素的一个或多个类进行切换 fade in/out 淡入淡出 tigger 方法触发被选元素的指定事件类型。==tigger出发事件是会冒泡，触发里面会影响外面 tigger可以触发自定义事件== 工具方法：1以$.xxx jQuery.xxx这种方式调用 ，此类方法定位在jQuery 函数上面 $.type() 判断 参数的数据类型 原生js判断类型的三种方法： 1231. arr.instanceof Aarray2. arr.constructor &#x3D;&#x3D;Array3. Object.prototype.toString.call(arr) 1,2两种有局限性，3 比较通用 trim()方法 1$.trim 消除空格 $proxy() 改变this指针方向 参数1：function , 参数2：函数执行期上下文。 $noConflict() 防止冲突 在很多javascript库使用$作为一个函数或变量名，正如我们同时需要使用jQuery和其他库一样，我们可以使用$.noConfilct把$控制权交给其他库。 $.parseJSON() 字符转换成json ,要求非常严格，外部是单引号，内部属性是双引号，不需要回车符 $.makeArray 把类数组转换成数组。 jQuery高级方法：$.extend() 插件扩展1 提供最新的jQuery 工具方法 $.fn.extend() 插件扩展2 提供最新的jQuery 实例方法，是实例不是工具方法 1编写方法1， $.extend(&#123;keftTrim :function ()&#123;&#125;&#125;) 12.fn.extend(&#123;drag : function()&#125;) 13. var cd &#x3D; $.Callback() 回调函数--》返回回调对象 14. once 只执行一次fire() 方法 放在回调函数的参数里面。 123var cd &#x3D; $.Callbacks(&#39;once&#39;);cd.add(fn1 ,fn2 ,fn3);cd.fire(); memory记忆 前面触发函数，后面添加也会被添加并触发 unique也是只执行一遍 $.Deferred() 延迟对象相当于有状态的Callbacks(); 添加函数； 12done fail progress触发成功， 失败 ， 进行中 触发函数：resolve reject notify $.deferred.promise() —-&gt;不能触发函数（无状态） $(when) —-&gt;返回的是延迟对象，参数也是延迟对象。当参数延迟对象全部触发done的时候最后会触发when返回延迟对象的done函数。 延迟对象作用控制的关键点，做链式运动的效果 $.ajax这种有状态的异步操作核心是deferred when当发生多个ajax请求的时候，因为都是异步的，所以可以用多个deferred ，每当ajax 成功后我们触发一个，最后全部成功在when后一并处理。 $() 里面可以填什么 1234$(false &#x2F;null &#x2F;undefined) $(&#39;&lt;li&gt;,&lt;&#x2F;li&gt;&#39;) $(&lt;li&#x2F;&gt;s1234) $(&#39;&lt;li&gt;&#39;, &#123;html : 123 ,dg :&#39; ds&#39;&#125;)$(&#39;#id&#39; &#x2F; &#39;.class&#39; &#x2F; div &#x2F; ul &#x2F;li &#x2F; li:eq(0))$(dom) //在JQuery中，init()函数里面会判断返回的类型，如果是DOM则是因为后面有.nodeType$(function () {})$($()) jQuery .extend() 拓展工具方法$().extend() 拓展实例方法 extend：拓展合并（传两个参数 ，合并到第一个对象里面去） 原始值的话并不会变化，而改个引用值就ok。 extends的四种写法： 1234$.extend(obj1)$.extend(obj1, obj2)$.extend(true ,obj1)$.extend(true ,obj1,obj2) 其实就是要关注target是什么，i是什么（从第几位开始传)，如果前面有true就往后挪一位.","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"JQuery","slug":"JQuery","permalink":"https://fengzehe.github.io/blog/tags/JQuery/"}]},{"title":"javascript学习笔记","slug":"javascript-note","date":"2019-05-11T09:22:32.000Z","updated":"2020-07-06T07:10:58.000Z","comments":true,"path":"2019/05/11/javascript-note/","link":"","permalink":"https://fengzehe.github.io/blog/2019/05/11/javascript-note/","excerpt":"","text":"JavaScript笔记 JavaScript笔记Web 发展史： Mosaic：是全世界第一款可以显示图片的浏览器 Netscape Navigator -&gt;2003 firefox 浏览器 IE6 -&gt;IE6浏览器 2008 -&gt; Chrome 浏览器 关于浏览器的内核部分： 渲染引擎（语法规则和渲染） js引擎 其他模块 JavaScript的语言特点： 解释性语言 –（不需要编译成文件）跨平台 单线程 ECMA标注 ECMAscript JavaScript执行队列： 执行片段A1-&gt;执行片段A2-&gt;执行片段A3 （争抢时间片） 主流浏览器及其内核： 主流浏览器 内核 IE trident Chrome wekit/blink firefox grcko Opera presto Safari webkit 引入javascript的两种方式 121.&lt;script&gt;&lt;&#x2F;script&gt;2.&lt;script src&#x3D;&#39;.js&#39;&gt;&lt;&#x2F;script&gt; js变量名的命名规则 变量名必须以英语字母 ,_ ,$开头。 变量名里面可以包括英文字母，_还有$. 不可以用系统的关键字还有保留字作为变量名。 JavaScript基本语法：数据类型分为原始值还有引用值 ==原始值有：number , boolean , String ,undefinded ,null== ==引用值有：array ,object ,funciton ,date ,regexp== 几个注意点： ==javascript对象才能拥有方法，然而number，String，boolean也可以拥有自己的方法，null和underfind是无法拥有方法的值。== 对象和数组属于可变类型，javascript程序可以更改对象属性值和数组元素的值。 数字，布尔值、null，和undefined属于不可变类型。 ==原始值和引用值的区别在于，原始值存在于stack(栈)当中，规则是先进去的最后出来。而引用值是存在heap（堆）里面的 ，引用值拷贝的是地址。== String的方法：在javascript权威指南中，笔者列举出了许多字符串可调用的方法。 运算符：12345+ - * &#x2F;不过特别要注意的是，任何“+”碰到字符串，都会变成字符串连接符。 1 &#x2F; 0 --&gt; Infinity &#x3D; Number; 0 &#x2F; 0 --&gt; Nan 比较运算符：字符串的比较是ASCII码数值的比较。 1Infinity &#x3D;&#x3D; Infinity undefind &#x3D;&#x3D; undenfind 特别注意的是 NaN!= NaN无穷大除以无穷大，给人以负数作开方运算或者算术云算法不是数字或无法转换为数字的操作数一起使用时都将返回NaN 逻辑运算符： 1&amp;&amp; || ! 与运算符&amp;&amp;，在运算中，undefind ,null ,Nan ,” “ ,0 ,flase ,会转换成false . &amp;&amp;操作符碰到false就返回这个值 1234var a &#x3D;1 &amp;&amp; 2 &#x3D;&#x3D;&gt; 2var a &#x3D; undefined &amp;&amp; 2 &#x3D;&#x3D;&gt; undefinedvar a &#x3D; NaN &amp;&amp; undefined &#x3D;&#x3D;&gt; NaNvar a &#x3D; 1 &amp;&amp; undefined &#x3D;&#x3D;&gt; undefined 或运算符12|| 或运算符中，找一个真的，然后返回。如果两个值都为假，那就返回第二个值。 在运算中，寻找一个真值，第一个为真则直接返回第一个值。若第一个为假，而又只有两个值，则返回第二个值，无论真假。12345左移（&lt;&lt;）将一个值左移相当于它乘以2，7&lt;&lt;2 &#x3D; 28右移（&gt;&gt;）将一个值右移相当于它除以2， 7&gt;&gt;1&#x3D;3 ，-7&gt;&gt;1&#x3D;-4 条件语句：123if(条件)&#123; &#125; 12345672. switch(1)&#123; case(1): console.log(&#39;a&#39;);break; &#x2F;&#x2F;switch这种选择语句，遇到合适条件的case才会执行，而却会把全部的case看一遍，如果在只有一种 &#x2F;&#x2F;条件下的case，则可以用break；停止运行。减少资源浪费。&#125; 对象1234对象：var obj &#x3D;&#123;属性名 ：&quot;属性值&quot;&#125; typeof可以判别的值有：number，String，boolean ，object，undefined，function；这6种。而typeof 在辨别null 和 Array 的时候一律返回object 。 类型转换：显示类型转换： var num = Number(‘123’) –&gt; 123注意： undefined -&gt;Number() –&gt; NaN null –&gt; Number(null) –&gt; 0 ‘123abc’ –&gt; Number() –&gt; NaN parseInt(‘10’ ,16)可以把任何东西转换成整形，而且可以进行10进制，16进制的转换。 parseInt(‘123abc’) –&gt; 123 parseInt(null) –&gt; NaN parseInt(undefined) –&gt; NaN parsefloat把数据转换成浮点类型。“123abc”可以识别数字并返回。 boolean：会把underfined ,null ,0 ,-0 ,NaN ,”” 转换成false。 toString: 将返回一个表示调用这个方法的对象值的字符串。 隐式类型转换：123451.isNan() 机制就是Number()进行转换成数字，然后再判断是不是2.+ -&gt;String类型3. - * &#x2F; % -&gt;number类型4. &#x3D;&#x3D; ！&#x3D; 隐式类型转换： 减号,乘号,除号,取模等操作会尝试将他们所操作转换为数字Number，如果没办法转换成数字，结果就是NaN 大于，小于，大于等于，小于等于，跟上面一样。 字符串遇上+号就进行隐式类型转换，变成字符串类型。没有字符串的情况下则不发生转换。 1&#x3D;&#x3D; !&#x3D; 字符串 op 字符串，不会进行类型转换，直接比较； 对象op对象，引用都指向同一个对象才为true typeOf !! 会转换成Boolean类型 12Boolean(Nan) &#x3D;&#x3D; false;null &#x3D;&#x3D; undefinded &#x2F;&#x2F; true 不发生类型转换：1234567&#x3D;&#x3D;&#x3D; &#x2F;&#x2F;绝对相等如果两个值为数字且数值相等，则它们相等。如果一个数值为0，另一个数值为-0，则它们同样相等。！&#x3D;&#x3D; &#x2F;&#x2F;绝对不相等！&#x3D;&#x3D;也可以用来判断一个属性书否是underfindvar o &#x3D; &#123;x : 1&#125;o.x !&#x3D;&#x3D; underfind &#x2F;&#x2F;true o中有属性xo.y !&#x3D;&#x3D; underfind &#x2F;&#x2F;false o中没有属性y ==typeof(typeof(number)) —&gt;最后其实类型是String ,因为第一个typeof是返回的是String类型。== 函数： 函数表达分为命名表达式还有匿名函数表达式。 命名表达式：function text(){ } text(); -&gt;调用 匿名表达式： var text :function() {} 形参与实参： 形参text(a,b) ==text.length== 可以知道形参的数量。 实参text(1,2)。==arguments.length== 可以知道实参的长度。 形参出生是多少个就是多少个，以后不会再往后加了。 return:使程序停止执行；返回值 递归： 符合人的逻辑思维过程 递归一定要有递归出口 javascript预编译：要点： 函数声明整体提升 变量声明提升 操作： imply global 暗示全局变量：即任何变量，如果变量未经声明就直接赋值，该变量为全局对象变量。 一切声明的全局变量，都是window的属性。即可以通过window调用。 javascript全局函数 escape(),eval_r() isFinite isNan() paresFloat() paresInt() unescape() 七个 预编译的四部曲（局部）：(重要) 创建AO（执行期上下文） 找形参和变量声明。将变量和形参作为AO属性名，值为underfined。 将实参值和形参值统一。 在函数体里面找函数声明，值赋予函数体，-&gt; 1function()&#123;&#125; 这种–优先级最高，function会覆盖之前变量的值。 ==注意：fcuntion a() {}这种叫函数表达式才算funciton, 在预编译里== 1var b &#x3D;function ()&#123;&#125; ==这种，因为还没有执行，所以不算function(){}== 全局的预编译 创建GO ——————-（其余步骤相等） ==在预编译的规则中，先生成GO ，再生成AO。== 作用域[[scope]]:每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些不行，这些对象仅供js引擎存取，[[scope]]就是其中一个。==其存储了运行上下文的集合==。 作用域链：[[scope]]中所存储的执行器上下文对象的集合，集合呈链式连接。 ==作用域上的作用域，生成的AO都是同一份。并且在每个作用域上修改的值，如果自己有就修改自己的值。 ==查找变量：从作用域的顶端依次向下查找，而AO在GO的顶端。== 闭包：==但凡是内部函数被保存到了外部，就一定会生成闭包。== 缺点：当内部函数被保存到外部时，将会生成闭包。闭包会导致原有的作用域链不释放，造成内存泄露（像内存泄露，只是说内存被占用） 闭包的作用： 实现公有变量。 例如说做一个函数累加器。1234function a (count)&#123; count ++; return count;&#125; 可以做缓存（存储结构）123456789101112131415属性：键 -- 值方法： 设置缓存 setCache 缓存的获取 getCache function configCache()&#123; var obj &#x3D; &#123;&#125;; return &#123; setCache : function (k ,v)&#123; obj[k] &#x3D; v ; &#125;, getCache : function (k)&#123; return [k]; &#125; &#125; &#125; 可以实现封装，属性私有化 模块化开发，放置污染全局变量 闭包的例题 123456789101112131415161718function test()&#123; var num &#x3D; 100; function a () &#123; num ++; console.log(num); &#125;; function b ()&#123; num -- ; console.log(num) &#125;; return [a,b];&#125;var myarr &#x3D; test(); myArr[0](); myArr[1](); &#x2F;&#x2F;这里打印的事101 100 ，在test函数执行完成后，test函数生成的AO作用域 ，test砍掉与其AO的连线，但retrun[a,b]把结果保存了出来，既函数a b依然使用连着test的AO,而且是同一份变量。因此改变同一份值。 立即执行函数：（也有执行器上下文，也需要预编译） 1(function() &#123;&#125; ()) 执行之后就立即被销毁。 123传递参数：(function(a,b,c))&#123;console.log(a+b+c);&#125;(1,2,3) 注意：只有表达式才能被执行符号执行（执行符号就是（）），利用立即执行函数把内部数据传到外部，也用于数据的初始化；‘ ， ’逗号可以把后面的值返回; 对象：所有的对象继承了两个转换方法，第一个是toString()，它的作用是返回一个反应这个对象的字符串。 toSting 数组类继承的toString()可以将每一个数组元素转换成一个字符串，并在元素之间添加都好并合并成结果字符串 函数类的toString()可以返回这个函数的实现定义的标识方式。 日期类的toString可以返回一个可读的日期和时间字符串。 RegExp类定义的toString()方法将RegExp对象转换成表达正则表达式直接量的字符串 另外一个方法是ValueOf()。如果存在任意原始值，它就默认将对象转换为表示它的原始值。 thisthis ：代表在某一对象里面的第一人称，例如this.health 函数预编译过程 this -&gt; window 全局作用域里 this -&gt; window call/apply 可以改变函数运行时的this 指向 obj.func(); func里面this指向 obj在对象内部的增删改查。 this指向只有在最终代码执行的时候才能知道指向谁 new 调用时指的是被构造的对象 call、apply调用，指向我们指定的对象 对象调用，如执行obj.b()，this指向obj 默认的，指向全局变量window(相当于执行window.fun()) 1this.wife&#x3D;&#39;FengZe&#39; ，即在这里直接进行添加和修改。 1删除：delete xx.name; 对象创建方法; var obj = {} 对象字面量/对象直接量。 通过构造函数创建： 系统自带构造函数 var obj = new object();构造函数要用大驼峰式方法来写：TheFirstName构造函数的内部原理：（一定要有new，不然就不是构造函数了） 在函数体最前面隐式加上this ={} 执行this.xxx=xxx; 隐式返回this 构造函数的内部原理 在函数体前隐式的执行 this = {} 执行 this.xxx = xxxx 隐式的返回 this 包装类：==原始值是坚决不能有方法的，如果能赋予属性，则是因为经历的包装类== new String()； new Boolean(); new Number()； null 和 undefined 不能有属性 对象创建方法： 对象字面量 12345678var obj &#x3D;&#123; &#x2F;&#x2F;对象字面量、对象直接量name : &quot;FengZe&quot;,sex : &quot;male&quot;,wfie : &quot;xingyu&quot;,smoke : function () &#123;console.log(&#39;i am smoking ！&quot;);&#125;&#125; 构造函数： 系统自带的构造函数 object –&gt; var obj = new object(); ==注意：构造函数要用大驼峰式的方法来写： TheFirstName这种== 自定义 123function xx()&#123;&#125; 构造函数的内部原理（一定要用new ,不然就不是构造函数了） 在函数体最前面隐式加入this = {} 执行this.xxx=xxx; 隐式地返回this; 包装类：new String（）；new Boolean ();new Number (); 原型： 定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的睡醒和方法。原型也是对象。 利用原理，可以提取共有属性。 独享通过隐式属性查看原型–&gt; 1__proto__ 通过constructor 查看对象的构造函数。 例子：如果生产一种汽车，而这种汽车大部分是相同的，而小部分作为选配部分，可以这样写： 1234567891011121314151617function Car (owner,power)&#123; this.owner &#x3D; owner, this.power &#x3D; power &#125; Car.prototype &#x3D; &#123; name :&#39;BMW&#39;, tite :18, run : function ()&#123; console.log(&quot;i am running &quot;); &#125; &#125; var car1 &#x3D; new Car(&#39;feng&#39;,&#39;900&#39;);delete.Car.name ,这样就可以删除了Car.prototype里面的属性了。 原型链：12Crand.protype.__prtot__ &#x3D; object.prototype --&gt;是所有对象的最终原型。var obj &#x3D; object.create(&quot;原型&quot;) 当继承的对象son 已经new出来后，再修改原型链就无效了。 12例： var person &#x3D; Object.create(Person.prototype)是绝大多数对象最终都会继承自object.prototpype, 大也有例外的，例如说object.create(null) call/applycall /apply 作用是转移this指向 借用别人的函数实现自己的功能 1234567891011121314Person.call(obj)；&#x2F;&#x2F;call需要把实参按照形参个数传进去，而apply需要传输一个arguments 区别在于传参列表不同。 function Person()&#123; this.name &#x3D; name; this.sex &#x3D; sxe; this.age &#x3D; age; &#125; function Student()&#123; Persion.call(this,name,sex,age); this.grade &#x3D; grade; this.tel &#x3D; tel; &#125; 继承 extend继承的发展史： 传统形式 -&gt;原型链 缺点：过多继承了没用的属性 123456789function Father()&#123; this.name &#x3D; &#39;Father&#39;;&#125;Son.prototype &#x3D; Fatherfunction Son()&#123;&#125;var son &#x3D; new Son(); 借用构造函数 (借用别人的构造函数) 缺点： 不能继承借用构造函数的原型。 每次构造函数都要执行多个方法。123456789101112function Person(name,age)&#123; this.name &#x3D; name; this.age &#x3D; age;&#125;function Student(name,age,sex,grade)&#123; Person.call(this.name,age,sex); this.grade &#x3D; grade;&#125;var student &#x3D; new Student(); 共享原型(共用一个原型链) 缺点： 不能随便改动自己的原型，因为他们拥有同一个原型。123456789Father.prototype.name &#x3D; &#39;He&#39;;function Father()&#123;&#125;function Son()&#123;&#125;Son.prototype &#x3D; Father.prototype;var son &#x3D; new Son(); 圣杯模式 123456&#x2F;&#x2F;函数F是一个中间层function F()&#123;F.prototype &#x3D; Father.prototype;son.prototype &#x3D; new F();son.prototype.constuctor &#x3D; son;&#125; 命名空间:管理变量，能防止污染全局，适用于模块化开发 属性拼接问题：123function (num)&#123;return this[&#39;name&#39; + num];&#125; &#x2F;&#x2F;输入num 得出num1的效果 对象的枚举：（遍历和枚举） 12341. for()2. for(var prop in obj)&#123;&#125; 当遍历不知道对象的数量多少的时候，可以用for in循环解决问题 [hasOwnProperty]obj.hasOwnProperty(), 用来判断属性是不是自己的，是不是从原型链上拿过来的。 in 属性只能用来能不能访问到这个属性in运算符希望它的左操作数是一个字符串或可以转换成字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数的属性名则返回true. 1234&#39;height&#39; in objvar point &#x3D; &#123;x:1 ,y:1&#125; &#39;x&#39; in point --&gt;true A instanceof B可以看A对象是不是从B的构造函数，构造出来的。Object ==可以看A对象的原型链上有没有B的原型==。instanceof 运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧对象是右侧对象的实例则返回true 123var d &#x3D; new Data();d instanceof Data; &#x2F;&#x2F;true,d是由Data() 创建的d instanceof Number; &#x2F;&#x2F; false ,d不是由Number创建的。 12[] instanceof Array -&gt;true Object -&gt;true toString方法： toString() 方法可把一个逻辑值转换为字符串，并返回结果。 12object.prototype.toString.call([]); ---&gt; [Object Array]object.prototype.toString &#x3D; function ()&#123;&#125; 克隆：浅层克隆，深层克隆。123456789101112131415&#x2F;&#x2F;浅层克隆 var obj &#x3D; &#123; name:&#39;Feng&#39;, wight:&quot;60&quot; &#125; var obj1 &#x3D; &#123;&#125; function shallowclone(origin, target)&#123; var target &#x3D; target || &#123;&#125;; for(var prop in origin)&#123; target[prop] &#x3D; origin[prop]; &#125; &#125; 12345678910111213141516171819202122232425262728293031&#x2F;&#x2F;deepclone 深层克隆var obj &#x3D; &#123; name: &quot;feng&quot;, sex: &#39;male&#39;, wife: &#123; name: &quot;fish&quot; &#125;&#125;var obj1 &#x3D; &#123;&#125;;function deepClone(Origin, Target) &#123; var Target &#x3D; Target || &#123;&#125;, toStr &#x3D; Object.prototype.toString, arrStr &#x3D; &#39;[object Array]&#39;; for(var prop in Origin)&#123; if(typeof(Origin[prop]) &#x3D;&#x3D; &#39;object&#39;)&#123; if(toStr.call(Origin[prop]) &#x3D;&#x3D; arrStr)&#123; Target[prop] &#x3D; []; &#125;else&#123; Target[prop] &#x3D; Origin[prop]; &#125; deepClone(Origin[prop],Target[prop]); &#125; else&#123; Target[prop] &#x3D; Origin[prop]; &#125; &#125;&#125;deepClone(obj,obj1); 对象序列化指的是对象的状态转换为字符串，也可以将字符串还原为对象。ECMAScript5提供了JSON.stringify()和 json.parse()用来序列化和还原js对象。但注意函数，RegExp,Error和underfind不能序列化和还原。 123o &#x3D; &#123;x : 1 , y:&#123;z : [false , null ,&#39;&#39;]&#125; &#125;;s &#x3D; JSON.stringify() &#x2F;&#x2F; s &#x3D; &#123;x : 1 , y:&#123;z : [false , null ,&#39;&#39;]&#125; &#125;p &#x3D; JSON.parse() &#x2F;&#x2F;p是o的深拷贝 三目运算符：问号前面放判断语句，如果结果为真则执行冒号前面的语句，否则指定冒号后面的语句 12？：例：1&gt;0? 2:1 如果1大于0 则选择2，否则选择1。 数组： 数组的第一个元素索引为0，最大可能索引为2 32(2的32次方) -2。 JavaScript数组是动态的，根据需要变长变短。数组都有一个length属性。 12var arr &#x3D; []; 数组字面量；var arr &#x3D; new Array(); 可以传参数，但如果只写一个数会认为这是数组的长度。 数组继承了默认的Value0f()方法，这个返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString方法。空数组转换成为空字符串，空字符串转换成数字0。 常用的方法： 改变原数组： push ,pop，shift ，unshift，sort，reverse ，splice 不改变原数组：concat ,join, split, toString ,slice push()–在数组的==最后一位添加数据,并返回最后的长度==123456Array.prototype.push &#x3D; function()&#123; for(var i &#x3D; 0 ; i &lt; arguments.length; i++ )&#123; this[this.length] &#x3D; arguments[i]; &#125; return this.length;&#125; pop ()–把数组的最后一位剪切出来，并返回最后一位的长度 unshift()–在数组前面添加数据，并可以通过传参添加多个数据， shift() 在数组前面减 reverse() 数组颠倒 splice()12345arr.splice (从第几位开始 ， 截取多少的长度 ，在切口处添加的新数据) var arr &#x3D; [1, 2, 3]; arr.splice(0,2,4); console.log(arr); &#x2F;&#x2F; [4,3] sort()给数组排序，但这个是用ASII码排序的，因为有时候会不尽人意。也可以自行添加函数。 如何优化sort()方法进行排序 123456789101112131415&#x2F;&#x2F;步骤 function sort(a , b)&#123; if(a - b &gt; 0)&#123; return 1; &#x2F;&#x2F; a 与 b 的位置发生转换 &#125;else&#123; return -1; &#x2F;&#x2F; a 与 b 的位置不发生转换 &#125; &#125; --&gt; a - b &gt; 0 --&gt; 可以写成 a &gt; b return 1 或 -1 可以写成 return a - b a - b 是升序， b - a 是降序 如何给数组乱序: 12345 var arr &#x3D; [5, 2, 7, 1, 9];arr.sort(function () &#123; return Math.random() - 0.5;&#125;);console.log(arr); 不改变原数组： concat :拼接数组，并且不影响前面的数组，也不会排序 toString :把数组变成字符串 slice() 从该位开始截取，截取到该位12var arr &#x3D; [1,2,3];arr.slice(1 ,3) --&gt; [2,3] join() 要字符串，然后用字符串连接12var arr &#x3D; [1,2,3];var a &#x3D; arr.join(&#39;-&#39;) --&gt; [1-2-3] split () 用” xxx “来拆分数组。1234var arr &#x3D; [1,2,3];var a &#x3D; arr.join(&#39;-&#39;) --&gt; [1-2-3]var b &#x3D; a.split(&#39;-&#39;) --&gt; [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;] 类数组：类数组不是数组，当然没有数组的方法。构成要素：属性为索引，必须要有length 属性，最好有push方法==类数组的好处是把数组和对象的属性都拼接在一起== 优点：类数组的关键点在于length 1234Array.prototype.push &#x3D; function(target)&#123; obj [obj.lenght] &#x3D; target obj.length++;&#125; 如此来实现push方法。 arguments.callee arguments.callee包含了一个函数的引用去创建arguments对象，它能让一个匿名函数方便指向本身。例如计算阶乘123456var num &#x3D;(function (n)&#123; if(n &#x3D;&#x3D; 1)&#123; retrun 1; &#125; return n * arguments.callee(n - 1);&#125;) arguments.caller()12 try…catch不影响try catch 下一块代执行，但不会执行try块里面的那行代码 几种常见错误类型： 1234567Error：有6种错误信息EvalErrorRangeError ；数值越界ReferenceError ：非法或不识别的引用SyntaxError :语法错误TypeError :操作的类型错误urIError:uri不当 es5严格模式（即es3.0与es5.0冲突的部分使用es5.0的解决办法） 浏览器基于es3.0+es5.0的新增方法“use strict”; 开启严格模式（并且要在代码的第一行来写） 在es5严格模式中，不允许使用argument.callee ，with{} caller 并且变量赋值前必须声明，局部里面的this一定要被赋值，拒绝重复的属性。 可以设置全局严格模式和函数内部严格模式（推荐） 在严格模式下有以下几种要求： 禁止使用with 语句 创设eval 作用域 禁止this关键字指向全局对象 禁止在函数内部遍历调用栈 禁止删除变量，只有configurable 设置为true的对象属性才能被删除。 变量必须声明 重名报错 arguments对象的限制不允许对arguments赋值 arguments不再追踪参数的变化禁止使用arguments.callee DOM （Document Obect Model） DOM定义了表示和修改文档的方法，DOM对象即为宿主对象。由浏览器厂商定义，用来操作html 和xml 。 DOM树中总共分成以下4种节点：Element(元素),Text类型(文本节点),Comment类型(注释节点),Document类型（document节点）1var div &#x3D; document.getElementsByTagName(&#39;div&#39;)[0]; &#x2F;&#x2F;后面这个0一定要选中。 数组去重方法：1234567891011Array.prototype.unique &#x3D; function() &#123; var temp &#x3D; &#123;&#125;; var arr &#x3D; []; var len &#x3D; this.length; for (var i &#x3D; 0; i &lt; this.length ; i++)&#123; if(!temp[this[i]])&#123; temp[this[i]] &#x3D; &#39;abc&#39;; arr.push(this[i]); &#125; &#125; &#125; DOM的基本操作： 对节点的增删改查： 查看元素节点： document.getElementById() document.getElementsByTagName() document.getElementsByClassName() document.getElementsByName() 增加元素节点： createElement createTextNode cloneNode createDocumentFragment 增加节点 DOM选择器：1doucument.getElementById() &#x2F;&#x2F;元素ID在IE8 一下浏览器是不区分大小写的，而且也返回匹配name 属性的元素；就是说写name可以当成id选择器（ie 8浏览器以下可以） getElementsByTagName() //标签名 getElemehtsByName() //只有部分标签name可生效（表单，表 ，img ,iframe） getElementsByClassName() 在IE8 及以下的版本中不使用方法。 .querySelector() //css选择器，在ie7级以下的版本中没有1var a &#x3D; document.querySelector(&#39;#a &gt; span &gt; p&#39;) .querySelectorAll() //css选择器，在ie7 及以下的版本中没有 选一组==不过querySelector选出来的只是之前的副本，并不是实时性的== ==document 代表整个文档，html只是文档里面的跟标签。== 遍历节点树：（遍历的是节点，有文本节点，元素节点等等等等） parentNode -&gt;父节点 （最顶端的parentNode 是#document;） childNodes -&gt;子节点 firstChild –&gt;第一个子节点 lstChild –&gt;最后一个子节点 nextSibling -&gt;后一个兄弟节点previousSiling -&gt;前一个兄弟节点 遍历元素节点数：（这个是访问元素节点，比较正常） parentElement -&gt;返回当前元素的父元素节点（IE不兼容） children -&gt;只返回当前元素的元素子节点 firstElementChild –&gt; 返回的第一个元素节点 lastElemeentChild –&gt; 返回的最后一个元素节点 nextElementSibling / previousElementSibling 返回后一个兄弟元素节点 / 返回前一个兄弟元素节点 1node.childElementCount &#x3D;&#x3D;&#x3D; node.children.length 节点类型：元素节点 --1 属性节点 --2 文本节点 --3 注释节点 --8 doucument --9 DocumentFragment --11节点的四个属性： nodeName //只能读取，不能写入。 nodeValue //text(文本)节点或comment（注释）节点的文本内容，可读写。 nodeType //该节点的类型 只读 判断元素是啥。 attributes // element 节点的属性集合 节点的一个方法:node.hasChildNodes(); DOM结构树：Document是系统的函数，只能系统自己调用。 ==getElementByTagName () 方法定义在Document.prototype 和Element.prototypes上== 增： 1234var div &#x3D; document.getElementsTagNmae(‘div’) ；document.createTextNode();document.createComment();document.createDocumentFragment(); 插： 12PARENTNODE.appendChild();PARENTNODE.insertBefore(a,b) &#x2F;&#x2F; 插入A在插入B之前 删： 12parent.removeChild();child.remove(); 替换： 1parent.replaceChild(new,origin) Element节点的一些属性：12345innerHTMLinnerText (火狐不兼容) &#x2F;textContent （老版本IE不好使）Element节点ele.setAttribute(&#39;id&#39; ,&#39;only&#39;)ele.getAttribute(&#39;id&#39;) 实例：在页面中插入一句话,并设置类名123456789var div &#x3D; document.createElement(&#39;div&#39;);var p &#x3D; document.createEelement(&#39;p&#39;);var text &#x3D; document.createTextNode(&#39;泽丰，最帅&#39;);div.setAttribute(&#39;class&#39;,&#39;example&#39;);div.setAttribute(&#39;id&#39;,&#39;handsome&#39;);p.setAttribute(&#39;class&#39;,&#39;rico&#39;);p.appendChild(text);div.appendChild(p);document.body.appendChild(div); Date 对象方法： 获取时间的方法 getDate() getDay() getFullYear() getMonth() getHour() getMinutes() getSeconds() getTime() Interval：定时器：但定时器是非常不准的。 setInterval: 定时器 clearInterval:清理计时器 5. 1234567891011121314151617181920212223 &#x2F;&#x2F;实现一个三分钟的定时器 var minuteNode &#x3D; document.getElementsByTagName(&#39;input&#39;)[0];var secondNode &#x3D; document.getElementsByTagName(&#39;input&#39;)[1];var minute &#x3D; 0;var second &#x3D; 0;var timer &#x3D; setInterval(function (min) &#123; second++; if (second &gt; 59) &#123; second &#x3D; 0; minute++; &#125; minuteNode.value &#x3D; minute; secondNode.value &#x3D; second; if (minute &#x3D;&#x3D; 3) &#123; clearTimeout(timer); alert(&quot;时间到&quot;); &#125;&#125;, 1000) DOM基本操作：查看滚动条的滚动距离： 1window.pageXOffsize YOffsize ==IE8及IE8以下不兼容== 查看视口的尺寸: 1window.innerWidth &#x2F;inner.Height 标准模式 /怪异模式也叫混杂模式（向后兼容），可在浏览器查document.compatMode,如果是CSS1Compat则是标准模式，如果是BackCompat则是向后兼容。clintHeight / clientHeight 查看元素的几何尺寸：1domEle.getBoundingClientRect(); 兼容性很好该方法返回不是实时的； 查看元素尺寸： 1dom.offsetWidth dom.offsetHeight //求的是视觉上的尺寸，当然不包含margin 查看元素的位置： 12345678910111213141516dom.offsetLeft dom.offsetTop&#x2F;&#x2F;封装一个方法查看位置的方法 function getScrollOffset() &#123; if (window.pageXOffset) &#123; return &#123; x: window.pageXOffset, y: window.pageYOffset &#125; &#125; else &#123; return &#123; x: document.body.scrollLeft + document.documentElement.scrollLeft, y: document.body.scrollTop + document.documentElement.scrollTop &#125; &#125; &#125; 1dom.offsetParent //查看父级的。能求有定位的父级。 让滚动条滚动：window上的三个方法： 123scroll()scrollTo() 这两个方法是一样的，滚动到某一个位置scroolBy() 累加滚动距离 阅读器小demo ，就是reader.js 脚本化CSS(DOM控制CSS) 可读写行间样式，没有兼容性问题，遇到float这样的保留字属性，前面应加css123456abc.style.width &#x3D; &#39;200px&#39;；&#x2F;&#x2F;这个200px写在行间样式是可以读得到的&#x2F;&#x2F;但没法读取在head里写的style样式的widthdiv.style.float &#x3D;&#x3D; div.style.cssfloat 复合属性必须拆解（borderWidth,borderHeight,borderradius），组合单词变成小驼峰式写法；写入的值必须是字符串格式 查询计算样式：123window.getComputedStyle(ele，null);var elem &#x3D; window.getComputedStyle(abc,null); 看到权重最高的，所以这个最准确。这个也不能改样式。计算样式只读 返回的计算样式的值都是绝对值，没有相对单位ie8及以下不兼容ie8及以下使用这种方法 ele.currentStyle(div, null) 123456789&#x2F;&#x2F;封装一个getStyle()方法,解决兼容性问题function getStyle(elem , prop)&#123; if(window.getComputedStyle)&#123; return window.getComputedStyle(elem,null)[prop]; &#125;else&#123; return elem.currentStyle[prop]; &#125;&#125; 查询样式：div.currentStyle–&gt; CSSStyleeclaration 事件：事件的绑定：12ele.onXXX&#x3D; function(event )&#123;&#125; &#x2F;&#x2F;程序this指向是dom元素本身特点：兼容性很好，但是一个元素的同一事件上只能绑定一个处理程序，基本等同于写在HTML行间上 12345obj.addEventListeber(type, fn,flase); &#x2F;&#x2F;程序this指向是dom元素本身ie9 以下不兼容，可以为一个时间绑定多个处理程序obj.attachEvent(&#39;on&#39;+type ,fn) &#x2F;&#x2F;程序this指向windowIE独有，一个时间同样可以绑定多个处理程序 绑定事件，当事件在循环里面，就一定要考虑要不要使用闭包。 事件处理程序解除事件： 1234ele.onclick &#x3D; false &#x2F;nullele.removeEventListener(type,fn ,false)ele.detachEvent(&#39;on&#39; +type ,fn);若绑定匿名函数，则无法解除 事件处理模型——事件冒泡，捕获结构上嵌套关系的元素，会存在事件冒泡的功能。 事件捕获： 只有chrome上可以用 把flase 变成ture,从结构的最外面向里面进行捕获. 一个对象的一个事件，绑定两个函数，分别是冒泡还有捕获。执行的顺序是先触发顺序，先捕获，后冒泡。 ==focus, blur , change submit reset ,select 等事件不冒泡== 取消冒泡：W3C标准event.stopP 阻止默认事件： 默认事件——表单提交，a标签跳转，右键菜单等return false; 以对象属性的方式注册的时间才有效 1event.preventDefault（） IE9以下不兼容 事件对象：event ||window.event 用于IE 事件源对象： event.target 火狐只有这个 event.srcElement ie只有这个 chorm 全都有 div.box就是事件源对象 事件分类：键盘类事件： Json就是为了传输数据： 以xml这种语言传输数据，xml相对于html比较随性，可以自定义标签。 规定json 属性名要加双引号，json传输的时候其实传输的是字符串。 12JSON.stringify() ---&gt;把数据传输给后台 json -&gt;stringJSON.parse（) ----&gt;后台把数据传输给前台，string -json 1domtree + csstree &#x3D; randerTree ==尽量减少dom节点的增加或者删除，以优化性能reflow 是效率最低的。dom节点的宽高变化==， 12例如说display none---&gt;blockoffsetWidth offsetLeft repanint 重绘效率相对没有这么低，是可以接受的 异步加载js：加载工具方法没必要阻塞文档。 三种方法异步加载js： defer = “defer” 这个就是异步加载的js了。只有IE能够用。要等到dom文档全部解析完之后才会被执行 async 异步加载。 async = “async” 也可以实现异步加载。W3C方法。加载完就执行。asynv只能加载外部脚本 创建script，插入DOM，可以按顺序执行。 使用onload方法，可以让所有资源加载完之后立即执行,除了IE都兼容。 123456IE 使用onreadystatechange（） 方法$(document).ready(function () &#123;&#125;) &#x2F;&#x2F;这种是当DOM解析完就执行的部分与window.onload 方法之间的区别。 onload是最低的写法 JS时间线BOM定义borwser Object Model 定义了操作浏览器的接口 BOM对象：Window ,History ,Navigator Screen,Location 由于浏览器不同，Bom对象的兼容性很低，一般情况只用部分功能。 123转义字符：“\\” 写到字符串里面，会把反斜杠后面的字符转义成正常文本多行字符串字符串换行符 \\n 正则表达式：匹配特殊字符或特殊搭配原则的字符的最佳选择———例如验证邮箱地址 两种创建方式： 11. 直接量 var reg &#x3D; new RegExp(); 两种方法： text() 只能判断有没有符号要求的片段，只能返回true和 false match()可以判断符合的片段，并返回给你 修饰符：123456i 执行对大小写不敏感的匹配g 执行全局匹配m 执行多行匹配一个表达式就代表一位 ，里面填的就是区间 元字符：123\\w &#x3D;&#x3D;&#x3D;[0-9A-z_]\\W &#x3D;&#x3D;&#x3D;[^w] 量词：1234567891011121314n只是代表这个数，并不是特定的nn+ 这个变量可以出现一次到无数次n* 区间是零到正无穷n? 匹配任何包含零个或一个n的字符串n&#123;x&#125;n &#123;x,y&#125; &#123;3,5&#125; 先匹配5个，再不行匹配三个n$ 结尾 ，是要以这一整个片段结尾^n 开头 RegExp对象属性：1234globalignoreCase &#x2F;&#x2F;忽略大小写multiline &#x2F;&#x2F;多行lastIndex 方法；exec()：index 索引 123456789101112131415&#x2F;()&#x2F; &#x2F;&#x2F;（）代表字表达式 \\1代表反向引用第一个表达式的内容var reg &#x3D; &#x2F;(\\w)\\1\\1\\1&#x2F; 可以匹配aaaaaabbbbb这种var reg &#x3D; &#x2F;(\\w)\\1(\\w)\\2&#x2F;g 可以匹配aabb这种表达式search()match() 匹配不到显示-1split 可以填字符串，还有正则表达式replace(‘a&#39;, &#39;b&#39;); &#x2F;&#x2F;替换字符，非正则表达式：把前面的替换成后面的 ，因为没有权限所以只能替换一个。正则表达式：具有访问全局的能力，把两个都能替换。rag &#x3D;&#x2F;a&#x2F;g 123var reg &#x3D; &#x2F;(\\w)\\1(\\w)\\2&#x2F;g; var str &#x3D; &quot;aabb&quot;; console.log(str.replace(reg,&#39;$2$2$1$1&#39;)); &#x2F;&#x2F;这种可以把字符把aabb转换成bbaa 1toUpperCase() 可以使字母大写 正向预查，正向断言 1&#x2F;a(? &#x3D;b)&#x2F;g 后面就是一个b 12abs() 可以去得正数和负数的绝对值floor（） 可以进行四舍五入 ui多线程 JS可以操作DOM元素，进而会影响GUI的渲染结果，因此JS引擎线程与GUI渲染线程是互斥的。 ######重新理解定时器1.setTimeout的等待时间结束并不是直接执行setTimeout属于异步操作，进入任务队列排队，等所有的同步操作运行后才开始执行任务队列，执行操作。 bind的使用","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://fengzehe.github.io/blog/tags/JavaScript/"}]},{"title":"浏览器渲染原理","slug":"brower-note","date":"2019-05-08T04:02:16.000Z","updated":"2020-06-18T10:17:35.000Z","comments":true,"path":"2019/05/08/brower-note/","link":"","permalink":"https://fengzehe.github.io/blog/2019/05/08/brower-note/","excerpt":"浏览器渲染原理 -步骤： 清楚HTML 生成DOM树 处理CSS生成 CSSDOM树 将两树合并成render 树 将render 树进行布局计算 将render树中的每一个节点绘制到屏幕上","text":"浏览器渲染原理 -步骤： 清楚HTML 生成DOM树 处理CSS生成 CSSDOM树 将两树合并成render 树 将render 树进行布局计算 将render树中的每一个节点绘制到屏幕上 重排，重绘 当render tree 中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变需要重新构建，会回流。每个页面至少需要一次回流，就是在页面的第一次加载的时候。 重绘。当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格而不影响布局的，例如background-color，就叫做重绘。 蓝色代表网络通信和HTML 解析 黄色代表javascipt执行 紫色代表样式计算和布局，即重排 绿色代表重绘","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"浏览器渲染原理","slug":"浏览器渲染原理","permalink":"https://fengzehe.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"}]},{"title":"jonp跨域","slug":"jonp","date":"2019-05-08T03:18:14.000Z","updated":"2020-06-18T10:18:50.000Z","comments":true,"path":"2019/05/08/jonp/","link":"","permalink":"https://fengzehe.github.io/blog/2019/05/08/jonp/","excerpt":"jsonp可以实现跨域获取数据 (其实是get请求),而Ajax跨域受到限制 解决跨域问题的几种方法: Flash (很少了) 服务器代理中转 （用得还算比较多）通过一个中间域名相同的php文件（借助自己同源的服务器），因为中间php不属于浏览器，因此不存在同源策略，即服务器之间可以互相转发信息。 Jsonp","text":"jsonp可以实现跨域获取数据 (其实是get请求),而Ajax跨域受到限制 解决跨域问题的几种方法: Flash (很少了) 服务器代理中转 （用得还算比较多）通过一个中间域名相同的php文件（借助自己同源的服务器），因为中间php不属于浏览器，因此不存在同源策略，即服务器之间可以互相转发信息。 Jsonp jsonp跨域的原理 web页面上1&lt;script&gt; 引入js文件时则不受是否跨域的影响（src不受同源策略限制） 于是我们把数据放到服务器上并且数据位json格式 （因为js可以轻松处理json数据） 因为我们无法监控1&lt;script&gt; 的src属性是否把数据获取完成，所以我们需要做一个处理。 实现定义好处理跨域获取数据的函数， 如function doJSON(data){} 用src获取数据的时候添加一个参数 cb = ‘doJSON’(服务端会根据参数cb的值返回 对应的内容) 此内容为cb对应的值doJSON为函数真实要传递的数据为函数的参数的一串字符 如doJSON (‘数据’)。 doucument.domain （针对基础域名相同的情况） //基础域名必须相同 bj.58.com document.domain = ‘58.com’ tj.58.com document.domain = ‘58.com’","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://fengzehe.github.io/blog/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"jsonp","slug":"jsonp","permalink":"https://fengzehe.github.io/blog/tags/jsonp/"}]},{"title":"Ajax笔记","slug":"Ajax-note","date":"2019-05-07T15:13:13.000Z","updated":"2020-06-18T10:17:24.000Z","comments":true,"path":"2019/05/07/Ajax-note/","link":"","permalink":"https://fengzehe.github.io/blog/2019/05/07/Ajax-note/","excerpt":"背景： form表单操作起来只会让整个页面刷新。Ajax(Asynchronoud javascript and xml)可以局部的获取数据。异步的过程。异步 javascript，和xml，用异步的javascipt获取xml数据，现在操作的是json。","text":"背景： form表单操作起来只会让整个页面刷新。Ajax(Asynchronoud javascript and xml)可以局部的获取数据。异步的过程。异步 javascript，和xml，用异步的javascipt获取xml数据，现在操作的是json。 封装Ajax的具体参数 Mothod : GET POST等。 action : address; enctype : 固定在发送表单数据之前如何对其进行编码，application /x -www-form -urlencoded在发送前编码所有的字符（默认）。 1multipart &#x2F; form-data (&lt;input type &#x3D;&#39; file &#39;&gt;) 不对字符编码，在使用包含文件上擦黄空间的表单时，必须使用该值。 因为IE中并没有xmlHttpRequest() 这种方法， 所以要使用 new ActiveXObject(‘Microsoft.XMLHttp’) 如何封装一个自己的Ajax123456var xhr &#x3D; null; if(window.XMLHttpRequest) &#123; xhr &#x3D; new XMLHttpRequest(); &#x2F;&#x2F;判断是否为主流浏览器 &#125;else &#123; xhr &#x3D; new ActiveXObject(&#39;Microsoft.XMLHttp&#39;) &#x2F;&#x2F;IE浏览器 &#125; Ajax的几种状态 ajax.open (method , url ,true); ajax.send(); onreadystatechage 4 // ajax状态每次变化都会触发 0 = 未初始化，未调用send（） 方法 1= 读取中，已调用send () 发送请求 2 = 已读取 ,send 方法执行完成，接收到全部相应内容 3 = 交互中， 正在解析响应内容 4 = 完成 ，响应内容解析完成 //只关系这个过程 status == 200 403 503 200代表成功 ,403代表请求访问的资源被服务器拒绝了,503表明服务器处于超负载或者正在进行停机维护。 Ajax支持的数据类型： dataType选项除了单纯的xml,还可以指定html,json,jsonp,script 或者 text","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"Ajax","slug":"Ajax","permalink":"https://fengzehe.github.io/blog/tags/Ajax/"}]},{"title":"douban","slug":"douban","date":"2019-05-07T01:03:25.000Z","updated":"2020-06-29T13:23:53.000Z","comments":true,"path":"2019/05/07/douban/","link":"","permalink":"https://fengzehe.github.io/blog/2019/05/07/douban/","excerpt":"使用豆瓣api做联想搜索项目目的：进行JQuery和Ajax的练习，仿照豆瓣的输入联想功能。在豆瓣后台返回数据的时候点击选项跳转到相关页面。","text":"使用豆瓣api做联想搜索项目目的：进行JQuery和Ajax的练习，仿照豆瓣的输入联想功能。在豆瓣后台返回数据的时候点击选项跳转到相关页面。 首先我们先写一下样式，仿照豆瓣的导航栏还有搜索框写一个样式。 HTML代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;src&#x2F;css&#x2F;index.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;wrapper&quot;&gt; &lt;div class&#x3D;&quot;nav&quot;&gt; &lt;div class&#x3D;&quot;nav-left&quot;&gt; &lt;ul&gt; &lt;li&gt;豆瓣&lt;&#x2F;li&gt; &lt;li&gt;读书&lt;&#x2F;li&gt; &lt;li&gt;电影&lt;&#x2F;li&gt; &lt;li&gt;音乐&lt;&#x2F;li&gt; &lt;li&gt;同城&lt;&#x2F;li&gt; &lt;li&gt;小组&lt;&#x2F;li&gt; &lt;li&gt;阅读&lt;&#x2F;li&gt; &lt;li&gt;FM&lt;&#x2F;li&gt; &lt;li&gt;时间&lt;&#x2F;li&gt; &lt;li&gt;豆品&lt;&#x2F;li&gt; &lt;li&gt;更多&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;nav-right&quot;&gt; &lt;ul&gt; &lt;li&gt;下载客户端&lt;&#x2F;li&gt; &lt;li&gt;注册&#x2F;登录&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;main-music&quot;&gt; &lt;div class&#x3D;&quot;main-wrapper&quot;&gt; &lt;div class&#x3D;&quot;main-logo&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;main-search&quot;&gt; &lt;form action&#x3D;&quot;&quot;&gt; &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;唱片名，表演者&quot; class&#x3D;&quot;search&quot; &gt; &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;submit&quot;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;main-list&quot;&gt; &lt;ul&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;..&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;src&#x2F;js&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; CSS样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127*&#123; padding: 0; margin: 0; list-style: none; text-decoration: none;&#125;html body&#123; width: 100%; height: 100%;&#125;.wrapper&#123; width: 100%; height: 100%; position: relative;&#125;.nav&#123; position: relative; width: 100%; height: 28px; min-width: 950px; background: #5d5d5d;&#125;.nav li&#123; display: inline-block; color: #d5d5d5; line-height: 28px; margin-left: 5px;&#125;.nav-left&#123; position:absolute; left: 5px;&#125;.nav-right&#123; position: absolute; right: 5px;&#125;.main-music&#123; position: relative; width: 100%; height: 100px; border-bottom: 1px solid black; background-color: #f0f3ef;&#125;.main-wrapper&#123; position: relative; width: 100%; height: 100%; left: 100px;&#125;.main-wrapper .main-logo&#123; position: relative; display: inline-block; top: 15px; float: left; width: 200px; height:80px; background-image: url(&quot;..&#x2F;bg.png&quot;); background-size: 100% 100%;&#125;.main-wrapper .main-search&#123; float: left; display: inline-block; width: 500px; height: 100px; line-height: 100px; color: #5d5d5d; font-size: 30px;&#125;.main-search .search&#123; position: relative; width: 250px; height: 30px; border-radius: 20px; overflow: hidden; left: 20px;&#125;.main-search .submit&#123; position: relative; width: 50px; height: 30px; border-radius: 20px; overflow: hidden; left: 30px;&#125;.main-list ul&#123; display: inline-block; position: absolute; width: 500px; height: 500px; left: 225px; top: 75px;&#125;.main-list li&#123; display: block; position: relative; width: 200px; height: 150px; font-size: 18px; font-family: &quot;黑体&quot;; background: #b1cbe0; border: 1px solid #d5d5d5; opacity: 0.7; text-align: center;&#125;.main-list img&#123; display: block; width: 100px; height: 100x;&#125; 上网查找豆瓣开发者API V2, 以前这里有文档写着后台接口，现在没有需要自己摸索（查资料）才能知道豆瓣的后台接口使啥。摸索完接口之后，我们这里用音乐接口作为例子，使用JQuery和封装Ajax,进行后台数据的接受。 javascript代码 1234567891011121314151617181920212223242526 (function()&#123; var $search &#x3D; $(&#39;.search&#39;); var $ul &#x3D; $(&#39;ul&#39;,&#39;.main-list&#39;); $search.on(&#39;input&#39;,function()&#123; var value &#x3D; $(this).val(); console.log(value); getData(value ,7); &#125;) function getData(value, num)&#123; $.ajax(&#123; type:&#39;get&#39;, &#x2F;&#x2F;获取方式为get url :&#39;https:&#x2F;&#x2F;api.douban.com&#x2F;v2&#x2F;music&#x2F;search&#39;, &#x2F;&#x2F;豆瓣音乐后台地址 data: &#39;q&#x3D;&#39; + value +&#39;&amp;count&#x3D;&#39; + num, &#x2F;&#x2F;获取的数据 dataType :&#39;jsonp&#39;, &#x2F;&#x2F;获取方式为jsonp success : addItem &#x2F;&#x2F;获取成功之后的函数addItem &#125;) &#125; function addItem(data)&#123; var list &#x3D; data.musics; var str &#x3D; &#39;&#39;; list.forEach(function(ele ,index)&#123; str +&#x3D; &#39;&lt;li&gt;&quot;&#39;+ele.title+&#39;&quot;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;music.douban.com&#x2F;subject&#x2F;&#39;+ele.id+&#39;&#x2F;&quot;&gt;&lt;img src&#x3D;&quot;&#39;+ele.image+&#39;&quot; &gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39; &#125;) $ul.html($(str)); &#125;&#125;)() 在数据获取成功之后我们通过foEach循环把获取回来的数据通过JQuery的html()方法插入到指定的文本当中,点击图片会跳转到歌曲页面。 豆瓣后台的项目大致就是这样啦。","categories":[{"name":"project","slug":"project","permalink":"https://fengzehe.github.io/blog/categories/project/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"实战项目","slug":"实战项目","permalink":"https://fengzehe.github.io/blog/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"}]},{"title":"图解HTTP","slug":"network-note","date":"2019-04-27T02:36:18.000Z","updated":"2020-06-18T10:19:12.000Z","comments":true,"path":"2019/04/27/network-note/","link":"","permalink":"https://fengzehe.github.io/blog/2019/04/27/network-note/","excerpt":"简单HTTP协议： HTTP协议用于客户端和服务器端之间的通信。","text":"简单HTTP协议： HTTP协议用于客户端和服务器端之间的通信。 告知服务器意图的各种HTTP方法： GET：获取资源 POST：用来传输实体的主体，post的主要目的并不是获取响应的主体内容 PUT：传输文件，跟FTPyiyang ,但PUT方法自身不带验证机制，因此存在安全性问题而不被使用。 HEAD：获得报文首部，用于确认URI的有效性及资源更新的日期时间。 ELETE: 删除文件，跟put相反的方法，DELETE方法按请求URI删除指定的资源 OPTIONS：询问支持的方法 TRACE:追踪路径 OPTIONS：询问支持的方法 TRACE : 追踪路径，但容易受到跨站追踪的工资，因此很少使用。 CONNECT: 要求用隧道协议连接 持久连接：只要任意一方没有明确提出断开连接，则保持TCP连接状态。 优点：持久连接的好处在于减少了建立和断开所造成的额外开销，减轻了服务器端的负载。因此Web页面现在是速度也就相应提高了。只要任意一端没有明确提出断开连接，则保持TCP连接状态。这样的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减少了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和相应能更早的结束，这样Web页面显示的速度也相应提高了。HTTP1.1具有持久连接。 HTTP是不保存状态的协议，因此引出了Cookie。 Cookie的状态连接： HTTP是无状态协议，可以减少服务器的CPU以及内存资源的消耗，而缺点在于每次跳转新页面都要再次登录或者再请求报文中附加参数来管理登录状态。Cookie会根据从服务器端发送的相应报文内的一个Set-cookie的首部字段信息，通知客户端保存Cookie。当下午客户端再向该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。 HTTP报文的HTTP信息： HTTP报文：请求端（客户端）的HTTP报文称为请求报文，响应端（服务器端）的叫做响应报文。 报文主体和实体主体的差异： 报文是HTTP通信中的基本单位，由8位组字节流组，通过HTTP通信传输。 实体：作为请求或响应的有效负载数据（补充项）被传输，其内容由实体首部和实体主体组成。 返回结果的HTTP状态码： 1XX：信息性状态码，接受的请求正在处理 2XX：状态成功码，请求正常处理完毕200 ok204 No Content 代表服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主体部分。 3XX：重定向状态码，需要进行附加操作以完成请求301 Moved Permanently 永久性重定向，说明请求的资源已经被分配了新的URI。302 Found 临时重定向。该状态码表示请求资源已经被分配了新的URI，希望用户（本次）使用新的URI访问。303 See Other 表示由于请求对应的资源存在另外一个URI，应使用GET方法定向获取请求的资源。304 Not Modified 表示客户端发送附带条件的请求，服务器允许请求访问资源，但未满足条件的情况，304状态码返回。307 Temporary Redirect 临时重定向。与302有相同的含义。 4XX：客户端错误状态码，服务器无法处理请求400 Bad Request 表示报文中存在语法错误401 Unauthorized 该状态码表示发送的请求需要通过有HTTP认证（BASIC认证，DIGEST认证）的认证信息403 Forbidden 表明请求资源的访问被服务器拒绝了。404 Not Found 表明服务器上无法找到请求的资源。 5XX：服务器错误状态码，服务器处理请求出错500 Internal Server Error 表明服务器端在执行请求时发生了错误，也可能是Web应用存在的bug或某些临时的故障。503 Server Unavailable 表明服务器处于超负载或者正在进行停机维护。 与HTTP协作的Web服务器 在互联网中，域名听过DNS服务映射到IP地址（域名解析）之后访问目标网站，可见，当请求发送到服务器时已经是以IP地址形式的访问了。 通信数据转发程序：代理，网关，隧道 代理——扮演者客户端和服务器的中间人角色，接受客户端发送的请求并转发给服务器，同时也接受服务器返回的响应并转发给客户端。 网关是转发其他服务器通信数据的服务器，接受从客户端发送过来的请求，它就会像自由拥有资源的源服务器一样对请求进行处理。 缓存服务器：优势在于利用缓存可避免对此从源服务器转发资源。","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://fengzehe.github.io/blog/tags/HTTP/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://fengzehe.github.io/blog/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"CSS2.0学习笔记","slug":"CSSnote","date":"2019-04-26T07:13:39.000Z","updated":"2020-06-18T10:18:02.000Z","comments":true,"path":"2019/04/26/CSSnote/","link":"","permalink":"https://fengzehe.github.io/blog/2019/04/26/CSSnote/","excerpt":"CSS (cascading style sheet 层叠样式表)引入css 行间样式，即1&lt;div style=\"\"&gt;&lt;/div&gt;","text":"CSS (cascading style sheet 层叠样式表)引入css 行间样式，即1&lt;div style=\"\"&gt;&lt;/div&gt; 页面级CSS，在head里面引入一个style标签，在里面写css代码。 引用外部css文件,即1&lt;link rel=&gt; link和!import引入的区别 Link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务;@import属于CSS范畴，只能加载CSS link引用CSS时，在页面载入是同时加载; @import需要页面网页完全载入后再加载 link是XHTML标签，无兼容问题; @import是CSS2.1提出的 ，低版本浏览器不支持 link使用Javascript控制DOM改变样式，而@import不支持 把html,css放在服务器上，浏览器下载一行代码并执行一行代码。属于异步执行，因为计算机的异步和同步相对于我们的理解来说是相反的。 (2)选择器 id选择器一个元素只能有一个id选择器。1&lt;div id=\"\"&gt;&lt;/div&gt; 类选择器,一个类选择器可对应对个元素。1&lt;div class=\"\"&gt;&lt;/div&gt; 标签选择器，适用于标签，例如说div a。 通配符选择器 *{} 选中所有的标签。这个用于初始化标签非常有作用。 属性选择器 选择器的权重（从高-低） important（正无穷）-&gt;行间样式（1000）–&gt;id（100）–&gt;class 属性选择器 （10） –&gt;标签选择，伪元素（1） ——&gt;通配符（0） 父子选择器： div span{} 特点：不在于一定要使用标签选择器，class id 选择器都可以，只要成立父子关系就可以了。 注意：浏览器定义父子选择器的顺序为从右到左，因为这样速度更快。 子元素选择器：即符号下的直接向下的选择方式，例如h1&gt;strong{;} 注意：浏览器定义父子选择器的顺序为从右到左，因为这样速度更快。 并列选择器：特点：当同时存在相同标签及相同类名时，可通过标签名和类名混合使用达到选中区域的效果。 权重选择器：特点：只要是同一横行想选择器，权重值为相加，若权重值一样，则后面的代码会覆盖前面的代码。 分组选择器：特点：例如说div span想设置一样的背景颜色，在减少冗余的角度来看，div span{}这样写css。 (3)CSS基础属性： 字体大小font-size px; 浏览器默认为16px;font-wight:blod 字体加粗font-style:italic；斜体font-family:arial;互联网上的通用字体color:设置字体颜色. 纯英文字母 颜色代码 （00-ff，00-ff,00-ff）分别代表rgb，red green,blue. 颜色函数，color:rgb(0-255,0-255,0-255) 123456border:10px solid(dotted点状，dashed 条状) black;（10px粗细，实线，黑色）text-align:right;文本向右对齐 text-align: center 文本居中显示line-height: 20px； 行高。因此让单行文本水平居中的做法就是让行高=容器高度text-indent:2em(2个font-size)cursor:(pointer 当光标移动到哪个区域，就会变成另外的符号，help ,move, pointer)伪类选择器 a:hover&#123;&#125; 在元素被光标选中的时候触发各种效果。 元素的分类：行级元素 inline 特征：内容决定元素所占位置，不可以通过css改变宽高。1&lt;span&gt; &lt;strong&gt; &lt;em&gt; &lt;a&gt; &lt;del&gt; 块级元素 block 特征：独占一行，可通过css改变宽高1&lt;div&gt; &lt;p&gt; &lt;ul&gt;&lt;li&gt;&lt;ol&gt; &lt;form&gt; &lt;address&gt; 行级块元素 inline-block 特征：1.内容决定元素所占位置 2.可以通过css改变宽高。1&lt;img&gt; &lt;input&gt; 凡是带有inline的都显示文字特性，因此会被分割，导致多张图片并排会有空隙产生。 注意：在开发的时候先写css样式再写html，因为clas是一对多关系的，所以这些属性都能通过组合加上去——先定义后选样式。 注意：用标签选择器做初始化，因为标签选择器的权重是0，若是用户想自定义修改那么通过增加权重就可以实现。","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://fengzehe.github.io/blog/tags/CSS/"}]},{"title":"HTML 学习笔记","slug":"HTMLnote","date":"2019-04-26T04:32:34.000Z","updated":"2020-06-18T10:18:33.000Z","comments":true,"path":"2019/04/26/HTMLnote/","link":"","permalink":"https://fengzehe.github.io/blog/2019/04/26/HTMLnote/","excerpt":"HTML（HyperText markup language 超文本标记语言）从出现到现在，从以前是文本编辑语言到现在只是用来表达内容。样式是由CSS做的。 HTML 语义化：根据内容的结构化，选择合适的标签，便于开发者阅读和写出更优雅的代码同时让浏览器的爬虫和机器很好的解析。","text":"HTML（HyperText markup language 超文本标记语言）从出现到现在，从以前是文本编辑语言到现在只是用来表达内容。样式是由CSS做的。 HTML 语义化：根据内容的结构化，选择合适的标签，便于开发者阅读和写出更优雅的代码同时让浏览器的爬虫和机器很好的解析。 1234&lt;html&gt; 表示根标签&lt;head&gt;&lt;body&gt;是结构化标签，&lt;head&gt;是给浏览器看的，&lt;body&gt;是给用户看的。&lt;titile&gt;表示页面标题 &lt;h&gt;表示标题 &lt;strong&gt;加粗 &lt;em&gt;表示斜体 &lt;del&gt;表示中划线 &lt;address&gt;表示地址容器：&lt;div&gt; &lt;span&gt; 高级标签：在编辑器里的空格只代表文本分隔符。12.&amp;nbsp;代表一个空格&lt;ol&gt;&lt;ul&gt;常用作网页导航栏 ol表示有序列表，在标签内写type=“A”就是以字母表排序，“1”就是以数字排序，start=”2”就是以数字2开始排序 ul表示无序列表 通常通过list-style:none 取消掉圆点样式. 相对路径：当html文和jpg文件在同一文件夹时，此时为相对路径。 图片占位置和提示符的区别 alt=”当图片展示不出来的时候，会用文字展示出来，这就是图片占位符” title=”图片提示符，当光标移动过去的时候会提示效果” 1&lt;a href=\"\"&gt; hyper Text reference--超文本引用 href 与src 之间的区别： href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系。 src表示引用资源，表示替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。 标签的几个作用：①超链接 ，②锚点， ③打电话 ④协议限定符（可运行js代码）target=“blank”就是在新的空白页中打开。 12&lt;form&gt;标签 能够把前端的数据完全发送给后端&lt;input type=\"text\"&gt; &lt;input type=\"password\"&gt; mothod 表示发送的方法 action 用来填发送给谁的地址 单选框＆复选框 当要做一个单选框的时候，input 里面的type=”radio”，请name相同，则只能单选一个 当需要进行多选的时候，input 里面的type=“checkbox”，则能多选。 在某些表单中，可以默认选中某些选项来提高用户体验，则可以使用check=”checked” 表示默认已经选中 创建下拉框 1234&lt;select name=\"phone\"&gt;&lt;option value=\"数据值\"&gt;iphone&lt;/option&gt;&lt;option value=\"数据值\"&gt;vivo&lt;/option&gt;&lt;/select&gt;","categories":[{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"}],"tags":[{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"HTML","slug":"HTML","permalink":"https://fengzehe.github.io/blog/tags/HTML/"}]},{"title":"hello","slug":"hello","date":"2019-04-25T13:04:39.000Z","updated":"2020-06-12T01:45:48.000Z","comments":true,"path":"2019/04/25/hello/","link":"","permalink":"https://fengzehe.github.io/blog/2019/04/25/hello/","excerpt":"","text":"hello","categories":[],"tags":[]}],"categories":[{"name":"rookie growth record","slug":"rookie-growth-record","permalink":"https://fengzehe.github.io/blog/categories/rookie-growth-record/"},{"name":"not only technology","slug":"not-only-technology","permalink":"https://fengzehe.github.io/blog/categories/not-only-technology/"},{"name":"front-end","slug":"front-end","permalink":"https://fengzehe.github.io/blog/categories/front-end/"},{"name":"project","slug":"project","permalink":"https://fengzehe.github.io/blog/categories/project/"},{"name":"back-end","slug":"back-end","permalink":"https://fengzehe.github.io/blog/categories/back-end/"}],"tags":[{"name":"-- record","slug":"record","permalink":"https://fengzehe.github.io/blog/tags/record/"},{"name":"-- 人生不止有技术","slug":"人生不止有技术","permalink":"https://fengzehe.github.io/blog/tags/%E4%BA%BA%E7%94%9F%E4%B8%8D%E6%AD%A2%E6%9C%89%E6%8A%80%E6%9C%AF/"},{"name":"-- 记录","slug":"记录","permalink":"https://fengzehe.github.io/blog/tags/%E8%AE%B0%E5%BD%95/"},{"name":"--  记录","slug":"记录","permalink":"https://fengzehe.github.io/blog/tags/%E8%AE%B0%E5%BD%95/"},{"name":"前端技术","slug":"前端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"vue","slug":"vue","permalink":"https://fengzehe.github.io/blog/tags/vue/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://fengzehe.github.io/blog/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"后端技术","slug":"后端技术","permalink":"https://fengzehe.github.io/blog/tags/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"CSS3","slug":"CSS3","permalink":"https://fengzehe.github.io/blog/tags/CSS3/"},{"name":"JQuery","slug":"JQuery","permalink":"https://fengzehe.github.io/blog/tags/JQuery/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://fengzehe.github.io/blog/tags/JavaScript/"},{"name":"浏览器渲染原理","slug":"浏览器渲染原理","permalink":"https://fengzehe.github.io/blog/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"},{"name":"跨域","slug":"跨域","permalink":"https://fengzehe.github.io/blog/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"jsonp","slug":"jsonp","permalink":"https://fengzehe.github.io/blog/tags/jsonp/"},{"name":"Ajax","slug":"Ajax","permalink":"https://fengzehe.github.io/blog/tags/Ajax/"},{"name":"实战项目","slug":"实战项目","permalink":"https://fengzehe.github.io/blog/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"},{"name":"HTTP","slug":"HTTP","permalink":"https://fengzehe.github.io/blog/tags/HTTP/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://fengzehe.github.io/blog/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"CSS","slug":"CSS","permalink":"https://fengzehe.github.io/blog/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://fengzehe.github.io/blog/tags/HTML/"}]}