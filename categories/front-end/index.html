<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Category: front-end | 欢迎来到何泽丰的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
  <meta name="description" content="怕，你就输一辈子">
<meta property="og:type" content="website">
<meta property="og:title" content="欢迎来到何泽丰的博客">
<meta property="og:url" content="http://yoursite.com/categories/front-end/index.html">
<meta property="og:site_name" content="欢迎来到何泽丰的博客">
<meta property="og:description" content="怕，你就输一辈子">
<meta property="article:author" content="何泽丰">
<meta name="twitter:card" content="summary">
  
    <link rel="icon" href="/images/icon.png">
  
  
<link rel="stylesheet" href="/blog/css/index.css">



  <!-- 百度站長統計-->
  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?34f341cfdc5f80d1bbb5dab01822e053";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/blog/atom.xml" title="欢迎来到何泽丰的博客" type="application/atom+xml">
</head>

<div class="main height-100 flex flex-v">
  <div class="phone-header">
    <a to="/home" class="mobile-logo" > <img src="/images/logo.svg" /> </a>
    <a class="menu iconfont icon-menu" onclick="toggleMenu()"></a>
  </div>
  <div class="main-top flex flex1">
    <nuxt-link  to="/home" class="mobile-nav-btn iconfont icon-fenlei"></nuxt-link>
    <!--主页上左部分-->
    <div class="height-100 main-left  flex flex-v">
      <div class="main-left-top flex1">
        <a class="logo">
          <img src="/images/logo.svg" />
          <div class="sub-title">自强不息 厚德载物</div>
        </a>
        <nav class="nav">

  
    
      <a title="首页"  alt="首页"  v-for="(menu,index) in menus" href="/blog">
        <div class="icon"><i class="iconfont icon-home"></i></div>
        <div class="name">
          <div class="cnname">首页</div>
          <div class="enname">Home Page</div>
        </div>
      </a>

    
      <a title="归档"  alt="归档"  v-for="(menu,index) in menus" href="/blog/archives">
        <div class="icon"><i class="iconfont icon-archives"></i></div>
        <div class="name">
          <div class="cnname">归档</div>
          <div class="enname">Archive Page</div>
        </div>
      </a>

    
      <a title="关于我"  alt="关于我"  v-for="(menu,index) in menus" href="/blog/about">
        <div class="icon"><i class="iconfont icon-about"></i></div>
        <div class="name">
          <div class="cnname">关于我</div>
          <div class="enname">About Me</div>
        </div>
      </a>

    
  

  <!--<a href="/link/">
    <div class="icon"><i class="iconfont icon-link"></i></div>
    <div class="name">
      <div class="cnname">友情链接</div>
      <div class="enname">Friends Web Link</div>
    </div>
  </a>-->
</nav>

      </div>

      <view class="website-msg">
        <div class="beian"><a target="_blank" href="http://www.miitbeian.gov.cn/"></a></div>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <div class="beian"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div>
        <div class="theme-drsc">PowerBy:<a href="https://hexo.io" target="_blank">Hexo</a> ThemeBy:<a href="" target="_blank">Soul</a></div>
        <div class="copyright">Copyright &#169 <a href="mailto:316692151@qq.com">2020 He ZeFeng</a> </div>
      </view>

      <div class="social flex flex-align-center ">
        
          
            
              <a class="flex1 text-center" href="https://weibo.com/3759599790/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" target="_blank" title="weibo" alt="weibo">
                <div class="icon relative">
                  <i class="iconfont icon-weibo"></i>
                </div>
              </a>
            
          
            
              <a class="flex1 text-center" href="https://github.com/FengZeHe" target="_blank" title="GitHub" alt="GitHub">
                <div class="icon relative">
                  <i class="iconfont icon-github"></i>
                </div>
              </a>
            
          
            
              <a class="flex1 text-center" href="/blog/316692151" target="_blank" title="wechat" alt="wechat">
                <div class="icon relative">
                  <i class="iconfont icon-wechat"></i>
                </div>
              </a>
            
          
        
      </div>
    </div>
    <!--主页上右部分-->
    
  
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/blog/2020/02/27/es6-async/" class="title">ES6异步的解决方案</a>
    <section class="desc">
  背景js经常会遇到一些异步任务（需要经过一段时间或当某个时机到达后才能得到的任务）例如说：

使用ajax请求服务器，当服务器完成响应后拿到响应结果
监听按钮是否被点击，当按钮点击后拿到某个文本框的值
使用setTimeout 等待一段时间，当时间到达后做某些事情

面对这样的场景，JS没有一种标准的模式来进行处理，我们处理这些问题的方式是杂乱的，这就导致了不同的人书写的异步任务代码使用方式不一致。例如说实用第三方库，不知道要传进去多少个参数，或者各种参数放第几位。
ES6异步处理模型ES6将异步场景分为两个阶段和三种状态
两个场景： unsettled (未决)  settled (已决)
三种状态： pending (挂起) resolved(完成) rejected (失败)

当任务处于未决时状态一定是pending的，表示任务从开始至拿到结果之间的过程。例如说网络完成了各种配置，发送了请求但还没有收到回复当任务处于已决时它只能是resolved和reject两种状态之间的一种。例如说拿到或者没拿到数据--&gt; resolved状态 。网络不通畅 --&gt; rejected状态我们把从未决推向已决的resolved状态的过程，叫做resolve，从未决推向已决的rejected状态的过程，叫做reject如下图所示
任务已决后(有了结果)进一步做后续处理，如果任务成功了（resolved）,有后续处理，如果任务失败了（rejected）,仍可能做后续处理我们把针对resolved的后续处理称之为thenable，针对rejected的后续处理，称之为catchable
注意事项
任务一旦进入已决后，所有企图改变代码任务状态的代码都将失效
以下代码可以让任务达到rejected 状态
调用reject
代码执行报错
抛出错误


后续处理函数一定是异步函数，并且放在微队列中



</section>
    <p class="sub">Feb 27, 2020</p>
  </div>
</div>
  
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/blog/2020/02/23/ES6-modular/" class="title">ES6模块化</a>
    <section class="desc">
  ES6的模块化模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件模块化背景过去js很难编写大型应用，因为有以下两个问题：

全局变量污染
难以管理的依赖关系这些问题，都导致了JS无法进行精细的模块划分，因为精细的模块划分会导致更多的全局污染更加负载的依赖关系，因为功能精细的划分有利于代码重用

前端的模块化有两个标准：
Commonjs
ES6 Module注意：上面提到的两个均是模块化标准，具体的实现需要依托于JS的

ConmomJS简介：目前，只有node环境才支持CommonJs模块化标准，所以需要先安装node才能使用CommonJS在CommonJS中，浏览器运行的是html页面，并加载页面通过script元素引入js，node.js直接运行某个js文件，该文件被称之为入口文件。node.js遵循ECMAScript标准，但脱离了浏览器环境：你可以在node.js中使用ECMAScript标准的任何语法或api，例如循环，判断，数组，对象等等但不能在node.js中使用浏览器的web api,例如说dom对象，window对象，document对象
CommonJS标准和使用node中的所有代码均在CommonJS下运行，具体规范如下 ：

一个js文件既为一个模块如果一个模块需要暴露依稀额数据或功能给其他模块使用，需要使用代码module.exports = xxx ,该过程称之为模块的导出

如果一个模块需要使用另一个模块导出的内容，需要使用代码require(‘模块路径’)
12路径必须以.&#x2F;或..&#x2F;开头如果模块文件后缀名为  .js 可以省略后缀名
require 函数中返回的是模块导出的内容,且模块中所有的全局代码产生的变量、函数均不会对全局造成任何污染，仅在模块内使用

模块具有缓存，第一次导入模块时会缓存模块的导出，之后再导入同一个模块 会使用之前缓存的结果


有了CommomJS模块化，代码就会形成以下结构：
原理：node实际上是将模块文件中的代码防止到一个函数环境中执行，可以想象该函数是下面的样子：
12345function(module)&#123;    module.exports &#x3D; &#123;&#125;;    var exports &#x3D; module.exports;    return module.exports;&#125;



ES6 module
由于种种原因，CommonJS难以在浏览器中实现，因为一直在浏览器端没有合适的模块化标准，直到es6出现。ES6规范了浏览器的模块化标准，一经发布，各大浏览器厂商纷纷在自己的浏览器中实现该规范。

模块的引入：
12&#x2F;&#x2F;在浏览器使用以下方式引入ES6模块文件&lt;script src &#x3D; &quot;入口文件&quot; type &#x3D; &quot;module&quot;&gt;




标准和使用模块的导出分为两种，基本导出和默认导出
12345678可以将整个模块的导出想象成一个对象，基本导出导出的是该对象的某个属性，默认导出导出的是该对象的特殊属性default&#x2F;&#x2F;导出结果：想象成一个对象&#123;    a: xxx, &#x2F;&#x2F;基本导出    b: xxx, &#x2F;&#x2F;基本导出    default: xxx, &#x2F;&#x2F;默认导出    c: xxx &#x2F;&#x2F;基本导出&#125;


ES6的导出方式：1234567891011121314export var a &#x3D; 1 &#x2F;&#x2F;基本导出 a &#x3D; 1export var b &#x3D; function()&#123;&#125; &#x2F;&#x2F;基本导出 b &#x3D; function()&#123;&#125;export function method()&#123;&#125;  &#x2F;&#x2F;基本导出 method &#x3D; function()&#123;&#125;var c &#x3D; 3;export &#123;c&#125; &#x2F;&#x2F;基本导出 c &#x3D; 3export &#123; c as temp &#125; &#x2F;&#x2F;基本导出 temp &#x3D; 3export default 3 &#x2F;&#x2F;默认导出 default &#x3D; 3export default function()&#123;&#125; &#x2F;&#x2F;默认导出 default &#x3D; function()&#123;&#125;export &#123; c as default &#125; &#x2F;&#x2F;默认导出 default &#x3D; 3export &#123;a, b, c as default&#125; &#x2F;&#x2F;基本导出 a&#x3D;1, b&#x3D;function()&#123;&#125;, 默认导出 default &#x3D; 3绝大部分时间写代码使用的导出方式是 export default()&#123;&#125;
ES6模块的导入：使用以下的代码导入模块
12345678import &#123;a,b&#125; from &quot;模块路径&quot;   &#x2F;&#x2F;导入属性 a、b，放到变量a、b中import &#123;a as temp1, b as temp2&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性a、b，放到变量temp1、temp2 中import &#123;default as a&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default，放入变量a中，default是关键字，不能作为变量名，必须定义别名import &#123;default as a, b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default、b，放入变量a、b中import c from &quot;模块路径&quot;  &#x2F;&#x2F;相当于 import &#123;default as c&#125; from &quot;模块路径&quot;import c, &#123;a,b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;相当于 import &#123;default as c, a, b&#125; from &quot;模块路径&quot;import * as obj from &quot;模块路径&quot; &#x2F;&#x2F;将模块对象放入到变量obj中import &quot;模块路径&quot; &#x2F;&#x2F;不导入任何内容，仅执行一次模块
细节导入模块时，注意以下细节

ES6 module 采用依赖预加载模式，所有模块导入代码均会提升到代码顶部
不能将导入代码放置到判断、循环中
导入的内容放置到常量中，不可更改
ES6 module 使用了缓存，保证每个模块仅加载一次



</section>
    <p class="sub">Feb 23, 2020</p>
  </div>
</div>
  
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/blog/2020/02/15/when-Enter-an-address/" class="title">当在浏览器输入一个地址发生了什么</a>
    <section class="desc">
  是这样的：
浏览器将url地址补充完整，如果没有写协议就自动添加上协议（http： / https：）

浏览器对url地址进行url编码，如果url地址中出现了非ASCII字符，浏览器则会对其进行编码

例如说在浏览器中搜索”王思聪”，汉字会被编码成ASCII码


浏览器构造一个没有消息体的GET请求，发送至服务器，等待服务器响应（此时浏览器标签应该有一个等等的图标–转圈）

服务器收到请求，将一个HTML页面代码组装到消息体中（不一定要html文件）响应给浏览器

浏览器拿到服务器的响应后，丢弃当前的页面，开始渲染消息体的HTML代码。浏览器之所以知道这是一个HTML代码，是因为服务器的响应头指定了消息类型为text/html

浏览器在渲染页面的过程中发现有嵌入的资源如CSS,JS图片等

浏览器使用不阻塞的渲染方式，重定向服务器发送该资源的请求，拿到响应结果后根据Content-Type做响应处理

当所有资源已经下载并处理好后，浏览器出发window.onload事件


   这里说的Content-Tpye是在http协议消息头中表示具体请求中的媒体类型信息
   有一下几种类型：
   


</section>
    <p class="sub">Feb 15, 2020</p>
  </div>
</div>
  
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/blog/2019/10/02/vue/" class="title">vue学习笔记</a>
    <section class="desc">
  vue学习笔记概念：Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现在话的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。vue的特点：
渐进式：vue的侵入性很少，可以与很多其他前端技术联用
组件化
响应式：数据响应式，vue会监控数据变化。当数据变化时

vue的核心功能：关于创建vue工程
直接在页面上引用vue.js
使用构建工具vue-cli脚手架

vue实例vue实例：通过new vue（配置对象）得到的对象
当创建vue实例的时候，vue将会把data（为了实现响应式）methods配置（为了在模板中方便使用）等配置成员提升到vue实例中.
由于有提升的存在，为了防止命名冲突，vue会将自身的成员名称前加上$ 或 _ , 为了防止命名冲突，vue会将自身的成员加上$(可以使用),_符号就不用用了

模板插值：在模板的元素内部使用指令：通常作为元素的属性存在，名称上以v- 开头v-for:用于循环生成元素v-on :用于注册事件。 语法糖@v-if :用于判断该玄素是否可以生成,可以与v-else 或者v-else-if联用v-show:元素已经显示,display:nonev-bind:用于绑定属性, 语法糖:v-model：用于事件双向绑定，实际上是自动绑定用了value值,和注册了input事件
模板中的配置
页面中直接书写
在template配置中书写（常见）
在render中手动配置用函数创建，render函数的参数是一个创建虚拟DOM对象，为什么要创建虚拟DOM,因为真实DOM操作特别慢

配置对象
template:字符串，配置模板
el:配置控制的元素，css选择器
data: 管理的数据，该数据是响应式的
mothods:配置方法，方法中的this指向vue实例，不能会用箭头函数,会干扰vue绑定this挂在的配置
通过el进行配置
使用vue实例中的$mount函数进行配置

关于computed –计算属性
计算属性，其中的配置会提升到vue实例中，因为在模板中可以直接当做属性使用，使用时，实际上调用的是对应的方法。通常，计算属性用户通过data或其他计算属性得到的数据。
与方法的区别：vue会检查计算属性的依赖，当依赖没有发生变化时，vue会直接使用之前缓存的结果，而不会重新计算
能用计算属性尽量使用，因为效率很高。依赖不变时不会重新加载。（计算属性的读取函数不可以有参数，有参数没意义）
计算属性可以配置get和set. 分别用于读取时和设置时。 get读取属性的时候可以监听到，然后检查那张表函数有没有变化。

关于v-html指令：
vue为了安全，会将元素内部的插值进行实体编码

12345678910&lt;div v-html &#x3D; &quot;html&quot;&gt;    &lt;&#x2F;div&gt;config &#x3D; &#123;    data:&#123;        html:&lt;p&gt;带标签的元素&lt;&#x2F;p&gt;    &#125;&#125;&#x2F;&#x2F;这样就可以把html标签渲染出来了

组件组件是页面中可复用的功能单元
VUE中的组建
组件的创建：组件对于开发者，是一个普通的配置对象
组件的注册：1234567891011121314&#x2F;&#x2F;全局注册组件Vue.component(&quot;组件形成&quot;,pager)&#x2F;&#x2F;局部注册组件 在使用的组件和vue实例配置中进行注册const config &#x3D; &#123;    template:&#96;&lt;div&gt;        &lt;MyPager&gt;&lt;&#x2F;MyPager&gt;    &lt;&#x2F;div&gt;&#96;,    el:&quot;#app&quot;,    components:&#123;        MyPager :pager    &#125;&#125;



组件名称的规范，以下命名的方式任选其一：
使用短横线命名
使用大驼峰命名组件的使用：把组件当成标签使用即可，标签名任选其一
短横线命名
大驼峰命名

组件可以嵌套，因为会形成一个组件树，组件树的根叫做根组件
组件中的数据通信：
prevent修饰符用于v-on指令，表示阻止默认行为
stop修饰符用于v-on指令，表示阻止事件冒泡

组件的状态和属性：
通常讲组件中需要自身管理的数据（组件配置中的data）叫做组件状态（component state），组件状态只能在组件内部使用，外部原则上不可以使用.
data(state 状态)在组件中的配置和在vue实例中配置的区别：在组件中data必须是一个函数，而VUE实例中心必须是一个对象。因为组件是可以被复用的，每一个组件都是独立的，所以data必须是一个函数.

123456789&#x2F;&#x2F;在组件中export default&#123;    template,    data()&#123;        return &#123;            &#x2F;&#x2F;返回的结果是组件的状态        &#125;    &#125;&#125;

组件中可以有属性（component props），而vue实例中没有
声明组件属性时，使用短横线或小驼峰命名法
传递组件属性时，使用短横线或小驼峰命名法
属性会被提升到vue组件实例中

==组件的属性时只读的，不允许更改，根本原因是要保证单向数据流==  
自定义事件：
在组件中触发事件： this.$emit(“事件名”,事件参数…)
当一个组件状态发生变化时，该组件会重新渲染，在渲染的过程中，可能会导致其子组件的属性发生变化，而属性的变化会导致组件重新渲染。但根本原因，是状态的变化.
v-model 的本质是一个语法糖，实际上是绑定value属性，同时监听input事件

组件的生命周期
beforeCreate(){}  –&gt;这个是自动执行的
created()  –&gt;组件实例中已经提升到实例总，但是没有渲染页面
beforeMount   –&gt; 组件即将进行渲染，但还没有渲染，此时已经编译好模板
mounted【常用】  –&gt;组件已经完成渲染（页面可见）
beforeUpdate –&gt;组件即将更新，还没有更新，此时得到的数据是新的，但页面依旧是旧的
updated –&gt; 数据，界面都是新的
beforeDestory –&gt; 当组件即将被销毁  调用vm.$destroy()函数
destoryed  –&gt; 解除绑定，销毁子组件以及事件监听器

vue路由vue路由，可以简单理解为，当访问某个地址时，渲染某个组件
使用路由

根据一个配置对象创建路由，得到路由对象
在创建vue实例时，将路由对象配置到实例配置的router中
在合适的位置写上router-view组件，表示路由匹配到组件渲染的位置，它实际上是vue-router做好的一个组件，并且做好了全局注册

路由配置对象

routes:路由规则配置
mode:配置模式
hash模式，兼容性最好，地址出现#号后，切换地址不会导致页面刷新
history模式，使用的是HTML5 history API，地址直接变化，并且页面不刷新





</section>
    <p class="sub">Oct 2, 2019</p>
  </div>
</div>
  
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/blog/2019/09/02/HTML5-note/" class="title">HTML5学习笔记</a>
    <section class="desc">
  HTML5学习笔记Canvas 画布Canvas应用场景：
游戏
图表
动画
condepen.io（HTML5动效）

Canvas 发展史
最早在apple Safari1.3中引入，ie9之前的浏览器不支持canvas

如何使用canvas添加canvas标签1234567&lt;canvas width &#x3D; 500 height &#x3D; 500&gt;&lt;&#x2F;canvas&gt;获取cancas元素var canvas &#x3D; document.getElementById(&#39;myCanvas&#39;)获取canvas上下文对象var ctx &#x3D; camvas.getContext(&#39;2d&#39;);

如何画线段123456ctx.moveTo(x,y) 移动到x,y坐标点ctx.lineTo(x,y) 从当前点描绘直线到x,y点ctx.stroke();描边ctx.lineWidth &#x3D; 20  设置线条宽度ctx.closePath();  闭合当前路径ctx.fill() 填充

fill和stroke方法都是作用在当前的所有子路径
完成一条路径后重新开始另一条路径时必须使用beginPath()开始子路径的一个新集合

如何使用Canvas画矩阵123ctx.rect(x, y,dx,dy)ctx.fillRect(x,y ,dx,dy)ctx.strockeRect(x, y ,w, h)


如何擦除当前区域： ctx.clearRect

如何画圆角：12345678ctx.arcTo(x1,y1,x2,y2,r)&#x2F;&#x2F;绘制的弧线与当前点和x1,y1连线，x1,y1和x2,y2连线都相切贝塞尔曲线：quadraticCureveTo(x1 ,x2,ex,ey)  二次贝塞尔曲线 x1,y1控制点，ex,ey结束点bezierCureveTo(x1,y1,x2,y2,ex,ey)  三次贝塞尔曲线x1 y1  x2 y2 控制点ex ey结束点

坐标轴的抓换12345678tanslate(dx,dy) 重新映射到画板上的（0,0）位置scale(sx,sy) 缩放当前绘图rotate(Math.PI)  旋转当前的绘图save()  restore()保存当前图像状态的一份拷贝从栈中弹出存储的图形状态并恢复setTransform(a,b,c,d,e,f)transform(a,b,c,d,e,f)  &#x2F;&#x2F;在之前的基础上变换

渐变 createLinearGradubt(x1,y1,x2,y2);线性渐变，必须在填充渐变区域里定义渐变，否则没有效果

createRadialGradient(x1, y1, r1, x2, y2, r2); 径向渐变bg.addColorStop(p.color)

阴影：1234ctx.shadowColorctx.shadowOffsetXctx.shadowOffsetYctx.shadowBlur
文本：
fillText();
strokeText();
measureText(‘helloworld’）

线段样式
lineCap
lineJoion

绘制图片：12ctx.drawImage();&#x2F;&#x2F;第一个参数是img(Image,canvas,video)

将canvas内容导出
canvas.toDataURL();  是canvas自身方法不是上下文对象
将canvas的内容抽取成一张照片，base64编码格式（注意同源策略）
将canvas内容放进img元素里

获取canvas像素信息123ctx.getImageData(x,y,dx,dy)crx.createImageData(w,h) 创建新的空白ImageData对象ctx.putImageData(imgData,x,y) 将图像数据放回画布上

SVG（Scalable Vector Graphics）可缩放适量图形
SVG应用场景:
图表
图标icon
动效
矢量图

使用svg画各种各样的图形：123456789101112131415161. 直线&lt;line x1&#x3D;&quot;100&quot; y1&#x3D;&quot;100&quot; x2&#x3D;&quot;200&quot; y2&#x3D;”100”&gt;&lt;&#x2F;line&gt;2. 矩形&lt;rect x&#x3D;&quot;50&quot; y&#x3D;&quot;50&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;100&quot; rx&#x3D;&quot;10&quot;ry&#x3D;&quot;20&quot;&gt;&lt;&#x2F;rect&gt;3. 圆形&lt;circle r&#x3D;&quot;50&quot; cx&#x3D;&quot;220&quot; cy&#x3D;&quot;100&quot;&gt;&lt;&#x2F;circle&gt;4. 椭圆&lt;ellipse rx&#x3D;&quot;100&quot; ry&#x3D;&quot;50&quot; cx&#x3D;&quot;100&quot; cy&#x3D;&quot;200&quot;&gt;&lt;&#x2F;ellipse&gt;5. 折线&lt;polyline points&#x3D;&quot;60 50, 75 35, 100 50, 125 35, 150 50,175 35, 190 50&quot;&gt;&lt;&#x2F;polyline&gt;6. 多边形&lt;polygon points&#x3D;&quot;125 125,130 140,120 140&quot;&gt;&lt;&#x2F;polygon&gt;7. ⽂本&lt;text x&#x3D;&quot;125&quot; y&#x3D;&quot;220&quot;&gt;hello,world&lt;&#x2F;text&gt;

path指令：（大写代表绝对定位，小写表示相对定位）12345678910M &#x3D; movetoL &#x3D; linetoH &#x3D; horizontal lineto 水平线V &#x3D; vertical lineto	垂直线C &#x3D; curveto 曲线S &#x3D; smooth curveto 平滑的曲线Q &#x3D; quadratic Belzier curve 二次贝塞尔曲线T &#x3D; smooth quadratic Belzier curveto 光滑贝塞尔曲线A &#x3D; elliptical Arc  椭圆弧Z &#x3D; closepath
SVG渐变
线性渐变
径向渐变

HTML5动画api requestAnimationFrame
页面刷新钱执行一次
1000ms 60fps -&gt; 16ms
cancelAnimationFrame
用法和setTimeout类似
兼容性(只在IE10以上的浏览器)用老浏览器就用setTimeout

123456789101112131415161718window.requestAnimFrame &#x3D; (function()&#123;  return window.requestAnimationFrame ||  window.webkitRequestAnimationFrame ||  window.mozRequestAnimationFrame ||  function( callback )&#123;  window.setTimeout(callback, 1000 &#x2F; 60);  &#125;;&#125;)();&#x2F;&#x2F;cancelAnimFrame()window.cancelAnimFrame &#x3D; (function()&#123;  return window.cancelAnimationFrame ||  window.webkitCancelAnimationFrame ||  window.mozCancelAnimationFrame ||  function( id)&#123;  window.clearTimeout(id);  &#125;;&#125;)();


客户端存储
Storage
localstorage (永久的)
sessionstorage(关闭浏览器就没有了)


cookie（存储容量很小，4K左右）

如何使用storage存储和读取数据12345localStorage.name &#x3D; &#39;admin&#39; &#x2F;&#x2F;存字符串localStorage.info &#x3D; JSON.stringify(&#123;name:&#39;admin&#39;，company:&#39;jizhu&#39;&#125;) &#x2F;&#x2F;存对象    var info &#x3D; JSON.parse(localStorage.obj);&#x2F;&#x2F;取出数据       console.log(info);

storage作用域
localSotrage -&gt; 文档源限制
sessionStorage -&gt; 文档源显示 + 窗口

storage 的API
setItem(name,val) 设置属性值
getItem(name) 获得属性值
removeItem(name) 移除属性
clear() 清除属性

cookie
存储信息到用户的设备上，数据量比较小
navigator.cookieEnable  监测是否开启了cookie

设置cookie值12345678910111213141516document.cookie &#x3D; “name&#x3D;aimee”&#x2F;&#x2F;（每次只能设置一个值，因为浏览器会认为后面的键值对是这个cookie的属性）document.cookie &#x3D; “name&#x3D;aimee”&#x2F;&#x2F;（每次只能设置一个值，因为浏览器会认为后面的键值对是这个cookie的属性）function getCookie(name) &#123;  var name &#x3D; name + &quot;&#x3D;&quot;;  var ca &#x3D; document.cookie.split(&#39;;&#39;);  for(var i&#x3D;0; i&lt;ca.length; i++) &#123;  var c &#x3D; ca[i];  while (c.charAt(0)&#x3D;&#x3D;&#39; &#39;) c &#x3D; c.substring(1);  if (c.indexOf(name) !&#x3D; -1) return c.substring(name.length, c.length);  &#125;  return &quot;&quot;;&#125;
cookie 与 storage的对比
history
history.back();
history.forward();
history.go(n)

通过修改hash和hashchange事件来实现历史纪录管理12345&#x2F;&#x2F;1、pushStatehistory.pushState(state, title, url); &#x2F;&#x2F;添加一条历史记录&#x2F;&#x2F;2、replaceStatehistory.replaceState(state, title, url);&#x2F;&#x2F; 替换当前的历史记录

worker(异步操作的api)12var worker &#x3D; new Worker(&#39;workder.js&#39;)&#x2F;&#x2F;https:&#x2F;&#x2F;www.w3school.com.cn&#x2F;html5&#x2F;html_5_webworkers.asp

geolocation
getCurrentPosition()     //获取当前的位置信息
getCurrentPosition(s,e,p)
success 回调 必须的
error  回调
option 参数


watchPosition()    //监视位置变化, 和1参数一样
clearWatch()  //清除位置监视

1window.navigator.geolocation.getCurrentPosition(suc)

PositionError对象
用户拒绝code = 1;
获取不到 code = 2;
连接超时 code  = 3;

配置参数enableHighAccuracy 是否需要高精度位置默认falsetimeout 单位ms 请求超时时间 默认infinitymaximumAge 单位ms，位置信息过期时间 设置为0就无条件获取新的地理位置信息 默认0https://dev.w3.org/geo/api/spec-source.html#position_options_interface
watchPosition12var id &#x3D; geolocation.watchPostion()  &#x2F;&#x2F;用于注册监听器，在设备的地理位置发生个改变的时候自动被调用clearWatch(id)  &#x2F;&#x2F;使用clearWatch 清除监听


devicemotion事件所包含的属性
accelerationIncludingGravity （包括重心引力）重力加速度
acceleration 重力加速度（需要陀螺仪支持）
rotationRate(alpha, beta, gamma)旋转速率
interval // 获取的时间间隔均为只读属性

多媒体：
audio 音频
video 视频12345678&lt;audio src&#x3D; &quot;.&#x2F;demo.mp3&quot; controls &#x3D; &gt;&lt;&#x2F;audio&gt;autoplay &#x2F;&#x2F;自动播放控件controls &#x2F;&#x2F;设置控件preload(none&#x2F;metadata&#x2F;auto)预加载metadata :元数据 诸如时长、比特率、帧大小这样的原数据而不是媒体内容需要加载的loop： 是否循环播放音频or视频poster:(video独有)，当视频不可用的时候，使用一张图片替代



多类型选择器：1234&lt;audio id&#x3D;&quot;music&quot;&gt;        &lt;source src&#x3D;&quot;成都.mp3&quot; type&#x3D;&quot;audio&#x2F;mpeg&quot;&gt; &#x2F;&#x2F;如果没有第一个，就播放第二个        &lt;source src&#x3D;&quot;成都.ogg&quot; type&#x3D;&#39;audio&#x2F;ogg&quot;&#39;&gt;        &lt;&#x2F;audio&gt;
脚本化：12345var audio &#x3D; document.getElementById(&#39;audio&#39;);var audio &#x3D; new Audio(&#39;.&#x2F;laojie.mp3&#39;);var audio &#x3D; document.createElement(&#39;video&#39;);

播放的方法
play() 方法
pause() 方法    //用于暂停
load()方法 用于重新加载视频/音频元素


表示播放音量，介于0(静音)~1(最大音量)之间，默认1。将muted属性设置为true则会进入静音模式，设置为false则会恢复之前指定的音量继续播放。超过范围会报错[0, 1]


播放速率playbackRate：用于指定媒体播放的速度。该属性值为1.0表示正常播放，大于1则表示快进，0-1之间表示慢放，负值表示回放。

currentTime/duration 属性
currentTime设置或返回音频视频的当前位置
duration 返回当前音频/视频的时常12345678910audio.currentTime &#x3D; 50;button.addEventLidtener(&#39;clkick&#39;,function()&#123;    consoloe.log(audio.currentTime)    &#125;)window.onload &#x3D;  function(&#123;    console.log(audio.duration);&#125;)




played/buffered/seekable
played属性返回已经播放(看过)的时间段，buffered属性返回当前已经缓冲的时间段，seekable属性则返回用户可以跳转的时间段。这三个属性都是TimeRanges对象，每个对象都有一个length属性以及start()和end()方法，length属性表示当前的一个时间段，start()与end()分别返回当前时间段的起始时间点和结束时间点(单位是秒，起始参数是0)


paused/seeking/ended这三个属性用来查询媒体播放状态，paused为true表示播放器暂停。seeking为true表示播放器正在调到一个新的播放点，如果播放器播放完媒体并且停下来，则ended属性为true。

canPlayType()方法12345var a &#x3D; new Audio();if(a.canPlayType(&quot;audio&#x2F;mp3&quot;))&#123;    a.src &#x3D; &quot;.&#x2F;chengdu.mp3&quot;;    a.play();&#125;


事件
play 开始播放触发
pause 暂停触发
loadedmetadata 浏览器获取完媒体的元数据触发
loadedata 浏览器已经加载完当前帧数据，准备播放时触发，注意兼容IE8
ended 当前播放结束后触发
readyState属性音频的当前就绪状态



drap  ＆ drop(常用语各种拖动操作中)创建可拖动元素1&lt;div id&#x3D;&quot;abc&quot; draggable&#x3D;&quot;true&quot;&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F;使用draggable之后就能够拖拽元素了关于拖拽的相关事件：
dragstart 被拖拽元素 开始被拖拽时触发  e.dataTransfer.setData(“data”,e.target.id)
dragend 被拖拽元素 拖拽完成时
dragenter 目标元素 拖曳元素进入目标元素
dragover 目标元素 拖拽元素在目标元素上移动
drop 目标元素 被拖拽的元素在目标元素上同时鼠标放开触发的事件
e.dataTransfer.getData(“data”)需要阻止dragover的默认行为才会触发drop事件123456789101112131415161718192021    &lt;script&gt;        var item &#x3D; document.getElementById(&quot;abc&quot;);        item.addEventListener(&#39;dragstart&#39;,function()&#123;            console.log(&quot;akshd&quot;)        &#125;)    var itemO &#x3D; document.getElementById(&quot;wrapper&quot;);        itemO.addEventListener(&#39;dragenter&#39;,function()&#123;            console.log(&#39;dragenter&#39;)        &#125;)&#x2F;&#x2F;这个是写在被进入的元素里面    &lt;&#x2F;script&gt;DragEvent 事件对象&#x2F;&#x2F;传值e.dataTranSfer.setData(&quot;data&quot;,e.target.id)&#x2F;&#x2F;取值 e.dataTransfer.getData(&quot;data&quot;)



FileReader 读取文件
abrot() 终止读取
readAsBinaryString(file) 将文件读取为二进制编码
readAsDataURL(file)     将文件读取为DataURL编码
readAsText(file,[encoding]) 将文件读取为文本
readAsArrayBuffer(file)  将文本读取为arraybuffer 通过不同的方式读取文件

FileReader 事件
onloadstart 读取开始时触发
onprogress 读取中
onloadend 读取完成，无论成功或失败
onload  文件读取成功完成时触发
onabort 中断时触发
onerror 出错时触发1234获取读取的结果fr.onload  &#x3D; function()&#123;    tihs.result;&#125;











Web Socket（是一个新的协议）
WebSocket 对象提供了一组 API，用于创建和管理 WebSocket 连接,​​​​​​​以及通过连接发送和接收数据.Websocket 其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已.借用了HTTP的协议来完成握手

产生背景：
在 HTTP/1.0 中,大多实现为每个请求/响应交换使用新的连接
在 HTTP/1.1 中,一个连接可用于一次或多次请求/响应交换
HTTP协议中，服务端不能主动联系客户端，只能有客户端发起。
webSoket服务器和客户端均可主动发送数据

建立连接的握手：
当Web应用程序调用new WebSocket(url)接口时，Browser就开始了与地址为url的WebServer建立握手连接的过程。
Browser与WebSocket服务器通过TCP握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用程序将收到错误消息通知。
在TCP建立连接成功后，Browser通过http协议传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端。
WebSocket服务器收到Browser发送来的请求后，如果数据包数据和格式正确，客户端和服务器端的协议版本号匹配等等，就接受本次握手连接，并给出相应的数据回复，同样回复的数据包也是采用http协议传输。
Browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发onopen消息，此时Web开发者就可以在此时通过send接口向服务器发送数据。否则，握手连接失败，Web应用程序会收到onerror消息，并且能知道连接失败的原因。

12创建webSocketvar Socket &#x3D; new WebSocket(url)


webSocket方法12Socket.send() 方法使用连接传输数据socket.close()  方法用于终止任何现有连接

webSocket的优点
客户端与服务器都可以主动传递数据给对方
不用频率创建TCP请求及销毁请求，减少网络带宽资源的占用，同时也节省服务器资源



</section>
    <p class="sub">Sep 2, 2019</p>
  </div>
</div>
  
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/blog/2019/08/12/ES6/" class="title">ES6</a>
    <section class="desc">
  ES6学习笔记ES6语法的一个特性块级作用域：{
}
LET命令
LET声明的变量具有块级作用域的概念12345678&#123;    console.log(typeof a)&#x2F;&#x2F;Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization    let a &#x3D; 42;    var b &#x3D; 1212;    console.log(typeof a)  &#x2F;&#x2F;number&#125;        console.log(typeof a)  &#x2F;&#x2F;underfind




不存在变量提升。在Let声明之前使用就会报错
暂时性死区：只要块级作用域内存在let命令，它所在的变量就“绑定”这个区域，不再受外部的影响
不允许重复声明
注意：因为let的不存在变量提升和暂时性死区，因此在let之前使用该变量会报错，在此变量作用域外使用会无效。



const命令1. const声明一个只读常量，一旦声明，常量的值就不能更改
2. const变量只声明不赋值就会报错
3. 只在作用域内生效以及不允许重复声明
4. const变量不能更改的实质是变量指向的那个内存地址所保存的数据不得改动.12345678910111213141516171819202122 const foo &#x3D; &#123;&#125;;     foo.prop &#x3D; 123;&#x2F;&#x2F;添加一个属性，没有问题     console.log(foo.prop)     foo&#x3D; 123;&#x2F;&#x2F;就会报错&#x2F;&#x2F; 浏览器的 ES6 环境function f() &#123; console.log(&#39;I am outside!&#39;); &#125;(function () &#123;  if (false) &#123;    &#x2F;&#x2F; 重复声明一次函数f    function f() &#123; console.log(&#39;I am inside!&#39;); &#125;  &#125;  f();&#125;());&#x2F;&#x2F;上面在ES6代码当中会报错，ES6规定，浏览器始兴县要遵循一些规定&#x2F;&#x2F;1.允许在块级作用于内声明函数&#x2F;&#x2F;2.函数声明类似于var ,即会提升到全局作用于函数作用于的头部&#x2F;&#x2F;3.同时，函数声明还会提升到所在的块级作用于的头部注意：以上三条规则只对ES6浏览器内有效，其他环境还是将块级作用于的函数声明当做let处理

注意：在ES6中一共有6种赋值的方式，有var 和 function 命令，还有let 和const命令，以及import和class命令。var 和 function 命令声明的全局变量是顶层对象的属性；let、const和class命令声明全局变量，不属于顶层对象的属性。 

变量的解构赋值
数组的解构赋值
概念：ES6允许按照一定的模式，从数组和对象中提取，对变量进行赋值注意：要是被赋值一边有一项没有被赋值或者赋值underfind，则被称为解构失败；要是赋值一边有三个值，被赋值一边只有两个变量，则被称为不完全解构
匹配模式其实是懒散匹配，如第6行代码，如果赋值一方对应位置有值，x就不会管默认值是10,而当赋值一边【】啥都没有的时候，才取默认值123456789101112131415161718192021222324252627&#x2F;&#x2F;模式匹配let [a , b, c] &#x3D; [1, 2, 3]let [a ,[b,[c]]] &#x3D; [1,[2,[3]]]let [x &#x3D; 10] &#x3D;[20] &#x2F;&#x2F;x &#x3D; 20 对象的解构赋值无序性：只要变量与属性同名，就能取到正确的值。当右边没有同名的属性，那么不叫取不到值而取得underfindlet &#123;bar ,foo &#125; &#x3D; &#123;foo :234, bar:123&#125;&#x2F;&#x2F;无论赋值的一方的顺序是怎么样的，赋值都不影响let &#123;foo:bar&#125; &#x3D; &#123;foo:123&#125;        console.log(bar);&#x2F;&#x2F;123        console.log(foo);&#x2F;&#x2F; foo is not defined                let&#123;length&#125; &#x3D; &quot;123&quot; &#x2F;&#x2F;length &#x3D; 3                &#x2F;&#x2F;可用于嵌套let obj &#x3D; &#123;  p: [    &#39;abcabc&#39;,    &#123; y: &#39;123123&#39; &#125;  ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; &#x3D; obj;&#x2F;&#x2F;&#39;abcabc&#39; &#39;123123&#39;
字符串的解构赋值123456789const [a,b,c,d,e] &#x3D; &#39;hello&#39;;                console.log(a);        console.log(b);        console.log(d);        let&#123; length :len&#125; &#x3D; &#39;hello&#39;        console.log(len)&#x2F;&#x2F; a b l 5



数值和布尔值的解构赋值1234567解构赋值时，如果等号右边是数值和布尔值，则会先转换成对象函数参数的解构赋值        function add([x,y])&#123;            return x + y;        &#125;        add([1,2])



不能使用圆括号的情况：使用场景：


交换变量的值
从函数返回多个值

123456function example()&#123;    return [1,2,3];&#125;let [a,b,c] &#x3D; example();console.log(a,b,c) &#x2F;&#x2F;1 2 3


提取JSON数据–解构赋值对提取JSON对象中的数据，尤其有用

便利Map结构：部署了Iterator接口的对象，都可以用for…of循环遍历。配合变量的解构赋值，获取键名和键值就肥肠方便
字符串的扩展
字符串的遍历器接口
123456a &#x3D; &#96;hzfnb&#96;;for(let  condePoint of a )&#123;    console.log(condePoint)&#125;        &#x2F;&#x2F; h z f n b

模板字符串

增强字符串:可以保留字符串在编辑器的模式 ，如果代码中的模板字符串都要用反引号表示，则前面需要用反斜杠转义

在字符串中添加变量（表达式）
赋值
${}对变量进行抓取

${} 对变量进行运算
12345678910111213141516171819202122232425262728var str &#x3D; &#39;hello&#39;;var newStr &#x3D; &#96;hello world&#96;; var xm &#x3D; &#123;            age :19,            height:180,            name :&#39;xiaoming&#39;        &#125;                var &#123;age ,name, height&#125; &#x3D; xm;        var newstr &#x3D;&#96;name: $&#123;name&#125; age: $&#123;age&#125; &#96;        console.log(newstr);&#x2F;&#x2F;通过对象的解构拿到对象的值， 再通过$&#123;&#125;直接取得这个值        &#x2F;&#x2F;$&#123;&#125;也是可以进行运算的，还可以添加方法                var x &#x3D; 3, y &#x3D; 5;        function getName()&#123;            return &#39;xiaoming&#39;;        &#125;        var str &#x3D; &#96;my name is $&#123;getName()&#125;&#96;;        console.log(str);                                var arr &#x3D; [1,2,3,4,5];        var resStr &#x3D;&#96;$&#123;arr.map(function(item,index)&#123;            return &#96;$&#123;item&#125;: $&#123;index&#125;&#96;        &#125;)&#125;&#96;&#x2F;&#x2F;通过增强字符串与函数把值赋给另外一个变量（对象）



标签模板
它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串标签模板的实质，函数调用的特殊形式重要应用，过滤HTML字符串–防止用户恶意注意内容12345678910safeHtml &#96;&lt;p&gt;$&#123;name&#125; Welcome&lt;&#x2F;p&gt;&#96;function safeHtml(data)&#123;    var str &#x3D;  data[0]    for(let i &#x3D; 1; i&lt;arguments.length;i++)&#123;        var arg &#x3D; String(arguments[i])        str +&#x3D; arg.replace(&#x2F;&amp;&#x2F;g,&#39;&amp;&#39;).replace(&#39;&#x2F;&lt;&#x2F;&#39;)    &#125;&#125;





字符串的新增方法123456789101112131415String.fromCodePoint() --用于从Unicode编码返回对应的字符串String.raw()		--用于转义字符串，往往用于模板字符串的处理方法        a &#x3D; String.raw&#96;hi\n\n$&#123;5&#125;!&#96;        console.log(a); &#x2F;&#x2F;hi\n\n5!                &#x2F;&#x2F;String.raw 作为正常的函数使用        a &#x3D; String.raw(&#123;raw:&#39;hzfnb&#39;&#125;,0,1,2)        console.log(a); &#x2F;&#x2F;h0z1f2nb&#96;&#96;&#96;       1. 实例方法：codePointAt() --测试一个字符由两字节还是四个字节组成的最简单方法2. 实例方法：normailza()3. includes(): 返回布尔值，表示是否找到了参数字符串4. startsWith() ： 返回布尔值，表示参数字符串是否在原字符串的头部5. endWith(): 返回布尔值，表示参数字符串是否在原字符串尾部
var a = &quot;hzfnb zf&quot;
var r1 = a.includes(&apos;hzfnb&apos;)
var r2 = a.startsWith(&apos;h&apos;)
var r3 = a.endsWith(&apos;f&apos;)

console.log(r1,r2,r3)//true true true126. 实例方法： repeat()返回一个新的字符串，并将原字符串重复N次7. 实例方法：padStart() padEnd()：接受两个参数，第一个参数是字符串补全的位数，第二个填的是要补全的字符串
padStart() 用于补全头部padEnd()  用于补全尾部        console.log(‘hzf’.padStart(5,’nb’)) //hzfnb
123456789101112131415161718198. 实例方法：trimStart() , trimEnd();分别用于消除字符串最前面的空格以及最后面的空格9. 实例方法：matchAll()方法返回一个正则表达式在当前字符串的所有匹配### 正则表达式的扩展#### 字符串的正则方法1. match()2. replace()3. search()4. split()5. u修饰符:含义为unicode模式，用来处理四个字节的UTF-16编码6. 点字符7. i修饰符8. y修饰符### 函数的扩展函数的默认值
function Persion(name ,age = 100){            console.log(name,age)        }Persion(‘hs’); // hs 100Persion(‘hs’,12); // hs 12
默认值与解构赋值的使用  function f1( {x = 0, y = 0} ={}){           console.log(x,y)        }
function f2({x,y} = {x:0,y:0}){
    console.log(x,y)
}

f1()
f2()
f1({x:1,y:2})
f2({x:1,y:2})
f1({x:1})
f2({x:1})

//0 0
//0 0 //1 2//1 2//1 0//1 undefined   最后一个解构赋值之后表示为 {x:1} 所以y = underfined
参数作用域已经注意事项在函数体内用let定义的变量，不能提前当做参数（放在括号内）es6在参数默认值方面是使用let来定义的RESTvar arr = [1,2,3,4,5];        fn.call(null,…arr) //…相当于把括号去掉        fn.apply(null,arr) //apply 要用数组的形式引入
// (5) [1, 2, 3, 4, 5]
// (5) [1, 2, 3, 4, 5]

function fn(...args){
    console.log(args)
}12### 箭头函数&gt; 注意事项：箭头函数里面没有this这个对象，它只会依次找到父级，也没有arguments
var f =            ()   =&gt;   numvar f = function  参数      return 参数
//箭头函数的嵌套 function fn(str){         return function(){                return str.splite(``)         }     }
var fn = str =&gt; () =&gt;str.splite(``)123### 数组的扩展### 数组的合并
var arr = [‘dy1’]        var arr1 = [‘1,2,3,4,5’]        var arr2 = [‘false’,NaN]        var newArr = […arr,…arr1,…arr2]        console.log(newArr)//[“dy1”, “1,2,3,4,5”, “false”, NaN]
var arr3 = [...&apos;hzf&apos;]
console.log(arr3);//[&quot;h&quot;, &quot;z&quot;, &quot;f&quot;]Array.from()把类数组和可遍历的对象转换成数组Array.of() 数组实例的方法copyWithin()   var arr = [1,2,3,4,5]    // Array.prototype.copyWithin(target ,start = 0,end = this.length))       console.log (arr.copyWithin(0,3))       // 0 3 还有一位end没写出来，0代表从第0位开始，3代表start=3, 第三位是4 end 没写表示到一直最后，       //表示从4,5替换掉从0开始的两位 因此结果 = 4,5,3,4,5
123456### 数组实例方法#### fill() , entries()，keys()   values()1. entries() 是对键值对的遍历2. values() 是对键值的遍历3. key() 是对键名的遍历
 var arr = [1,2,3,4,5]        var a = arr.keys()        console.log(a) //Array Iterator {}
var arr1 = new Array(5);
arr1.fill(7,3,4)
console.log(arr1)  //(5) [empty x 3 ,7 empty x 3] 
//fill的用法是添加某个数，用法跟copywithin()差不多，
//添加7这个数字，在第3跟第4个数之间插入数字7

var arr2 = [&apos;2&apos;,2,3,4,5]
var a = arr2.keys()

for([item, index] of arr.entries())
{   
    console.log(item ,index)
}
//entries 可以用于遍历数组，列出是第几位的并且把值打印出来
//  0 &quot;2&quot;
//  1  2
//  2  3123456### 数组的实例方法 #### includes() find() findIndex()1. includes() ——返回一个布尔值，表示某个数组是否包含给定的值。如果包含则返回true，否则返回false2. find() ——找到第一个符合条件的数组成员3. findIndex() 返回第一个负荷而条件的数组成员的位置
var arr = [20 , 4, -5, 10]        var str = [arr.find((n) =&gt; n &lt;19)]        console.log(str)    //[4]
12### 对象的扩展
属性的简洁表示法 var foo = ‘123’ var bar = {foo}
123##### 属性的可枚举性以及属性的遍历1. 对象的每个属性都有一个遍历对象（Descriptor）用来控制该属性的行为
var obj = {age :123,name:’dv’}
console.log(Object.getOwnPropertyDescriptor(Object.prototype,’toString’))//enumerable: false 说明不可枚举
1234567891011&gt; 但是有4种操作会忽略enumerable 为flase的属性&gt; 1. for... in 循环：遍历对象自身的和继承的可枚举属性&gt; 2. object.keys()  返回对象自身的所有可枚举的属性的键名&gt; 3. JSON.stringify() 只串行话独享自身的可枚举属性&gt; 4. object.assign() （ES6新增）### 对象的新增方法1. Object.is()ES5判断两个值知否相等只有 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;。它们的缺点在于， &#x3D;&#x3D; 回自动转换数据类型， &#x3D;&#x3D;&#x3D; 会使得Nan不等于自身，-0 不等于 +0
object.is()       console.log (Object.is(-0,+0))      //false       console.log (Object.is(NaN,NaN))    //true
1234### Class类&gt; class 一定要先定义再使用
class Person{
    constructor( name=&apos;zf&apos;,age = 18){
        this.name = name
        this.age = age
    } //这里不能写  &apos;,&apos; 写了就报错 
    show(){
        console.log(this.age,this.name)
    }
}

var per = new Person()
// per.name 表示实例属性立即执行classvar p = new class{ //这个类只能使用一次        }
12345678910### this指向 &#x3D;&gt; 指向父级作用域，跟ES5里面的this指向有些不同### 静态方法### 静态属性	### 继承&gt; 与es5的不同之处&gt;1. 子类 __proto__表示构造函数的继承&gt;2. 子类 __proto__.prototype 表示方法的继承&gt;3. 注意：__proto__并不属实语言本身的特征，目前很多浏览器的JS引擎都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，推荐使用Object.getPrototypeof()来获取实例对象的原型，再为原型添加属性
class A{            constructor(){                this.name = ‘zf’            }            print(){                console.log(this.name)//console.log(‘father A’)            }        }        class B extends A{            constructor(){                super() //为啥要调用super？                //子类要调用super方法，才能使用this，给父级绑定才有this                this.name = ‘aasda’            }            print(){                super.print() //b.print() -&gt; father A            }        }
var b = new B()
// b.name = &apos;aasda&apos;
// b.print() aasda 1234567### Promise对象#### Promise的含义：简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常来说是一个异步操作。）1. 基本用法2. 三种状态    1. pending 就绪状态    2. resolved 成功状态    3. rejected 失败状态
实例方法Promise.all Promise.race
```


</section>
    <p class="sub">Aug 12, 2019</p>
  </div>
</div>
  
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/blog/2019/05/12/CSS3-note/" class="title">CSS3学习笔记</a>
    <section class="desc">
  CSS3学习笔记CSS33只是版本号，目前主流浏览器都支持了，IE10以后也开始全面支持CSS3。

CSS3提供了更加强大的且精准的选择器，提供多种背景填充方案，可以实现渐变颜色，可以改变元素的形状，角度等。可以加阴影效果，报纸布局，弹性盒子，ie6混杂模式的盒模型，新的计量单位，动画效果等但CSS3并不是所有属性都通过了W3C标准，要查兼容性手册。

CSS3的特性
border-radius –圆角，实现一个叶子的形状，画一个半圆 
1100px 100px 0 0；

box-shadow  盒子的阴影  box-shadow   x代表偏移量，y代表偏移量， ，阴影模糊半径，阴影扩展半径，阴影颜色，投影方式text-shadow==不过shodow都是性能杀手==



线性渐变 语法：linear-gradient[方向，颜色，颜色，颜色…]

径向渐变 语法：
1radial-gradient(shape at position ,color[percent ] ,color)

shape ：放射的形状，可以为原型circle 或拖延ellipse,position 为圆心位置

border-image

border-origin:content-box / border-box / padding-box

background-clip : 
1border-box &#x2F; padding-box &#x2F;conteent-box  &#x2F;no-clip
参数分别从边框，或内填充，或内容区域向外剪裁背景

text :background-clip :text;

background-size :auto |&lt;长度值&gt;|&lt;百分比&gt;

background-position: center


CSS3 选择器：属性选择器
E[att ^= “val” ]{….}  选择匹配元素E，且E元素定义了属性att ，其属性值以val 开头的任何字符串
E[att $= “val”]{….} 选择匹配元素E ，且E元素定义了属性att ,其属性以val为结尾的任何字符串
E[att *= “val”]{….}  选择匹配元素E， 且E元素定义了属性att ，其属性值任意位置出现了’val’ ,即属性值包含了“val”，位置不限。
~=的意思是只要有item 的元素都被选中了。

伪类选择器伪元素选择：伪元素的效果是需要通过添加一个实际的元素才能达到的.
CSS3 对伪元素进行一定的调整，在以前的基础上增加了一个：也就是
1::first-letter, ::first-line ,::before ::after

另外还增加了一个 ::selection 
root选择器等同于html ,但权重比html更高
not 选择器除了那一个，其他都选中
empty 空标签选择器target 目标元素选择器被锚点的元素，被选中的元素被进行操作。
伪类选择器：
first-child 第一个子元素
last-child 最后一个子元素
:nth-child（）{}  第XXX个子元素，n代表变量自然数
first-of-type 第一个子元素
:last-of-child 最后一个子元素
:only-of-type  唯一一个子元素

表示状态的伪类选择器
12:enabled 可用的元素:disabled  禁用的元素

有些表单元素才会有这样的元素，例如输入框，密码框，复选框
:check  已经被选中的状态   check-boxread-only  选中只读的元素
伪元素选择器::first-letter  首个字母:first-line 首行::selection  被选中时候的文本
条件选择器E &gt; F 直接子元素选择器 E + F  后面紧挨着的兄弟节点 E ~ F 后面的兄弟节点
例如单选框旁的div ，被选中的时候隔壁也被选中。 input:checked + div
CSS3 动画形状变换
transform 可以实现元素的形状，角度，位置等变化（包括旋转）。transform: rotateX /Y/ Z(  deg);不写默认是Z。
rotate3d(x , y, z, Angel)
scale () 以x/y 轴进行缩放    
scale(x,y)接受两个值，如果第二个参数未提供，则第二个参数使用第一个参数的值。
skew() 对元素进行倾斜扭曲shew（） 接受两个值，分别对应X轴 和Y轴， 如果第二个参数未提供，则默认为0；
translate(x ,[y])  移动
使用CSS3属性实现水平垂直居中当使用：

12top: 50%;left: 50%;， 是以左上角为原点，故不处于中心位置。    translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。


transition 过渡动画

1transition 第一项选择属性(什么width height fontsize opacity ，就是一项属性，用于监听)，第二项选择时间，第三项选择速度，第四项指定过渡函数，第五项为动画的延迟时间



animation  动画
animation-iteration-count   属性主要用来定义动画的播放次数
animation-direction 。normal 正常播放， reverse 反向播放
animation-play-state 用来控制动画的播放状态 running播放，paused 暂停。



CSS 多列布局为了能在Web页面中方便实现类似报纸，杂志那种多列排版的布局，W3C特意给CSS3增加了一个多列布局。语法： 
12columns:[column-width][column-count]  columns:2;  变成两列column-gap ：
 设置列与列之间的宽度，直接用数值即可（eg:10px）column-span  设置多列布局的子元素可以跨列，类似标题效果。 
CSS3 盒模型：IE6混杂模式，首先要触发一个怪异模式。 在IE6混杂模式盒模型下(IE6及以下浏览器)，内容宽度（盒子） = width - padding -border.width包含padding 和 borderW3C标准下的空间高度（盒子）= width +padding +border;  width 为内容宽度，不包括padding 和 border
CSS3 弹性盒子 display :flex==flex为复合属性，必须配合父元素display :flex使用==如图


6个属性
flex-grow    把盒子分成多少份，要是1 的话就分成1分自己独占。默认是0；

flex-shrink 多出盒子的部分，按照比例的大小砍掉相应的大小，即比例越大，被砍的越大。

flex-basis    伸缩基准值，占据主轴空间。

flex    order    可以进行排序，从小到大进行排列

1234align-self &#123;auto &#x2F; flex-start &#x2F;flex-end  &#x2F; center &#x2F;baseline（基准线对齐） &#x2F;stretch &#125;主轴 &#x2F;侧轴&#x2F;交叉轴

flex-direction 决定主轴的方向row 从左向右， row-reverse , column ,column-reverse

flex-wrap 是否换行    

flex-flow 是dirction 和 wrap的简写方式

justify-content 1.flex-start    左对齐

flex-end    右对齐
conter     居中
space-between    两端对齐，项目之间的间隔都相等
space-around 每个项目两侧的间隔相等。
align-items  属性如何在侧轴上对齐
flex-start 交叉轴的起点对齐。
flex-end 交叉轴终点对齐
center 交叉轴中点对齐
baseline 项目的第一行文字基准线对齐
stretch 如果未设置高度或设为auton ,将占满整个容器的高度



transparent 透明色颜色值。
CSS3响应式布局通过设备不同的宽度，相应出不同的布局。这就叫做响应式布局。
123&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; width&#x3D;device-width 意思是宽度等于设备的宽度，user-scalable &#x3D; no 意思是不允许用户缩放

媒体查询：媒体查询是向不同设备提供不同样式的一种方式，为每种类型的用户提供了更佳的体验。CSS2 :mdeia type 是CSS2中一个非常有用的属性，通过media type 我们可以对不同设备执行不同的样式CSS3 mdeia query 是CSS3对meida type的增强。
添加方式：
12第一种插入样式，需要多个CSS文件&lt;link rel&#x3D;&quot;stylesheet&quot; media&#x3D;&quot;screen and (max-width:800px)&quot; href&#x3D;&quot;.&#x2F;text.css&quot;&gt;

第二种插入方式
123456789101112131415@media screen and (max-width:300px)&#123;    div&#123;        width: 200px;        height: 200px;        background-color: blue;    &#125;&#125;@media screen and (min-width:301px)&#123;    div&#123;        width: 499px;        height: 293px;        background-color: aqua;    &#125;&#125;

and not only 这三个值。only是仅有的意思。 and是再添加这个属性的意思
demo–&gt;从四列变三列再变成两列一列的CSS3响应式布局
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124.wrapper&#123;    display: flex;    width: 100%;    flex-wrap: wrap;&#125;.wrapper div&#123;    width: 20%;    display: inline-block;    flex-grow: 1;&#125;.wrapper div img&#123;    width:100%;&#125;@media screen and (max-width:1000px)&#123;    .wrapper div&#123;        width: 25%;    &#125;&#125;@media screen and (max-width:800px)&#123;    .wrapper div&#123;        width: 33.33%;    &#125;&#125;@media screen and (max-width:400px)&#123;    .wrapper div&#123;        width: 50%;    &#125;&#125;@media screen and (max-width:200px)&#123;    .wrapper div&#123;        width: 100%;    &#125;&#125;CSS3动画transform-style ：flat | preserve-3d； 注意：属性需要设置在父元素中，高于任何嵌套的变形元素。设置了tranform-style :preserve-3d的原型，就不能设置overflow:hidden 否则preserve-3d失效元素旋转，其他轴也在旋转translate3d 这样写好了之后浏览器就会使用GPU加速。下图代码块为爱的魔力转圈圈    &lt;style&gt;        .wrapper&#123;                 position: relative;            width: 200px;            height: 200px;            margin: 0 auto;            transform-style: preserve-3d;            &#x2F;* transform: rotateX(-20deg); *&#x2F;            margin-top: 200px;            animation: turn 5s linear infinite;        &#125;        .wrapper div&#123;            position: absolute;            top: 0;            width: 200px;            height: 200px;            opacity: 0.5;            text-align: center;            line-height: 200px;            color :#fff;            font-size: 30px;        &#125;        .wrapper .item:nth-of-type(1)&#123;            background-color: red;            transform: rotateY(0deg) translateZ(200px);        &#125;        .wrapper .item:nth-of-type(2)&#123;            background-color: yellow;            transform: rotateY(60deg) translateZ(200px);        &#125;        .wrapper .item:nth-of-type(3)&#123;            background-color: green;            transform: rotateY(120deg) translateZ(200px);        &#125;        .wrapper .item:nth-of-type(4)&#123;            background-color: blueviolet;            transform: rotateY(180deg) translateZ(200px);        &#125;        .wrapper .item:nth-of-type(5)&#123;            background-color: pink;            transform: rotateY(240deg)translateZ(200px);        &#125;        .wrapper .item:nth-of-type(6)&#123;            background-color: yellowgreen;            transform: rotateY(300deg) translateZ(200px);        &#125;        @keyframes turn&#123;            0%&#123;                transform:rotateX(-20deg) rotateY(0deg);            &#125;            100%&#123;                transform:rotateX(-20deg) rotateY(-360deg);            &#125;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div class&#x3D;&quot;wrapper&quot;&gt;        &lt;div class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;item&quot;&gt;6&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;


</section>
    <p class="sub">May 12, 2019</p>
  </div>
</div>
  
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/blog/2019/05/12/JQuery-note/" class="title">JQuery笔记</a>
    <section class="desc">
  JQuery学习笔记jQuery是啥呢？它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。
jQuery的用法：选择元素：
$(); 里面和CSS一样，不过对选择出的一组元素，一起处理，省略循环，这里是js不允许的。
里面可以写CSS选择器原生dmo,jQuery对象、 null  /undefind / function(){}    selector/content等
jQuery特有的选择规则，选出来是jquery对象
filter可以用来筛选，例如说筛选类名。not的话可以用来反向选择，没有这一项的就被选中，is则相反。has说明里面有这一项的选项被选中。find跟has的区别是，找到这里有这一项的然后选中。
jQuery可以进行链式操作。 
sizzle是用来选择特殊写法的，是查到dom最快的方式。

函数写法：
都是函数式的写法。
CSS取值相当于getComputed，赋值相当于1dom.style.***
，就写width，然后啥也不写
css赋值一组，取值取一个（）
xxx.setAttribute(‘son’,’’Feng)  这样就可以给对象添加属性了。  
attr() 用于设置或返回被选中元素的属性值
prop() 如果是检索html元素则使用attr()替代。
next()下一个兄弟节点。
prev()上一个兄弟节点
index 当前兄弟节点
addClass removeClass
toggleClass 删除或者添加类名  没有的话帮你添加，有话帮你删除
insertBefore  插入到谁谁的前面。
appendTo()   –这个比较常用12A添加到B的里面（添加到最后一个子元素后） $(&#39;p&#39;).appendTo($(&#39;ul&#39;)D.append（C）  D里加上C
remove detach 可以删除元素并且可以return 删除的元素。remove的话点击删除之后也删除了方法，因此第二次点击不能再删除了，而detach则可以。不断的进行删除和添加
on方法绑定时间 

1.on(&#39;click&#39; ,&#39;a&#39;, function()&#123;&#125;)  &#x2F;&#x2F;off可以解除绑定 $(&#39;.item&#39;).off(&#39;click&#39;), 如果想指定解绑的元素，那就要传值以更精准

one() 只绑定之间一次scrollTop()  滚出去的高度 
动态生成标签 1$(&#39;&lt;div&gt;&lt;&#x2F;div&gt;&#39;)
经常用于动态添加图片或者选项框

关于事件：
时间对象 e-&gt;e.pageX 相对文档而言，e.clinetX 相对于浏览窗口而言。 e.which 哪个键或按钮  e.button哪个鼠标按键被按

e.preventDefalut()  s.stopPrpagation()  return false;  这些都是用来解绑事件的

offset().left/top position().left/top。

offset()方法返回或设置匹配元素相对于文档的偏移（位置）。


parent() 返回父节点 

offsetParent() 返回离它最近有定位的父级        

paerents()  返回多个父级

closet()  查找最近的祖先节点        

val是jQuery里面代表.value的参数

each 遍历 
1$(&#39;li&#39;)each(function (index  , ele )&#123;&#125; )

end() 回退操作,可以使jQuery 可以连续实现点操作。就说可以用一行代码搞定。

slblings()  当前元素节点的所有兄弟节点

1$(&#39;li.third-item&#39;).siblings().css(&#39;background-color&#39;, &#39;red&#39;);



prevAll()  当前元素上面的所有兄弟节点

nextAll() 当前元素下面的所有兄弟节点 

prevUntil()  nextUntil() 掐头去尾选中元素，传jQuery 对象dom

clone 克隆节点，参数为true的时候，事件也能克隆

wrap 包裹的意思  wrapall    包裹选中所有的元素 会破坏结构  unwrap 接触包装，接过话标签不能删除。

A.add(B)  选中元素A和B集中操作。

slice(0，2)  截取，算头不算尾

serialize 串联表单数据 serializeArray 串联数据成数组

animate()

参数target  
参数durition    
参数代表速度变化方式  
回调函数


stop(true, true) 停止当前所有的运动，停在当前目标带点  ,后面的参数决定是否立即到达目标点上  

是否停止后续所有运动     false：不停止，继续运动  true :停止后续所有运动
是否立即到达当前目标点     flase :不到达    true：到达



22.stop（flase ,true） 跳过当前运动并到达目标点，执行后续运动

finish()  停止当前运动  

delay （）延迟，参数，延迟运动   
1jquery.easing.js 是专门用来做jQuery 运动的.

slideToggle(speed ,callback)  通过滑动效果来切换元素的可见状态

sildeUp   sildedown   隐藏起来元素/显示元素——根据之前的不同状态进行切换- none–block  or  block–none

toggleClass(active)  对设置或移除备选元素的一个或多个类进行切换

fade in/out   淡入淡出

tigger 方法触发被选元素的指定事件类型。==tigger出发事件是会冒泡，触发里面会影响外面  tigger可以触发自定义事件==  


工具方法：1以$.xxx  jQuery.xxx这种方式调用 ，此类方法定位在jQuery 函数上面

$.type()  判断 参数的数据类型 原生js判断类型的三种方法：
1231. arr.instanceof Aarray  2. arr.constructor &#x3D;&#x3D;Array  3. Object.prototype.toString.call(arr)

1,2两种有局限性，3 比较通用
trim()方法
1$.trim 消除空格


$proxy() 改变this指针方向 参数1：function , 参数2：函数执行期上下文。
$noConflict() 防止冲突 在很多javascript库使用$作为一个函数或变量名，正如我们同时需要使用jQuery和其他库一样，我们可以使用$.noConfilct把$控制权交给其他库。
$.parseJSON()  字符转换成json ,要求非常严格，外部是单引号，内部属性是双引号，不需要回车符
$.makeArray 把类数组转换成数组。
jQuery高级方法：$.extend()  插件扩展1 提供最新的jQuery 工具方法
$.fn.extend()  插件扩展2 提供最新的jQuery 实例方法，是实例不是工具方法 
1编写方法1， $.extend(&#123;keftTrim :function ()&#123;&#125;&#125;)

12.fn.extend(&#123;drag : function()&#125;)


13. var cd &#x3D; $.Callback()   回调函数--》返回回调对象


14. once 只执行一次fire()  方法 放在回调函数的参数里面。

123var cd &#x3D; $.Callbacks(&#39;once&#39;);cd.add(fn1 ,fn2 ,fn3);cd.fire();


memory记忆  前面触发函数，后面添加也会被添加并触发  unique也是只执行一遍
$.Deferred() 延迟对象相当于有状态的Callbacks();
添加函数；
12done		fail		progress		触发成功，   失败 ，    进行中

触发函数：resolve          reject    notify
$.deferred.promise() —-&gt;不能触发函数（无状态）
$(when) —-&gt;返回的是延迟对象，参数也是延迟对象。当参数延迟对象全部触发done的时候最后会触发when返回延迟对象的done函数。

延迟对象作用控制的关键点，做链式运动的效果
$.ajax这种有状态的异步操作核心是deferred 
when当发生多个ajax请求的时候，因为都是异步的，所以可以用多个deferred ，每当ajax 成功后我们触发一个，最后全部成功在when后一并处理。

$() 里面可以填什么
1234$(false &#x2F;null &#x2F;undefined)  $(&#39;&lt;li&gt;,&lt;&#x2F;li&gt;&#39;)   $(&lt;li&#x2F;&gt;s1234)  $(&#39;&lt;li&gt;&#39;, &#123;html : 123 ,dg :&#39; ds&#39;&#125;)$(&#39;#id&#39; &#x2F;  &#39;.class&#39;   &#x2F;  div &#x2F; ul &#x2F;li &#x2F;    li:eq(0)) $(dom)
//在JQuery中，init()函数里面会判断返回的类型，如果是DOM则是因为后面有.nodeType$(function () {})$($())
jQuery .extend()  拓展工具方法$().extend()   拓展实例方法
extend：拓展合并（传两个参数 ，合并到第一个对象里面去）
原始值的话并不会变化，而改个引用值就ok。
extends的四种写法：
1234$.extend(obj1)$.extend(obj1, obj2)$.extend(true ,obj1)$.extend(true ,obj1,obj2)


其实就是要关注target是什么，i是什么（从第几位开始传)，如果前面有true就往后挪一位.


</section>
    <p class="sub">May 12, 2019</p>
  </div>
</div>
  
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/blog/2019/05/11/javascript-note/" class="title">javascript学习笔记</a>
    <section class="desc">
  JavaScript笔记
Web 发展史：
Mosaic：是全世界第一款可以显示图片的浏览器
Netscape Navigator -&gt;2003 firefox 浏览器
IE6 -&gt;IE6浏览器
2008 -&gt; Chrome 浏览器 


关于浏览器的内核部分：


渲染引擎（语法规则和渲染）
js引擎
其他模块


JavaScript的语言特点：

解释性语言 –（不需要编译成文件）跨平台
单线程
ECMA标注 ECMAscript


JavaScript执行队列：  执行片段A1-&gt;执行片段A2-&gt;执行片段A3 （争抢时间片）



主流浏览器及其内核：


主流浏览器
内核



IE
trident


Chrome
wekit/blink


firefox
grcko


Opera
presto


Safari
webkit





引入javascript的两种方式  121.&lt;script&gt;&lt;&#x2F;script&gt;2.&lt;script src&#x3D;&#39;.js&#39;&gt;&lt;&#x2F;script&gt;




js变量名的命名规则


变量名必须以英语字母 ,_ ,$开头。
变量名里面可以包括英文字母，_还有$.
不可以用系统的关键字还有保留字作为变量名。

JavaScript基本语法：数据类型分为原始值还有引用值

==原始值有：number , boolean , String ,undefinded ,null==
==引用值有：array ,object ,funciton ,date ,regexp==


几个注意点：


==javascript对象才能拥有方法，然而number，String，boolean也可以拥有自己的方法，null和underfind是无法拥有方法的值。==
对象和数组属于可变类型，javascript程序可以更改对象属性值和数组元素的值。
数字，布尔值、null，和undefined属于不可变类型。
==原始值和引用值的区别在于，原始值存在于stack(栈)当中，规则是先进去的最后出来。而引用值是存在heap（堆）里面的 ，引用值拷贝的是地址。==

String的方法：在javascript权威指南中，笔者列举出了许多字符串可调用的方法。
运算符：12+ - * &#x2F; 不过特别要注意的是，任何“+”碰到字符串，都会变成字符串连接符。


比较运算符：字符串的比较是ASCII码数值的比较。
1Infinity &#x3D;&#x3D; Infinity	undefind &#x3D;&#x3D; undenfind


特别注意的是 NaN!= NaN无穷大除以无穷大，给人以负数作开方运算或者算术云算法不是数字或无法转换为数字的操作数一起使用时都将返回NaN


逻辑运算符：
1&amp;&amp; 	|| 	!


与运算符-&gt;&amp;&amp;，在运算中，undefind ,null ,Nan ,” “ ,0 ,flase ,会转换成false

1例： var a &#x3D;1 &amp;&amp; 2;   先看表达式前面1，直接转换成true，然后知己输出第二个表达式，若第一个表达式为false，则直接输出为0；
或运算符1-&gt;||
在运算中，寻找一个真值，第一个为真则直接返回第一个值。若第一个为假，而又只有两个值，则返回第二个值，无论真假。12345左移（&lt;&lt;）将一个值左移相当于它乘以2，7&lt;&lt;2 &#x3D; 28右移（&gt;&gt;）将一个值右移相当于它除以2， 7&gt;&gt;1&#x3D;3 ，-7&gt;&gt;1&#x3D;-4


条件语句：123if(条件)&#123;        &#125;

12345672. switch(1)&#123;            case(1):      console.log(&#39;a&#39;);break;       &#x2F;&#x2F;switch这种选择语句，遇到合适条件的case才会执行，而却会把全部的case看一遍，如果在只有一种  &#x2F;&#x2F;条件下的case，则可以用break；停止运行。减少资源浪费。&#125;

对象1234对象：var obj &#x3D;&#123;属性名 ：&quot;属性值&quot;&#125;



typeof可以判别的值有：number，String，boolean ，object，undefined，function；这6种。而typeof 在辨别null 和 Array的时候一律返回object 。

类型转换：显示类型转换：
var num = Number(‘123’)；注意：undefined -&gt;Number (Nan)

parseInt(‘10’ ,16)可以把任何东西转换成整形，而且可以进行10进制，16进制的转换。

parsefloat把数据转换成浮点类型。“123abc”可以识别数字并返回。

boolean：会把underfined ,null ,0 ,-0 ,NaN ,”” 转换成false。

toString:    将返回一个表示调用这个方法的对象值的字符串。


隐式类型转换：12341.isNan()2.+ -&gt;String类型3. - *  &#x2F; % -&gt;number类型4. ！&#x3D;

隐式类型转换：
减号,乘号,除号,取模等操作会尝试将他们所操作转换为数字Number，如果没办法转换成数字，结果就是Nan
大于，小于，大于等于，小于等于，跟上面一样。

1&#x3D;&#x3D; ！&#x3D;

字符串 op 字符串，不会进行类型转换，直接比较；
对象op对象，引用都指向同一个对象才为true  

12Boolean(Nan) &#x3D;&#x3D; false;null &#x3D;&#x3D; undefinded  &#x2F;&#x2F;  true

不发生类型转换：1234567&#x3D;&#x3D;&#x3D;			&#x2F;&#x2F;绝对相等如果两个值为数字且数值相等，则它们相等。如果一个数值为0，另一个数值为-0，则它们同样相等。！&#x3D;&#x3D;		&#x2F;&#x2F;绝对不相等！&#x3D;&#x3D;也可以用来判断一个属性书否是underfindvar o &#x3D; &#123;x : 1&#125;o.x !&#x3D;&#x3D; underfind &#x2F;&#x2F;true o中有属性xo.y !&#x3D;&#x3D; underfind &#x2F;&#x2F;false o中没有属性y
==typeof(typeof(number)) —&gt;最后其实类型是String ,因为第一个typeof是返回的是String类型。==
函数：
函数表达分为命名表达式还有匿名函数表达式。
命名表达式：function text(){ } text(); -&gt;调用
匿名表达式： var text :function() {} 

形参与实参：
形参text(a,b)  ==text.length== 可以知道形参的数量。
实参text(1,2)。==arguments.length== 可以知道实参的长度。


形参出生是多少个就是多少个，以后不会再往后加了。

return:使程序停止执行；返回值
递归：

符合人的逻辑思维过程
递归一定要有递归出口

javascript预编译：要点：
函数声明整体提升
变量声明提升

操作：
imply global 暗示全局变量：即任何变量，如果变量未经声明就直接赋值，该变量为全局对象变量。
一切声明的全局变量，都是window的属性。即可以通过window调用。

预编译的四部曲（局部）：(重要)
创建AO（执行期上下文）

找形参和变量声明。将变量和形参作为AO属性名，值为underfined。

将实参值和形参值统一。

在函数体里面找函数声明，值赋予函数体，-&gt;
1function()&#123;&#125;
这种–优先级最高，function会覆盖之前变量的值。


==注意：fcuntion a() {}这种叫函数表达式才算funciton, 在预编译里==
1var b &#x3D;function ()&#123;&#125;
 ==这种，因为还没有执行，所以不算function(){}==
全局的预编译
创建GO

——————-（其余步骤相等）
==在预编译的规则中，先生成GO ，再生成AO。==
作用域[[scope]]:每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些不行，这些对象仅供js引擎存取，[[scope]]就是其中一个。==其存储了运行上下文的集合==。
作用域链：[[scope]]中所存储的执行器上下文对象的集合，集合呈链式连接。
==查找变量：从作用域的顶端依次向下查找，而AO在GO的顶端。==
闭包：但凡是内部函数被保存到了外部，就一定会生成闭包。
缺点：当内部函数被保存到外部时，将会生成闭包。闭包会导致原有的作用域链不释放，造成内存泄露（像内存泄露，只是说内存被占用）
闭包的作用：

实现公有变量。例如说做一个函数累加器。
可以做缓存（存储结构）
可以实现封装，属性私有化
模块化开发，放置污染全局变量

立即执行函数：（也有执行器上下文，也需要预编译）
1(function() &#123;&#125; ()) 执行之后就立即被销毁。

123传递参数：(function(a,b,c))&#123;console.log(a+b+c);&#125;(1,2,3)


注意：只有表达式才能被执行符号执行（执行符号就是（）），利用立即执行函数把内部数据传到外部，也用于数据的初始化；‘  ， ’逗号可以把后面的值返回;

对象：所有的对象继承了两个转换方法，第一个是toString()，它的作用是返回一个反应这个对象的字符串。

toSting
数组类继承的toString()可以将每一个数组元素转换成一个字符串，并在元素之间添加都好并合并成结果字符串
函数类的toString()可以返回这个函数的实现定义的标识方式。
日期类的toString可以返回一个可读的日期和时间字符串。
RegExp类定义的toString()方法将RegExp对象转换成表达正则表达式直接量的字符串



另外一个方法是ValueOf()。如果存在任意原始值，它就默认将对象转换为表示它的原始值。
thisthis ：代表在某一对象里面的第一人称，例如this.health在对象内部的增删改查。
1this.wife&#x3D;&#39;FengZe&#39; ，即在这里直接进行添加和修改。


1删除：delete xx.name;



对象创建方法;
var obj = {}  对象字面量/对象直接量。

通过构造函数创建：

系统自带构造函数  var obj = new object();构造函数要用大驼峰式方法来写：TheFirstName构造函数的内部原理：（一定要有new，不然就不是构造函数了）
在函数体最前面隐式加上this ={}
执行this.xxx=xxx;
隐式返回this



包装类：new String()；
new Boolean();
new Number()；
对象创建方法：
对象字面量
12345678var obj &#x3D;&#123;			&#x2F;&#x2F;对象字面量、对象直接量name : &quot;FengZe&quot;,sex  : &quot;male&quot;,wfie : &quot;xingyu&quot;,smoke : function () &#123;console.log(&#39;i am smoking ！&quot;);&#125;&#125;

构造函数：

系统自带的构造函数 object   –&gt;  var obj = new object();




==注意：构造函数要用大驼峰式的方法来写： TheFirstName这种==


自定义 

123function xx()&#123;&#125;

构造函数的内部原理（一定要用new ,不然就不是构造函数了）

在函数体最前面隐式加入this = {}
执行this.xxx=xxx;
隐式地返回this;

包装类：new String（）；new Boolean ();new Number ();
原型：
定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的睡醒和方法。原型也是对象。

利用原理，可以提取共有属性。

独享通过隐式属性查看原型–&gt;   
1__proto__

通过constructor 查看对象的构造函数。


例子：如果生产一种汽车，而这种汽车大部分是相同的，而小部分作为选配部分，可以这样写：     
1234567891011121314151617function Car (owner,power)&#123;				this.owner &#x3D; owner,				this.power &#x3D; power			&#125;			Car.prototype &#x3D; &#123;				name :&#39;BMW&#39;,				tite :18,				run : function ()&#123;					console.log(&quot;i am running &quot;);				&#125;			&#125;			var car1 &#x3D; new Car(&#39;feng&#39;,&#39;900&#39;);delete.Car.name ,这样就可以删除了Car.prototype里面的属性了。




原型链：12Crand.protype.__prtot__ &#x3D; object.prototype --&gt;是所有对象的最终原型。var obj &#x3D; object.create(&quot;原型&quot;)



12例： var person &#x3D; Object.create(Person.prototype) 是绝大多数对象最终都会集成object.prototpype, 大也有例外的，例如说object.create(null)


call/applycall /apply 作用是转移this指向
12Person.call(obj)；&#x2F;&#x2F;call需要把实参按照形参个数传进去，而apply需要传输一个arguments  区别在于传参列表不同。


继承继承的发展史：
传统形式 -&gt;原型链   缺点：过多继承了没用的属性

借用构造函数 
 缺点：

不能继承借用构造函数的原型。
每次构造函数都要执行多个方法。


共享原型 缺点：

不能随便改动自己的原型，因为他们拥有同一个原型。


圣杯模式


1234function  F()&#123;F.prototype &#x3D; Father.prototype;son.prototype &#x3D; new F();&#125;

命名空间:管理变量，能防止污染全局，适用于模块化开发
属性拼接问题：123function (num)&#123;return this[&#39;name&#39; + num];&#125;	&#x2F;&#x2F;输入num 得出num1的效果


对象的枚举：（遍历和枚举）
12341. for()2. for(var temp in obj)&#123;&#125;

当遍历不知道对象的数量多少的时候，可以用for in循环解决问题

[hasOwnProperty]obj.hasOwnProperty(),    用来判断属性是不是自己的，是不是从原型链上拿过来的。

in   属性只能用来能不能访问到这个属性in运算符希望它的左操作数是一个字符串或可以转换成字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数的属性名则返回true.


1var point &#x3D; &#123;x:1 ,y:1&#125;  	&#39;x&#39; in point --&gt;true



A instanceof B可以查到 A对象是不是从B的构造函数，构造出来的。Object 可以看A对象的原型链上有没有B 的原型。instanceof 运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧对象是右侧对象的实例则返回true

123var d  &#x3D; new Data();d instanceof Data; &#x2F;&#x2F;true,d是由Data() 创建的 d instanceof Number; &#x2F;&#x2F; false ,d不是由Number创建的。



12[] instanceof Array -&gt;true    Object -&gt;true

toString方法：    toString() 方法可把一个逻辑值转换为字符串，并返回结果。
12object.prototype.toString.call([]);object.prototype.toString &#x3D; function ()&#123;&#125;




克隆：浅层克隆，深层克隆。{% asset_img 深克隆.png 深克隆 %}

function clone ()

对象序列化指的是对象的状态转换为字符串，也可以将字符串还原为对象。ECMAScript5提供了JSON.stringify()和 json.parse()用来序列化和还原js对象。但注意函数，RegExp,Error和underfind不能序列化和还原。

123o &#x3D; &#123;x : 1 , y:&#123;z : [false , null ,&#39;&#39;]&#125;  &#125;;s &#x3D; JSON.stringify() &#x2F;&#x2F; s &#x3D; &#123;x : 1 , y:&#123;z : [false , null ,&#39;&#39;]&#125;  &#125;p &#x3D; JSON.parse() &#x2F;&#x2F;p是o的深拷贝


三目运算符：1？：
例：1&gt;0? 2:1  如果1大于0 则选择2，否则选择1。数组：
数组的第一个元素索引为0，最大可能索引为2 32(2的32次方) -2。 
JavaScript数组是动态的，根据需要变长变短。数组都有一个length属性。 

12var arr &#x3D; []; 	数组字面量；var arr &#x3D; new Array();
可以传参数，但如果只写一个数会认为这是数组的长度。

数组继承了默认的Value0f()方法，这个返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString方法。空数组转换成为空字符串，空字符串转换成数字0。

常用的方法：
改变原数组： push ,pop， shift ，unshift， sort， reverse 

不改变原数组：concat ,join, split toString ,slice



push()–在数组的==最后一位添加数据==
pop ()–把数组的最后一位剪切出来
unshift()–在数组前面添加数据，并可以通过传参添加多个数据，
shift()    在数组前面减
reverse() 数组颠倒
splice()  arr.splice (从第几位开始 ， 截取多少的长度  ，在切口处添加的新数据)
sort()给数组排序，但这个是用ASII码排序的，因为有时候会不尽人意。也可以自行添加函数。

如何优化sort()方法进行排序
123456arr.sort(function ( a , b )&#123;				&#x2F;&#x2F;必须传2个形参return a-b;	&#x2F;&#x2F;升序		&#x2F;&#x2F;看返回数，当返回值为负数时，那么前面的数在前面return b-a;	&#x2F;&#x2F;降序&#125;)
如何给数组乱序:
123arr.sort(function ()&#123;Math.random() -0.5;	&#125;)


不改变原数组：


concat :拼接数组，并且不应县前面的数组，也不会排序
toString :把数组变成字符串
slice() 从该位开始截取，截取到该位
join()  要字符串，然后用字符串连接
split ()  用“”来拆分字符串变成数组。

类数组：类数组不是数组，当然没有数组的方法。构成要素：属性为索引，必须要有length 属性，最好有push方法
优点：类数组的关键点在于length 还有push方法obj [obj.lenght] = targetobj.length++;
如此来实现push方法。
try…catch不影响try catch 下一块代执行，但不会执行try块里面的那行代码
几种常见错误类型：
1234567Error：6EvalErrorRangeError ；数值越界ReferenceError ：非法或不识别的引用SyntaxError :语法错误TypeError :操作的类型错误urIError:uri不当


es5严格模式（即es3.0与es5.0冲突的部分使用es5.0的解决办法）
浏览器基于es3.0+es5.0的新增方法“use strict”;

在es5严格模式中，不允许使用argument.callee ，with{}  caller 并且变量赋值前必须声明，局部里面的this一定要被赋值，拒绝重复的属性。

在严格模式下有以下几种要求：
禁止使用with 语句
创设eval 作用域
禁止this关键字指向全局对象
禁止在函数内部遍历调用栈
禁止删除变量，只有configurable 
设置为true的对象属性才能被删除。

重名报错
arguments对象的限制不允许对arguments赋值
arguments不再追踪参数的变化禁止使用arguments.callee

DOM （Document Obect Model）
DOM定义了表示和修改文档的方法，DOM对象即为宿主对象。由浏览器厂商定义，用来操作html 和xml 。
DOM树中总共分成以下4种节点：Element(元素),Text类型(文本节点),Comment类型(注释节点),Document类型（document节点）1var div &#x3D; document.getElementsByTagName(&#39;div&#39;)[0];  &#x2F;&#x2F;后面这个0一定要选中。



数组去重方法：1234567891011Array.prototype.unique &#x3D; function() &#123;			var temp &#x3D; &#123;&#125;;			var arr &#x3D; [];			var len &#x3D; this.length;			for (var i &#x3D; 0; i &lt; this.length ; i++)&#123;				if(!temp[this[i]])&#123;					temp[this[i]] &#x3D; &#39;abc&#39;;					arr.push(this[i]);				&#125;			&#125;		&#125;


DOM的基本操作：
对节点的增删改查：
查：
查看元素节点 ：



DOM选择器：
1doucument.getElementById() &#x2F;&#x2F;元素ID在IE8 一下浏览器是不区分大小写的，而且也返回匹配name 属性的元素；就是说写name可以当成id选择器（ie 8浏览器以下可以）

getElementsByTagName()      //标签名

getElemehtsByName()  //只有部分标签name可生效（表单，表 ，img ,iframe）

getElementsByClassName() 在IE8 及以下的版本中不使用方法。

.querySelect()    //css选择器，在ie7级一下的版本中没有

.querySelectorAll()  //css选择器，在ie7 及以下的版本中没有 选一组


==document 代表整个文档，html只是文档里面的跟标签。==
遍历节点树：
parentNode -&gt;父节点 （最顶端的parentNode 是#document;）
childNodes -&gt;子节点
firstChild –&gt;第一个子节点
lstChild  –&gt;s最后一个子节点
nextSibling -&gt;后一个兄弟节点previousSiling  -&gt;前一个兄弟节点

遍历元素节点数：
parentElement -&gt;返回当前元素的父元素节点（IE不兼容）
children -&gt;只返回当前元素的元素子节点

1node.childElementCount &#x3D;&#x3D;&#x3D; node.children.length
 当前元素节点的子元素节点数目4. firstElementChild  5. 第一个元素子节点（IE不兼容）5. lastElementChild 返回最后一个元素子节点（IE 不兼容）6. nextElementSibling /previousElementSibling -&gt;返回后一个/前一个兄弟节点
节点类型：元素节点
属性节点
文本节点
注释节点
doucument
DocumentFragment节点的四个属性：

nodeName   //只能读取，不能写入。
nodeValue     //text节点或comment节点的文本内容，可读写。
nodeType     //该节点的类型 只读   判断元素是啥。
attributes        // element 节点的属性集合

节点的一个方法:node.hasChildNodes();
DOM结构树：Document是系统的函数，只能系统自己调用。
==getElementByTagName () 方法定义在Document.prototype 和Element.prototypes上==
增：
1234var div &#x3D; document.getElementsTagNmae(‘div’) ； document.createTextNode();document.createComment();document.createDocumentFragment();


插：
12PARENTNODE.appendChild();PARENTNODE.insertBefore(a,b)  &#x2F;&#x2F;  插入A在插入B之前


删：
12parent.removeChild();child.remove();


替换：
1parent.replaceChild(new,origin)



Element节点的一些属性：12345innerHTML innerText   (火狐不兼容) &#x2F;textContent （老版本IE不好使）Element节点ele.setAttribute(&#39;id&#39; ,&#39;only&#39;)  ele.getAttribute(&#39;id&#39;)


Date 对象方法：
getTimer:

Interval：定时器：但定时器是非常不准的。

setInterval: 定时器

clearInterval:清理计时器



123456789setTimeout(function()&#123;&#x2F;&#x2F;用于推迟一段时间之后再执行&#125;，1000)var timer &#x3D; setTimeout(function ()&#123;&#125;)clearTimeout(timer);


DOM基本操作：查看滚动条的滚动距离：
1window.pageXOffsize YOffsize

==IE8及IE8以下不兼容==
查看视口的尺寸:
1window.innerWidth &#x2F;inner.Height



标准模式 /怪异模式也叫混杂模式（向后兼容），可在浏览器查document.compatMode,如果是CSS1Compat则是标准模式，如果是BackCompat则是向后兼容。clintHeight / clientHeight 

查看元素的几何尺寸：1domEle.getBoundingClientRect();

兼容性很好该方法返回不是实时的；
查看元素尺寸：
1dom.offsetWidth  dom.offsetHeight
 //求的是视觉上的尺寸，当然不包含margin
查看元素的位置：
1dom.offsetLeft  dom.offsetTop



1dom.offsetParent
 //查看父级的。能求有定位的父级。
让滚动条滚动：window上的三个方法：
123scroll()  scrollTo() 其实是一样的 scroolBy()  累加滚动距离

阅读器小demo ，就是reader.js
脚本化CSS  （就是控制CSS）
可读写行间样式，没有兼容性问题，遇到float这样的保留字属性，前面应加css
复合属性必须拆解（borderWidth,borderHeight,borderradius），组合单词变成小驼峰式写法；写入的值必须是字符串格式

查询计算样式：1window.getComputedStyle(ele，null);
 //看到权重最高的，所以这个最准确。这个也不能改样式。计算样式只读
返回的计算样式的值都是绝对值，没有相对单位ie8 及以下不兼容。
查询样式：div.currentStyle–&gt; CSSStyleeclaration
事件：事件的绑定：12ele.onXXX&#x3D; function(event )&#123;&#125;  		&#x2F;&#x2F;程序this指向是dom元素本身特点：兼容性很好，但是一个元素的同一事件上只能绑定一个处理程序，基本等同于写在HTML行间上



12345obj.addEventListeber(type, fn,flase);	&#x2F;&#x2F;程序this指向是dom元素本身ie9 以下不兼容，可以为一个时间绑定多个处理程序obj.attachEvent(&#39;on&#39;+type ,fn)			&#x2F;&#x2F;程序this指向windowIE独有，一个时间同样可以绑定多个处理程序

绑定事件，当事件在循环里面，就一定要考虑要不要使用闭包。
事件处理程序解除事件：
1234ele.onclick &#x3D; false &#x2F;nullele.removeEventListener(type,fn ,false)ele.detachEvent(&#39;on&#39; +type ,fn);若绑定匿名函数，则无法解除


事件处理模型——事件冒泡，捕获结构上嵌套关系的元素，会存在事件冒泡的功能。
事件捕获： 只有chrome上可以用
把flase 变成ture,从结构的最外面向里面进行捕获.

一个对象的一个事件，绑定两个函数，分别是冒泡还有捕获。执行的顺序是先触发顺序，先捕获，后冒泡。

==focus, blur , change  submit  reset  ,select 等事件不冒泡==
取消冒泡：W3C标准event.stopPropagation
阻止默认事件：
默认事件——表单提交，a标签跳转，右键菜单等return false;     以对象属性的方式注册的时间才有效

1event.preventDefault（） IE9以下不兼容



事件对象：event ||window.event 用于IE
事件源对象：
event.target 火狐只有这个
event.srcElement ie只有这个
chorm 全都有
div.box就是事件源对象

事件分类：键盘类事件：

Json就是为了传输数据：
以xml这种语言传输数据，xml相对于html比较随性，可以自定义标签。
规定json 属性名要加双引号，json传输的时候其实传输的是字符串。



12JSON.stringify() ---&gt;把数据传输给后台   json -&gt;stringJSON.parse（) ----&gt;后台把数据传输给前台，string -json


1domtree + csstree &#x3D; randerTree

==尽量减少dom节点的增加或者删除，以优化性能reflow 是效率最低的。dom节点的宽高变化==，
12例如说display none---&gt;block offsetWidth offsetLeft


repanint 重绘效率相对没有这么低，是可以接受的
异步加载js：加载工具方法没必要阻塞文档。
三种方法异步加载js：

defer = “defer”  这个就是异步加载的js了。只有IE能够用。要等到dom文档全部解析完之后才会被执行
async  异步加载。 async = “async” 也可以实现异步加载。W3C方法。加载完就执行。asynv只能加载外部脚本
创建script，插入DOM，可以按顺序执行。


使用onload方法，可以让所有资源加载完之后立即执行,除了IE都兼容。

123456IE 使用onreadystatechange（） 方法$(document).ready(function () &#123;&#125;)					&#x2F;&#x2F;这种是当DOM解析完就执行的部分与window.onload 方法之间的区别。 onload是最低的写法


JS时间线BOM定义borwser Object Model
定义了操作浏览器的接口
BOM对象：Window ,History ,Navigator Screen,Location
由于浏览器不同，Bom对象的兼容性很低，一般情况只用部分功能。
123转义字符：“\”多行字符串字符串换行符 \n

正则表达式：匹配特殊字符或特殊搭配原则的字符的最佳选择———例如验证邮箱地址
两种创建方式：
11. 直接量  var reg &#x3D; new RegExp();


两种方法：

text() 只能判断有没有符号要求的片段，只能返回true和 false
match()可以判断符合的片段，并返回给你

修饰符：123456i  执行对大小写不敏感的匹配g 执行全局匹配m 执行多行匹配一个表达式就代表一位 ，里面填的就是区间




元字符：123\w &#x3D;&#x3D;&#x3D;[0-9A-z_]\W &#x3D;&#x3D;&#x3D;[^w]
量词：1234567891011121314n只是代表这个数，并不是特定的nn+ 这个变量可以出现一次到无数次n* 区间是零到正无穷n? 匹配任何包含零个或一个n的字符串n&#123;x&#125;n &#123;x,y&#125; &#123;3,5&#125;  先匹配5个，再不行匹配三个n$ 结尾  ，是要以这一整个片段结尾^n  开头

RegExp对象属性：1234globalignoreCase   &#x2F;&#x2F;忽略大小写multiline 		&#x2F;&#x2F;多行lastIndex

方法；exec()：index 索引
123456789101112131415&#x2F;()&#x2F;		&#x2F;&#x2F;（）代表字表达式  \1代表反向引用第一个表达式的内容var reg &#x3D; &#x2F;(\w)\1\1\1&#x2F;   可以匹配aaaaaabbbbb这种var reg &#x3D; &#x2F;(\w)\1(\w)\2&#x2F;g 可以匹配aabb这种表达式search()match() 匹配不到显示-1split 可以填字符串，还有正则表达式replace(‘a&#39;, &#39;b&#39;); 	&#x2F;&#x2F;替换字符，非正则表达式：把前面的替换成后面的 ，因为没有权限所以只能替换一个。正则表达式：具有访问全局的能力，把两个都能替换。rag &#x3D;&#x2F;a&#x2F;g



123var reg &#x3D; &#x2F;(\w)\1(\w)\2&#x2F;g;			var str &#x3D; &quot;aabb&quot;;		console.log(str.replace(reg,&#39;$2$2$1$1&#39;)); 	&#x2F;&#x2F;这种可以把字符把aabb转换成bbaa



1toUpperCase() 可以使字母大写




正向预查，正向断言

1&#x2F;a(? &#x3D;b)&#x2F;g 后面就是一个b



12abs() 可以去得正数和负数的绝对值floor（） 可以进行四舍五入




</section>
    <p class="sub">May 11, 2019</p>
  </div>
</div>
  
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/blog/2019/05/08/brower-note/" class="title">浏览器渲染原理</a>
    <section class="desc">
  浏览器渲染原理 -步骤：

清楚HTML 生成DOM树
处理CSS生成 CSSDOM树
将两树合并成render 树
将render 树进行布局计算
将render树中的每一个节点绘制到屏幕上


重排，重绘


当render tree 中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变需要重新构建，会回流。每个页面至少需要一次回流，就是在页面的第一次加载的时候。
重绘。当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格而不影响布局的，例如background-color，就叫做重绘。




蓝色代表网络通信和HTML 解析


黄色代表javascipt执行


紫色代表样式计算和布局，即重排


绿色代表重绘



</section>
    <p class="sub">May 8, 2019</p>
  </div>
</div>
  


  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/categories/front-end/page/2/">2</a><a class="extend next" rel="next" href="/blog/categories/front-end/page/2/">&lt;span class&#x3D;&quot;iconfont icon-arrow-right&quot;&gt;&lt;&#x2F;span&gt;</a>
  </nav>


  </div>
  <div class="main-bottom">
    <div class="music flex flex-pack-justify flex-align-center">
      <div class="control">
        <a onclick="preSong()"><span class="iconfont icon-shangyishou"></span></a>
        <a onclick="playControl()"><span class="iconfont play-icon icon-kaishi1"></span></a>
        <a onclick="nextSong()"><span class="iconfont icon-xiayishou-copy"></span></a>
      </div>
      <div class="msg">
        <span class="time"></span>
        <div class="line" ref="progress-line-warp">
          <div class="song-msg">周杰伦 - 说好不哭</div>
          <!--<div class="current-line" ref="progress-line">
            <a tag="a" class="target" v-on:mousedown.prevent="mousedown"></a>
          </div>-->
        </div>
        <span class="all-time"></span>
      </div>
      <div class="right-control">
        <a class="order-btn flex flex-align-center" onclick="toogleShowMusicList()">
          <span class="iconfont icon-ttpodicon"></span>
          <span class="number flex1">3</span>
        </a>
      </div>
      <audio id="audio" class="mian-audio" src="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3">
        Your browser does not support the audio element.
      </audio>
    </div>
  </div>
  <div class="music-list">
    <div id="musiclist">
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 说好不哭" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3" onclick="changePlayIndex(0)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">说好不哭 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 爱在西元前" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%88%B1%E5%9C%A8%E8%A5%BF%E5%85%83%E5%89%8D%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(1)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">爱在西元前 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 龙拳" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%BE%99%E6%8B%B3%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(2)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">龙拳 - 周杰伦</span>
        </a>
      
    </div>
  </div>
</div>

<script>
  var playIndex = localStorage.getItem('playIndex') ? parseInt(localStorage.getItem('playIndex')) : 0
  let musics = $('.music-item')
  musics.eq(playIndex).addClass('active')
  var audio = document.getElementById("audio");

  $('.song-msg').html(musics[playIndex].dataset.name)
  audio.src = musics[playIndex].dataset.url


  var playbtn = document.getElementsByClassName("play-icon")[0];
  var playing = false;
  audio.loop = false;
  audio.addEventListener('ended', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  audio.addEventListener('play', function () {
    playbtn.classList.remove("icon-kaishi1")
    playbtn.classList.add("icon-kaishi")
    playing= true
  }, false);
  audio.addEventListener('pause', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  function toogleShowMusicList() {
    var musiclist = document.getElementsByClassName("music-list")[0];
    if(musiclist.className.indexOf("active") === -1){
      musiclist.classList.add("active")
    }else{
      musiclist.classList.remove("active");
    }
  }

  function playControl() {
    if(playing){
      audio.pause()
    }else{
      audio.play()
    }
  }

  function changePlayIndex(index) {
    if(playIndex !== index){
      localStorage.setItem('playIndex',index)
      playIndex = index
      musics.removeClass('active')
      musics.eq(playIndex).addClass('active')
      $('.song-msg').html(musics[playIndex].dataset.name)
      audio.src = musics[playIndex].dataset.url
      audio.play()
    }else{
      playControl()
    }
  }

  function preSong() {
    var index
    if(playIndex === 0){
      index = musics.length - 1
    }else{
      index = playIndex - 1
    }
    changePlayIndex(index)
  }

  function nextSong() {
    var index
    if(playIndex === musics.length - 1){
      index = 0
    }else{
      index = playIndex + 1
    }
    changePlayIndex(index)
  }

  function toggleMenu() {
    var mainLeft = $('.main-left')
    if(mainLeft.hasClass('active')){
      mainLeft.removeClass('active')
      $('.menu').removeClass('icon-close')
      $('.menu').addClass('icon-menu')
    }else{
      mainLeft.addClass('active')
      $('.menu').removeClass('icon-menu')
      $('.menu').addClass('icon-close')
    }
  }
</script>
