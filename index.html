<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>欢迎来到何泽丰的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
  <meta name="description" content="怕，你就输一辈子">
<meta property="og:type" content="website">
<meta property="og:title" content="欢迎来到何泽丰的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="欢迎来到何泽丰的博客">
<meta property="og:description" content="怕，你就输一辈子">
<meta property="article:author" content="何泽丰">
<meta name="twitter:card" content="summary">
  
    <link rel="icon" href="/images/icon.png">
  
  
<link rel="stylesheet" href="/blog/css/index.css">



  <!-- 百度站長統計-->
  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?34f341cfdc5f80d1bbb5dab01822e053";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/blog/atom.xml" title="欢迎来到何泽丰的博客" type="application/atom+xml">
</head>

<div class="main height-100 flex flex-v">
  <div class="phone-header">
    <a to="/home" class="mobile-logo" > <img src="/images/logo.svg" /> </a>
    <a class="menu iconfont icon-menu" onclick="toggleMenu()"></a>
  </div>
  <div class="main-top flex flex1">
    <nuxt-link  to="/home" class="mobile-nav-btn iconfont icon-fenlei"></nuxt-link>
    <!--主页上左部分-->
    <div class="height-100 main-left  flex flex-v">
      <div class="main-left-top flex1">
        <a class="logo">
          <img src="/images/logo.svg" />
          <div class="sub-title">自强不息 厚德载物</div>
        </a>
        <nav class="nav">

  
    
      <a title="首页"  alt="首页"  v-for="(menu,index) in menus" href="/blog">
        <div class="icon"><i class="iconfont icon-home"></i></div>
        <div class="name">
          <div class="cnname">首页</div>
          <div class="enname">Home Page</div>
        </div>
      </a>

    
      <a title="归档"  alt="归档"  v-for="(menu,index) in menus" href="/blog/archives">
        <div class="icon"><i class="iconfont icon-archives"></i></div>
        <div class="name">
          <div class="cnname">归档</div>
          <div class="enname">Archive Page</div>
        </div>
      </a>

    
      <a title="关于我"  alt="关于我"  v-for="(menu,index) in menus" href="/blog/about">
        <div class="icon"><i class="iconfont icon-about"></i></div>
        <div class="name">
          <div class="cnname">关于我</div>
          <div class="enname">About Me</div>
        </div>
      </a>

    
  

  <!--<a href="/link/">
    <div class="icon"><i class="iconfont icon-link"></i></div>
    <div class="name">
      <div class="cnname">友情链接</div>
      <div class="enname">Friends Web Link</div>
    </div>
  </a>-->
</nav>

      </div>

      <view class="website-msg">
        <div class="beian"><a target="_blank" href="http://www.miitbeian.gov.cn/"></a></div>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <div class="beian"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div>
        <div class="theme-drsc">PowerBy:<a href="https://hexo.io" target="_blank">Hexo</a> ThemeBy:<a href="" target="_blank">Soul</a></div>
        <div class="copyright">Copyright &#169 <a href="mailto:316692151@qq.com">2020 He ZeFeng</a> </div>
      </view>

      <div class="social flex flex-align-center ">
        
          
            
              <a class="flex1 text-center" href="https://weibo.com/3759599790/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" target="_blank" title="weibo" alt="weibo">
                <div class="icon relative">
                  <i class="iconfont icon-weibo"></i>
                </div>
              </a>
            
          
            
              <a class="flex1 text-center" href="https://github.com/FengZeHe" target="_blank" title="GitHub" alt="GitHub">
                <div class="icon relative">
                  <i class="iconfont icon-github"></i>
                </div>
              </a>
            
          
            
              <a class="flex1 text-center" href="/blog/316692151" target="_blank" title="wechat" alt="wechat">
                <div class="icon relative">
                  <i class="iconfont icon-wechat"></i>
                </div>
              </a>
            
          
        
      </div>
    </div>
    <!--主页上右部分-->
    
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/blog/2020/02/27/es6-async/" class="title">ES6异步的解决方案</a>
    <section class="desc">
  背景js经常会遇到一些异步任务（需要经过一段时间或当某个时机到达后才能得到的任务）例如说：

使用ajax请求服务器，当服务器完成响应后拿到响应结果
监听按钮是否被点击，当按钮点击后拿到某个文本框的值
使用setTimeout 等待一段时间，当时间到达后做某些事情

面对这样的场景，JS没有一种标准的模式来进行处理，我们处理这些问题的方式是杂乱的，这就导致了不同的人书写的异步任务代码使用方式不一致。例如说实用第三方库，不知道要传进去多少个参数，或者各种参数放第几位。
ES6异步处理模型ES6将异步场景分为两个阶段和三种状态
两个场景： unsettled (未决)  settled (已决)
三种状态： pending (挂起) resolved(完成) rejected (失败)

当任务处于未决时状态一定是pending的，表示任务从开始至拿到结果之间的过程。例如说网络完成了各种配置，发送了请求但还没有收到回复当任务处于已决时它只能是resolved和reject两种状态之间的一种。例如说拿到或者没拿到数据--&gt; resolved状态 。网络不通畅 --&gt; rejected状态我们把从未决推向已决的resolved状态的过程，叫做resolve，从未决推向已决的rejected状态的过程，叫做reject如下图所示
任务已决后(有了结果)进一步做后续处理，如果任务成功了（resolved）,有后续处理，如果任务失败了（rejected）,仍可能做后续处理我们把针对resolved的后续处理称之为thenable，针对rejected的后续处理，称之为catchable
注意事项
任务一旦进入已决后，所有企图改变代码任务状态的代码都将失效
以下代码可以让任务达到rejected 状态
调用reject
代码执行报错
抛出错误


后续处理函数一定是异步函数，并且放在微队列中



</section>
    <p class="sub">Feb 27, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/blog/2020/02/23/ES6-modular/" class="title">ES6模块化</a>
    <section class="desc">
  ES6的模块化模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件模块化背景过去js很难编写大型应用，因为有以下两个问题：

全局变量污染
难以管理的依赖关系这些问题，都导致了JS无法进行精细的模块划分，因为精细的模块划分会导致更多的全局污染更加负载的依赖关系，因为功能精细的划分有利于代码重用

前端的模块化有两个标准：
Commonjs
ES6 Module注意：上面提到的两个均是模块化标准，具体的实现需要依托于JS的

ConmomJS简介：目前，只有node环境才支持CommonJs模块化标准，所以需要先安装node才能使用CommonJS在CommonJS中，浏览器运行的是html页面，并加载页面通过script元素引入js，node.js直接运行某个js文件，该文件被称之为入口文件。node.js遵循ECMAScript标准，但脱离了浏览器环境：你可以在node.js中使用ECMAScript标准的任何语法或api，例如循环，判断，数组，对象等等但不能在node.js中使用浏览器的web api,例如说dom对象，window对象，document对象
CommonJS标准和使用node中的所有代码均在CommonJS下运行，具体规范如下 ：

一个js文件既为一个模块如果一个模块需要暴露依稀额数据或功能给其他模块使用，需要使用代码module.exports = xxx ,该过程称之为模块的导出

如果一个模块需要使用另一个模块导出的内容，需要使用代码require(‘模块路径’)
12路径必须以.&#x2F;或..&#x2F;开头如果模块文件后缀名为  .js 可以省略后缀名
require 函数中返回的是模块导出的内容,且模块中所有的全局代码产生的变量、函数均不会对全局造成任何污染，仅在模块内使用

模块具有缓存，第一次导入模块时会缓存模块的导出，之后再导入同一个模块 会使用之前缓存的结果


有了CommomJS模块化，代码就会形成以下结构：
原理：node实际上是将模块文件中的代码防止到一个函数环境中执行，可以想象该函数是下面的样子：
12345function(module)&#123;    module.exports &#x3D; &#123;&#125;;    var exports &#x3D; module.exports;    return module.exports;&#125;



ES6 module
由于种种原因，CommonJS难以在浏览器中实现，因为一直在浏览器端没有合适的模块化标准，直到es6出现。ES6规范了浏览器的模块化标准，一经发布，各大浏览器厂商纷纷在自己的浏览器中实现该规范。

模块的引入：
12&#x2F;&#x2F;在浏览器使用以下方式引入ES6模块文件&lt;script src &#x3D; &quot;入口文件&quot; type &#x3D; &quot;module&quot;&gt;




标准和使用模块的导出分为两种，基本导出和默认导出
12345678可以将整个模块的导出想象成一个对象，基本导出导出的是该对象的某个属性，默认导出导出的是该对象的特殊属性default&#x2F;&#x2F;导出结果：想象成一个对象&#123;    a: xxx, &#x2F;&#x2F;基本导出    b: xxx, &#x2F;&#x2F;基本导出    default: xxx, &#x2F;&#x2F;默认导出    c: xxx &#x2F;&#x2F;基本导出&#125;


ES6的导出方式：1234567891011121314export var a &#x3D; 1 &#x2F;&#x2F;基本导出 a &#x3D; 1export var b &#x3D; function()&#123;&#125; &#x2F;&#x2F;基本导出 b &#x3D; function()&#123;&#125;export function method()&#123;&#125;  &#x2F;&#x2F;基本导出 method &#x3D; function()&#123;&#125;var c &#x3D; 3;export &#123;c&#125; &#x2F;&#x2F;基本导出 c &#x3D; 3export &#123; c as temp &#125; &#x2F;&#x2F;基本导出 temp &#x3D; 3export default 3 &#x2F;&#x2F;默认导出 default &#x3D; 3export default function()&#123;&#125; &#x2F;&#x2F;默认导出 default &#x3D; function()&#123;&#125;export &#123; c as default &#125; &#x2F;&#x2F;默认导出 default &#x3D; 3export &#123;a, b, c as default&#125; &#x2F;&#x2F;基本导出 a&#x3D;1, b&#x3D;function()&#123;&#125;, 默认导出 default &#x3D; 3绝大部分时间写代码使用的导出方式是 export default()&#123;&#125;
ES6模块的导入：使用以下的代码导入模块
12345678import &#123;a,b&#125; from &quot;模块路径&quot;   &#x2F;&#x2F;导入属性 a、b，放到变量a、b中import &#123;a as temp1, b as temp2&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性a、b，放到变量temp1、temp2 中import &#123;default as a&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default，放入变量a中，default是关键字，不能作为变量名，必须定义别名import &#123;default as a, b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default、b，放入变量a、b中import c from &quot;模块路径&quot;  &#x2F;&#x2F;相当于 import &#123;default as c&#125; from &quot;模块路径&quot;import c, &#123;a,b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;相当于 import &#123;default as c, a, b&#125; from &quot;模块路径&quot;import * as obj from &quot;模块路径&quot; &#x2F;&#x2F;将模块对象放入到变量obj中import &quot;模块路径&quot; &#x2F;&#x2F;不导入任何内容，仅执行一次模块
细节导入模块时，注意以下细节

ES6 module 采用依赖预加载模式，所有模块导入代码均会提升到代码顶部
不能将导入代码放置到判断、循环中
导入的内容放置到常量中，不可更改
ES6 module 使用了缓存，保证每个模块仅加载一次



</section>
    <p class="sub">Feb 23, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/blog/2020/02/15/when-Enter-an-address/" class="title">当在浏览器输入一个地址发生了什么</a>
    <section class="desc">
  是这样的：
浏览器将url地址补充完整，如果没有写协议就自动添加上协议（http： / https：）

浏览器对url地址进行url编码，如果url地址中出现了非ASCII字符，浏览器则会对其进行编码

例如说在浏览器中搜索”王思聪”，汉字会被编码成ASCII码


浏览器构造一个没有消息体的GET请求，发送至服务器，等待服务器响应（此时浏览器标签应该有一个等等的图标–转圈）

服务器收到请求，将一个HTML页面代码组装到消息体中（不一定要html文件）响应给浏览器

浏览器拿到服务器的响应后，丢弃当前的页面，开始渲染消息体的HTML代码。浏览器之所以知道这是一个HTML代码，是因为服务器的响应头指定了消息类型为text/html

浏览器在渲染页面的过程中发现有嵌入的资源如CSS,JS图片等

浏览器使用不阻塞的渲染方式，重定向服务器发送该资源的请求，拿到响应结果后根据Content-Type做响应处理

当所有资源已经下载并处理好后，浏览器出发window.onload事件


   这里说的Content-Tpye是在http协议消息头中表示具体请求中的媒体类型信息
   有一下几种类型：
   


</section>
    <p class="sub">Feb 15, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/blog/2020/02/12/vue-demo-1/" class="title">实现一个简单的VUE</a>
    <section class="desc">
  
实现的效果




     



目标​    实现一个简单的vue函数，包括双向数据绑定，数据的响应式
思路1. 首先想到要实现vue的数据绑定，根据vue的双向数据绑定，把{{xxx}} 与data{}里面的值进行绑定。将值绑定后，我们想到要将这些数据渲染出来，这里就需要知道页面的各个节点与各节点的子节点
 2. 再到数据响应模块，使用object.defineProperty来实现数据的响应式，用get方法来读取属性的值，用set方法来写入属性的值，以此来实现数据绑定
 3. 最后为Vue添加构造函数，例如说this.$el 来表示绑定的元素，$data来表示绑定的数据，$vnode代表虚拟节点模块划分
编译模块
虚拟节点模块
渲染模块
数据响应模块
VUE构造函数模块

编译模块
提供一个compile函数，将一个模板文本(数据)和环境对象（DOM节点）编译成一个结果思想：


使用正则表达式匹配到html代码中包含 括号 的字符串
拿到字符串之后把两边括号替换掉，把表达式分割成数组
这需要与envObj环境变量进行配合使用，绑定后变成一个数组



compile.js 代码

1234567891011121314151617181920212223242526//过程： 先拿到&#123;&#123;xxx&#125;&#125;里面的字符串，然后再对字符串进行加工function getFragments(template) &#123;    var matches = template.match(/&#123;&#123;[^&#125;]+&#125;&#125;/g); //万一有人的用户名叫12&#125;  所以这里要处理一下    return matches || [];&#125;function getValue(fragment, envObj) &#123;    var exp = fragment.replace("&#123;&#123;", "").replace("&#125;&#125;", "");    var props = exp.split(".");//将表达式分割为属性数组    var obj = envObj;    for (var i = 0; i &lt; props.length; i++) &#123;        obj = obj[props[i]];    &#125;    return obj;&#125;export default function compile(template, envObj) &#123;    // 提取模板中的&#123;&#123;&#125;&#125;    var flags = getFragments(template);    var result = template;    for (var i = 0; i &lt; flags.length; i++) &#123;        var flag = flags[i];        result = result.replace(flag, getValue(flag, envObj))    &#125;    return result;&#125;



虚拟DOM:
提供一个函数createVNode,根据提供真实的DOM，构建一个虚拟DOM树思想：


需要创建虚拟DOM 以便以后操作数据
需要判断真实节点是否为文本节点，如果是就要记录到虚拟节点

12345678910111213141516171819202122232425function VNode(realDom, template) &#123;    // node 构造函数    this.realDom = realDom;    this.template = template;    this.children = [];&#125;export default function createVNode(realDom) &#123;    var root = new VNode(realDom, "");    if (realDom.nodeType === Node.TEXT_NODE) &#123;        root.template = realDom.nodeValue;        // 判断真实节点是否为文本节点，如果是，就要记录到虚拟节点        // 文本节点代表的数字是3    &#125;    else &#123;        for(var i  = 0; i&lt; realDom.childNodes.length;i++)&#123;            var childNode = realDom.childNodes[i];            var vNode = createVNode(childNode)            root.children.push(vNode);        &#125;    &#125;    return root;&#125;




渲染模块
用于提取虚拟节点，将其模板编译结果设置到真实的dom中，对虚拟节点的子节点也做同样的操作

123456789101112131415import compile from "./compile.js";// 渲染一个虚拟节点（将文本的虚拟节点进行编译）export default function render(vnode, envObj) &#123;    if (vnode.realDom.nodeType === Node.TEXT_NODE) &#123;        vnode.realDom.nodeValue = compile(vnode.template, envObj);    &#125;    else &#123;        for (var i = 0; i &lt; vnode.children.length; i++) &#123;            var childNode = vnode.children[i];            render(childNode, envObj);        &#125;    &#125;&#125;



数据响应模块
主要负责将原始对象的数据附加到代理对象上，代理对象能够监听到数据的更改，当数据发生改变时，执行某个回调函数(就可以实现数据响应)


使用Object.defineProperty来实现数据的响应式

这里有一个关键是当代理一个对象是，发现对象里面还有属性没法代理。这时候就要重新申请一个新的代理（如下图）



123456789101112131415161718192021222324252627282930313233343536373839404142// 将原始对象的prop属性添加到代理对象中function proxyProp(originalObj, targetObj, prop, callback) &#123;    if (typeof originalObj[prop] === "object") &#123;        // 要代理的属性是一个对象,对象要单独处理        var newTarget = &#123;&#125;;//新的 要代理的对象        createResponsive(originalObj[prop], newTarget, callback);        Object.defineProperty(targetObj,prop,&#123;            get:function()&#123;                return newTarget;            &#125;,            set:function(value)&#123;                originalObj[prop] = value;                newTarget = value;                callback &amp;&amp; callback(prop);            &#125;        &#125;)    &#125;    else &#123;        Object.defineProperty(targetObj, prop, &#123;            get: function () &#123;                return originalObj[prop];            &#125;,            set: function (value) &#123;                originalObj[prop] = value;                callback &amp;&amp; callback(prop);            &#125;        &#125;)    &#125;&#125;// 将原始对象的属性，提取到代理对象中// org是原始对象， target是代理对象 当代理对象被赋值的时候要调用回调函数export default function createResponsive(originalObj, targetObj, callback) &#123;    for (var prop in originalObj) &#123;        proxyProp(originalObj, targetObj, prop, callback);    &#125;&#125;

为vue写一个构造函数12345678910111213141516171819import createVNode from './vnode.js'import createResponsive from './dataResponsive.js'import render from './render.js'export default function vue(option) &#123;    this.$el = option &amp;&amp; option.el;    this.$data = option &amp;&amp; option.data;    this.$vnode = createVNode(document.querySelector(this.$el))    var that = this;    createResponsive(this.$data, this, function () &#123;        // 重新渲染        that.render();    &#125;)    this.render()//初次渲染&#125;vue.prototype.render = function () &#123;    render(this.$vnode, this);&#125;





在前端页面写一个简单的VUE结构
在前端页面写一个简单的VUE结构，测试一下是否正确

1234567891011121314&lt;script&gt;    import Vue from "./vue/index.js"        window.vm = new Vue(&#123;            el: "#app",            data: &#123;                name:"FengZe",                age:16,                addr:&#123;                    province:"广东",                    city:"佛山"                &#125;            &#125;        &#125;)&lt;/script&gt;

大概就是这样实现的了.
源码地址：https://github.com/FengZeHe/vue_demo



</section>
    <p class="sub">Feb 12, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/blog/2020/02/12/vue-demo/" class="title">vue_demo</a>
    <section class="desc">
  

</section>
    <p class="sub">Feb 12, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/blog/2020/01/10/ofo_demo/" class="title">如何实现一个简单的ofo微信小程序</a>
    <section class="desc">
  
实现的效果




     






实现功能简介：

扫码骑车记时功能
用户登录及充值功能
用户报障功能

思路：

要实现这些功能，首先要设置一个首页，首页里面包含所有功能按钮，包括回到当前定位，立即用车，单车报障及个人用户按钮
回到当前定位功能直接调用this.movetoCenter()函数
立即用车功能;调用扫码接口获取开锁密码与当前单车编号，完事进入开锁界面并在90秒后跳转到计费页面并开始记录用户当前开始用车时间。
不过这里需要注意的是在计费中页面，用户仍然可以切换到首页地图，再次点击扫码用车的时候直接进入计费页面。
因为切回首页是把计费页面放在后台,所以使用navtgateTo()方法，而不是使用redirectTo()方法。


单车报障功能
这里要说一嘴的是故障类型跟上传照片是必填，要验证内容是否为空。这里我只是判断了input框中的长度是否大于0；
上传照片这里调用了微信的chooseImage()接口；我使用了一个数组存储上传的照片，所以在删除的时候直接在数组干掉就好了。


用户登录及充值功能
用户登录这里要注意下微信新版本是要授权，在按钮处设置open-type 为 getUserInfo才能使用。
另外我把用户数据存进了storage,这样处理下一次就可以自动登录了。同时在登出的时候也会删除storage.




关于后台：    因为时间（技术）问题暂时没有做出来，后续版本就有了嘿。因此这次我在modeHttp在线mock了后台数据。


源码地址：https://github.com/FengZeHe/ofo_demo



</section>
    <p class="sub">Jan 10, 2020</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/blog/2019/12/14/spring/" class="title">Spring学习笔记</a>
    <section class="desc">
  Spring学习笔记框架的概念：
高度抽取可重用代码的设计
高度的通用性

Spring的特点:优良特性：

非侵入式
依赖注入
面向切面编程
容器
组件化
一站式


Core Container（IOC）核心容器包含Bean Core Context expression 这几个容器

Web：Sping开发Web应用
WebSocket
Servlet
web protlet
(建议用哪个模块就导哪个包)



IOC：
控制反转;被动式的资源获取方式：资源的获取不是自己创建，而是交给容器创建和设置

DI：（Injevtion  依赖注入）
容器能知道哪个组件（类运行的时候时候需要另外一个类）
只要使用管理的组件，都能使用组件提供的强大功能。现在所有的对象交给容器创建，容器中的组件注册。

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;bean id &#x3D; &quot;person03&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;		&lt;constructor-arg name&#x3D;&quot;lastName&quot; value&#x3D;&quot;小明&quot;&gt;&lt;&#x2F;constructor-arg&gt;		&lt;constructor-arg name&#x3D;&quot;email&quot; value&#x3D;&quot;skjdhfkjsdfhkd@126.com&quot;&gt;&lt;&#x2F;constructor-arg&gt;		&lt;constructor-arg name&#x3D;&quot;gender&quot; value&#x3D;&quot;男&quot;&gt;&lt;&#x2F;constructor-arg&gt;		&lt;constructor-arg name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;constructor-arg&gt;	&lt;&#x2F;bean&gt; &#x2F;&#x2F;有参构造器 &lt;constructor-arg&gt;就代表一个属性  &lt;bean id&#x3D;&quot;person01&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;		&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;he&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;age&quot; value &#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;hzf@666.com&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;man&quot;&gt;&lt;&#x2F;property&gt;	  &lt;&#x2F;bean&gt;  &#x2F;&#x2F;通过无参构造器  &#x2F;&#x2F;如果省略name参数 就要严格按照构造器参数的位置  &#x2F;&#x2F;在重载的情况下 type可以指定参数的类型    &#x2F;&#x2F;名称空间：在xml中名称空间是用来防止标签重复的  &lt;book&gt;      &lt;b:name&gt;西游记&lt;&#x2F;name&gt;      &lt;author&gt;         &lt;a:name&gt;吴承恩&lt;&#x2F;name&gt;       &lt;&#x2F;author&gt;  &lt;&#x2F;book&gt;  通过标签的前缀，就可以知道name是指哪个name    xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;      &lt;property name&#x3D;&quot;lastName&quot;&gt;      &lt;&#x2F;null&gt; &#x2F;&#x2F;进行复杂的赋值，在property标签里面   &lt;&#x2F;property&gt;    &#x2F;&#x2F;如果把多个属性赋值给一个对象呢    &lt;bean  id &#x3D;&quot;car01&quot; class&#x3D;&quot;com.bean.Car&quot;&gt;		&lt;property name&#x3D;&quot;carName&quot; value&#x3D;&quot;宝马&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;color&quot; value&#x3D;&quot;pink&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;price&quot; value&#x3D;&quot;30000&quot;&gt;&lt;&#x2F;property&gt;		  &lt;&#x2F;bean&gt;    &lt;property name&#x3D;&quot;car&quot; ref&#x3D;&quot;car01&quot;&gt;&lt;&#x2F;property&gt;  &#x2F;&#x2F;在person01的容器中加入这段代码就ok      &#x2F;&#x2F;在bean里面写property写是引用外部bean， 在property里面写bean是引用内部bean

Spring在为各种属性赋值：
在bean使用ref写是引用外部bean， 在property里面写bean是引用内部bean
在对list属性进行赋值，写在property里面，同时也可以使用ref引用外部赋值
在对map属性进行赋值，在property键值对里面&lt;entry&gt;标签，在标签内使用key value进行键值对的赋值。
util名称空间创建集合类型的bean 方便别人引用123&lt;util:map id&#x3D;&quot;myMap&quot;&gt;&#x2F;&#x2F;一定要有Id    &#x2F;&#x2F;里面写的直接是元素&lt;&#x2F;util:map&gt;




级联属性赋值：就是属性的属性


通过继承实现bean配置信息的重用

123456789101112&lt;bean id&#x3D;&quot;parent05&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;		&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;男&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;akshdajsk&quot;&gt;&lt;&#x2F;property&gt;	&lt;&#x2F;bean&gt;		&lt;bean id&#x3D;&quot;person06&quot; class&#x3D;&quot;com.bean.Person&quot; parent&#x3D;&quot;parent05&quot;&gt;		&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;fengZe&quot;&gt;&lt;&#x2F;property&gt;	&lt;&#x2F;bean&gt;  &#x2F;&#x2F;abstract&#x3D;&quot;true&quot;,这个Bean的配置是一个抽象的，不能获取他的实例，只能被别人用来继承


bean之间的依赖（只是改变创建顺序）如果在创建之前写入 depends-on=‘book,person“，那么就会先创建book 还有person。


通过静态工厂方法创建bean，实例工厂方法创建beanbean的创建默认就是框架利用反射new出来的bean实例，工厂模式就是有一个类帮你去创建对象


静态工厂：工厂本身不用创建对象：通过静态方法调用  对象 = 工厂类.工厂方法名（）
实例工厂：工厂本身需要创建对象：
工厂类 工厂对象 =  new 工厂类（）；工厂对象.getAirplane

123factory-method：指定工厂方法class:指定静态工厂全类名&lt;constructor-arg value&#x3D;&quot;李四&quot;&gt;&lt;&#x2F;constructor-arg&gt;传参

实例工厂


先配出实例工厂对象
配置我们需要创建的airPlane使用哪个工厂创建
facotry-bean ：指定使用哪个工厂实例
factory-method：使用哪个工厂方法


FactoryBean（是Spring规定的一个接口);只要是这个接口的实现类，Spring都认为是一个工厂，ioc容器启动的时候就不会创建实例

bean的生命周期
ioc容器中注册的bean：

单例bean ，容器启动的时候才会创建好，容器关闭也会销毁创建的bean
多例bean，获取的时候才会创建


引用外部属性文件:

数据库连接池作为单实例是最好的，一个项目就一个连接池，连接池里面管理很多连接。连接直接从连接里拿，可以让spring 帮我们创建连接池对象。
依赖context名称空间，可以加载外部配置文件



自动装配（自动赋值）
autowire= “default” ，可以填byName ,byType, constructor,no。
例如说byName，按照名字，以属性名作为id去容器里找到这个组件，给他赋值。如果找不到就装配null

Spring有四种注解：
@Controller  控制器
@Service 业务逻辑
@Respository 数据库（持久化层）
@Component 
注意：某个类上添加任何一个注解都能快速的将这个组件加入ioc容器的管理 



添加步骤：
加入注释:告诉Spring，自动扫描加注释，依赖名称空间 –context:component-scanbase.package:” “填入需要扫描的包，至少填两级目录
在ioc获取bean的过程中，id是默认是类名的首字母小写， 也可以在注释后加入()来修改名字



</section>
    <p class="sub">Dec 14, 2019</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/blog/2019/12/12/frontEnd_Loading/" class="title">用CSS3做LoadIng动画</a>
    <section class="desc">
  使用CSS3做Loading动画

</section>
    <p class="sub">Dec 12, 2019</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/blog/2019/10/02/vue/" class="title">vue学习笔记</a>
    <section class="desc">
  vue学习笔记概念：Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现在话的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。vue的特点：
渐进式：vue的侵入性很少，可以与很多其他前端技术联用
组件化
响应式：数据响应式，vue会监控数据变化。当数据变化时

vue的核心功能：关于创建vue工程
直接在页面上引用vue.js
使用构建工具vue-cli脚手架

vue实例vue实例：通过new vue（配置对象）得到的对象
当创建vue实例的时候，vue将会把data（为了实现响应式）methods配置（为了在模板中方便使用）等配置成员提升到vue实例中.
由于有提升的存在，为了防止命名冲突，vue会将自身的成员名称前加上$ 或 _ , 为了防止命名冲突，vue会将自身的成员加上$(可以使用),_符号就不用用了

模板插值：在模板的元素内部使用指令：通常作为元素的属性存在，名称上以v- 开头v-for:用于循环生成元素v-on :用于注册事件。 语法糖@v-if :用于判断该玄素是否可以生成,可以与v-else 或者v-else-if联用v-show:元素已经显示,display:nonev-bind:用于绑定属性, 语法糖:v-model：用于事件双向绑定，实际上是自动绑定用了value值,和注册了input事件
模板中的配置
页面中直接书写
在template配置中书写（常见）
在render中手动配置用函数创建，render函数的参数是一个创建虚拟DOM对象，为什么要创建虚拟DOM,因为真实DOM操作特别慢

配置对象
template:字符串，配置模板
el:配置控制的元素，css选择器
data: 管理的数据，该数据是响应式的
mothods:配置方法，方法中的this指向vue实例，不能会用箭头函数,会干扰vue绑定this挂在的配置
通过el进行配置
使用vue实例中的$mount函数进行配置

关于computed –计算属性
计算属性，其中的配置会提升到vue实例中，因为在模板中可以直接当做属性使用，使用时，实际上调用的是对应的方法。通常，计算属性用户通过data或其他计算属性得到的数据。
与方法的区别：vue会检查计算属性的依赖，当依赖没有发生变化时，vue会直接使用之前缓存的结果，而不会重新计算
能用计算属性尽量使用，因为效率很高。依赖不变时不会重新加载。（计算属性的读取函数不可以有参数，有参数没意义）
计算属性可以配置get和set. 分别用于读取时和设置时。 get读取属性的时候可以监听到，然后检查那张表函数有没有变化。

关于v-html指令：
vue为了安全，会将元素内部的插值进行实体编码

12345678910&lt;div v-html &#x3D; &quot;html&quot;&gt;    &lt;&#x2F;div&gt;config &#x3D; &#123;    data:&#123;        html:&lt;p&gt;带标签的元素&lt;&#x2F;p&gt;    &#125;&#125;&#x2F;&#x2F;这样就可以把html标签渲染出来了

组件组件是页面中可复用的功能单元
VUE中的组建
组件的创建：组件对于开发者，是一个普通的配置对象
组件的注册：1234567891011121314&#x2F;&#x2F;全局注册组件Vue.component(&quot;组件形成&quot;,pager)&#x2F;&#x2F;局部注册组件 在使用的组件和vue实例配置中进行注册const config &#x3D; &#123;    template:&#96;&lt;div&gt;        &lt;MyPager&gt;&lt;&#x2F;MyPager&gt;    &lt;&#x2F;div&gt;&#96;,    el:&quot;#app&quot;,    components:&#123;        MyPager :pager    &#125;&#125;



组件名称的规范，以下命名的方式任选其一：
使用短横线命名
使用大驼峰命名组件的使用：把组件当成标签使用即可，标签名任选其一
短横线命名
大驼峰命名

组件可以嵌套，因为会形成一个组件树，组件树的根叫做根组件
组件中的数据通信：
prevent修饰符用于v-on指令，表示阻止默认行为
stop修饰符用于v-on指令，表示阻止事件冒泡

组件的状态和属性：
通常讲组件中需要自身管理的数据（组件配置中的data）叫做组件状态（component state），组件状态只能在组件内部使用，外部原则上不可以使用.
data(state 状态)在组件中的配置和在vue实例中配置的区别：在组件中data必须是一个函数，而VUE实例中心必须是一个对象。因为组件是可以被复用的，每一个组件都是独立的，所以data必须是一个函数.

123456789&#x2F;&#x2F;在组件中export default&#123;    template,    data()&#123;        return &#123;            &#x2F;&#x2F;返回的结果是组件的状态        &#125;    &#125;&#125;

组件中可以有属性（component props），而vue实例中没有
声明组件属性时，使用短横线或小驼峰命名法
传递组件属性时，使用短横线或小驼峰命名法
属性会被提升到vue组件实例中

==组件的属性时只读的，不允许更改，根本原因是要保证单向数据流==  
自定义事件：
在组件中触发事件： this.$emit(“事件名”,事件参数…)
当一个组件状态发生变化时，该组件会重新渲染，在渲染的过程中，可能会导致其子组件的属性发生变化，而属性的变化会导致组件重新渲染。但根本原因，是状态的变化.
v-model 的本质是一个语法糖，实际上是绑定value属性，同时监听input事件

组件的生命周期
beforeCreate(){}  –&gt;这个是自动执行的
created()  –&gt;组件实例中已经提升到实例总，但是没有渲染页面
beforeMount   –&gt; 组件即将进行渲染，但还没有渲染，此时已经编译好模板
mounted【常用】  –&gt;组件已经完成渲染（页面可见）
beforeUpdate –&gt;组件即将更新，还没有更新，此时得到的数据是新的，但页面依旧是旧的
updated –&gt; 数据，界面都是新的
beforeDestory –&gt; 当组件即将被销毁  调用vm.$destroy()函数
destoryed  –&gt; 解除绑定，销毁子组件以及事件监听器

vue路由vue路由，可以简单理解为，当访问某个地址时，渲染某个组件
使用路由

根据一个配置对象创建路由，得到路由对象
在创建vue实例时，将路由对象配置到实例配置的router中
在合适的位置写上router-view组件，表示路由匹配到组件渲染的位置，它实际上是vue-router做好的一个组件，并且做好了全局注册

路由配置对象

routes:路由规则配置
mode:配置模式
hash模式，兼容性最好，地址出现#号后，切换地址不会导致页面刷新
history模式，使用的是HTML5 history API，地址直接变化，并且页面不刷新





</section>
    <p class="sub">Oct 2, 2019</p>
  </div>
</div>-->
<!---->
<!--  <div class="project-card">
  
  <div class="ctnWrap">
    <a href="/blog/2019/09/03/2019.09.03/" class="title">2019-09-03 实习笔记</a>
    <section class="desc">
  背景：
今天刷面试题的时候，遇到一个问题——如何判断一段字符串里面出现最多的字符以及出现次数。

思路
利用javascript对象的属性特征，可以实现每个字符与出现次数的绑定
通过遍历和累加，计算得出每个字符出现的次数
通过对比出现的次数，返回出现次数最多的字符

12345678910111213141516171819202122232425262728293031323334353637const str &#x3D; &#39;asddfgdfwwqeweqwezczxcsdfgdgd&#39;;   var obj &#x3D; &#123;&#125;;   var max &#x3D; 0;   var maxStr &#x3D; &quot;&quot;;   for(let i &#x3D; 0; i &lt; str.length ; i++)&#123;     var word &#x3D; str.charAt(i);     if(obj[word] !&#x3D; null)&#123;       obj[word]++;     &#125;else&#123;       obj[word] &#x3D; 1     &#125;          for(let i in obj)&#123;       if(obj[i]&gt;max)&#123;         max &#x3D; obj[i];         maxStr &#x3D; i       &#125;     &#125;        &#125;   console.log(&#39;出现最多次:&#39; + max +&#39;的字符是：&#39;+ maxStr)   console.log(obj);   &#x2F;&#x2F; &#123;a: 1, s: 2, d: 6, f: 3, g: 3, …&#125;   &#x2F;&#x2F; a: 1   &#x2F;&#x2F; c: 2   &#x2F;&#x2F; d: 6   &#x2F;&#x2F; e: 3   &#x2F;&#x2F; f: 3   &#x2F;&#x2F; g: 3   &#x2F;&#x2F; q: 2   &#x2F;&#x2F; s: 2   &#x2F;&#x2F; w: 4   &#x2F;&#x2F; x: 1   &#x2F;&#x2F; z: 2   &#x2F;&#x2F; __proto__: Object

</section>
    <p class="sub">Sep 3, 2019</p>
  </div>
</div>-->
<!---->
<!--
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/2/">&lt;span class&#x3D;&quot;iconfont icon-arrow-right&quot;&gt;&lt;&#x2F;span&gt;</a>
  </nav>

-->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/css/swiper.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/js/swiper.min.js"></script>
<div class="main-right flex1 flex flex-v">
    <div class="box-content flex1">
        <div class="swiper-container">
            <div class="swiper-wrapper">
                
                    <a title="ES6异步的解决方案" alt="ES6异步的解决方案" href="/blog/2020/02/27/es6-async/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="ES6异步的解决方案" alt="ES6异步的解决方案"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; ES6异步的解决方案 &gt;</div>
                            <div class="content flex1">
                                
  背景js经常会遇到一些异步任务（需要经过一段时间或当某个时机到达后才能得到的任务）例如说：

使用ajax请求服务器，当服务器完成响应后拿到响应结果
监听按钮是否被点击，当按钮点击后拿到某个文本框的值
使用setTimeout 等待一段时间，当时间到达后做某些事情

面对这样的场景，JS没有一种标准的模式来进行处理，我们处理这些问题的方式是杂乱的，这就导致了不同的人书写的异步任务代码使用方式不一致。例如说实用第三方库，不知道要传进去多少个参数，或者各种参数放第几位。
ES6异步处理模型ES6将异步场景分为两个阶段和三种状态
两个场景： unsettled (未决)  settled (已决)
三种状态： pending (挂起) resolved(完成) rejected (失败)

当任务处于未决时状态一定是pending的，表示任务从开始至拿到结果之间的过程。例如说网络完成了各种配置，发送了请求但还没有收到回复当任务处于已决时它只能是resolved和reject两种状态之间的一种。例如说拿到或者没拿到数据--&gt; resolved状态 。网络不通畅 --&gt; rejected状态我们把从未决推向已决的resolved状态的过程，叫做resolve，从未决推向已决的rejected状态的过程，叫做reject如下图所示
任务已决后(有了结果)进一步做后续处理，如果任务成功了（resolved）,有后续处理，如果任务失败了（rejected）,仍可能做后续处理我们把针对resolved的后续处理称之为thenable，针对rejected的后续处理，称之为catchable
注意事项
任务一旦进入已决后，所有企图改变代码任务状态的代码都将失效
以下代码可以让任务达到rejected 状态
调用reject
代码执行报错
抛出错误


后续处理函数一定是异步函数，并且放在微队列中




                            </div>
                            <div class="post-tags">
                                
                                    <span href="" class="">
                      # 前端技术
                    </span>
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Feb 27, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="ES6模块化" alt="ES6模块化" href="/blog/2020/02/23/ES6-modular/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="ES6模块化" alt="ES6模块化"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; ES6模块化 &gt;</div>
                            <div class="content flex1">
                                
  ES6的模块化模块（module）:一块具有独立功能的代码，可以是一个函数，一个对象，甚至是一个字符串或数字，通常存储为一个单独的js文件模块化背景过去js很难编写大型应用，因为有以下两个问题：

全局变量污染
难以管理的依赖关系这些问题，都导致了JS无法进行精细的模块划分，因为精细的模块划分会导致更多的全局污染更加负载的依赖关系，因为功能精细的划分有利于代码重用

前端的模块化有两个标准：
Commonjs
ES6 Module注意：上面提到的两个均是模块化标准，具体的实现需要依托于JS的

ConmomJS简介：目前，只有node环境才支持CommonJs模块化标准，所以需要先安装node才能使用CommonJS在CommonJS中，浏览器运行的是html页面，并加载页面通过script元素引入js，node.js直接运行某个js文件，该文件被称之为入口文件。node.js遵循ECMAScript标准，但脱离了浏览器环境：你可以在node.js中使用ECMAScript标准的任何语法或api，例如循环，判断，数组，对象等等但不能在node.js中使用浏览器的web api,例如说dom对象，window对象，document对象
CommonJS标准和使用node中的所有代码均在CommonJS下运行，具体规范如下 ：

一个js文件既为一个模块如果一个模块需要暴露依稀额数据或功能给其他模块使用，需要使用代码module.exports = xxx ,该过程称之为模块的导出

如果一个模块需要使用另一个模块导出的内容，需要使用代码require(‘模块路径’)
12路径必须以.&#x2F;或..&#x2F;开头如果模块文件后缀名为  .js 可以省略后缀名
require 函数中返回的是模块导出的内容,且模块中所有的全局代码产生的变量、函数均不会对全局造成任何污染，仅在模块内使用

模块具有缓存，第一次导入模块时会缓存模块的导出，之后再导入同一个模块 会使用之前缓存的结果


有了CommomJS模块化，代码就会形成以下结构：
原理：node实际上是将模块文件中的代码防止到一个函数环境中执行，可以想象该函数是下面的样子：
12345function(module)&#123;    module.exports &#x3D; &#123;&#125;;    var exports &#x3D; module.exports;    return module.exports;&#125;



ES6 module
由于种种原因，CommonJS难以在浏览器中实现，因为一直在浏览器端没有合适的模块化标准，直到es6出现。ES6规范了浏览器的模块化标准，一经发布，各大浏览器厂商纷纷在自己的浏览器中实现该规范。

模块的引入：
12&#x2F;&#x2F;在浏览器使用以下方式引入ES6模块文件&lt;script src &#x3D; &quot;入口文件&quot; type &#x3D; &quot;module&quot;&gt;




标准和使用模块的导出分为两种，基本导出和默认导出
12345678可以将整个模块的导出想象成一个对象，基本导出导出的是该对象的某个属性，默认导出导出的是该对象的特殊属性default&#x2F;&#x2F;导出结果：想象成一个对象&#123;    a: xxx, &#x2F;&#x2F;基本导出    b: xxx, &#x2F;&#x2F;基本导出    default: xxx, &#x2F;&#x2F;默认导出    c: xxx &#x2F;&#x2F;基本导出&#125;


ES6的导出方式：1234567891011121314export var a &#x3D; 1 &#x2F;&#x2F;基本导出 a &#x3D; 1export var b &#x3D; function()&#123;&#125; &#x2F;&#x2F;基本导出 b &#x3D; function()&#123;&#125;export function method()&#123;&#125;  &#x2F;&#x2F;基本导出 method &#x3D; function()&#123;&#125;var c &#x3D; 3;export &#123;c&#125; &#x2F;&#x2F;基本导出 c &#x3D; 3export &#123; c as temp &#125; &#x2F;&#x2F;基本导出 temp &#x3D; 3export default 3 &#x2F;&#x2F;默认导出 default &#x3D; 3export default function()&#123;&#125; &#x2F;&#x2F;默认导出 default &#x3D; function()&#123;&#125;export &#123; c as default &#125; &#x2F;&#x2F;默认导出 default &#x3D; 3export &#123;a, b, c as default&#125; &#x2F;&#x2F;基本导出 a&#x3D;1, b&#x3D;function()&#123;&#125;, 默认导出 default &#x3D; 3绝大部分时间写代码使用的导出方式是 export default()&#123;&#125;
ES6模块的导入：使用以下的代码导入模块
12345678import &#123;a,b&#125; from &quot;模块路径&quot;   &#x2F;&#x2F;导入属性 a、b，放到变量a、b中import &#123;a as temp1, b as temp2&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性a、b，放到变量temp1、temp2 中import &#123;default as a&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default，放入变量a中，default是关键字，不能作为变量名，必须定义别名import &#123;default as a, b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;导入属性default、b，放入变量a、b中import c from &quot;模块路径&quot;  &#x2F;&#x2F;相当于 import &#123;default as c&#125; from &quot;模块路径&quot;import c, &#123;a,b&#125; from &quot;模块路径&quot; &#x2F;&#x2F;相当于 import &#123;default as c, a, b&#125; from &quot;模块路径&quot;import * as obj from &quot;模块路径&quot; &#x2F;&#x2F;将模块对象放入到变量obj中import &quot;模块路径&quot; &#x2F;&#x2F;不导入任何内容，仅执行一次模块
细节导入模块时，注意以下细节

ES6 module 采用依赖预加载模式，所有模块导入代码均会提升到代码顶部
不能将导入代码放置到判断、循环中
导入的内容放置到常量中，不可更改
ES6 module 使用了缓存，保证每个模块仅加载一次




                            </div>
                            <div class="post-tags">
                                
                                    <span href="" class="">
                      # 前端技术
                    </span>
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Feb 23, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="当在浏览器输入一个地址发生了什么" alt="当在浏览器输入一个地址发生了什么" href="/blog/2020/02/15/when-Enter-an-address/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="当在浏览器输入一个地址发生了什么" alt="当在浏览器输入一个地址发生了什么"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 当在浏览器输入一个地址发生了什么 &gt;</div>
                            <div class="content flex1">
                                
  是这样的：
浏览器将url地址补充完整，如果没有写协议就自动添加上协议（http： / https：）

浏览器对url地址进行url编码，如果url地址中出现了非ASCII字符，浏览器则会对其进行编码

例如说在浏览器中搜索”王思聪”，汉字会被编码成ASCII码


浏览器构造一个没有消息体的GET请求，发送至服务器，等待服务器响应（此时浏览器标签应该有一个等等的图标–转圈）

服务器收到请求，将一个HTML页面代码组装到消息体中（不一定要html文件）响应给浏览器

浏览器拿到服务器的响应后，丢弃当前的页面，开始渲染消息体的HTML代码。浏览器之所以知道这是一个HTML代码，是因为服务器的响应头指定了消息类型为text/html

浏览器在渲染页面的过程中发现有嵌入的资源如CSS,JS图片等

浏览器使用不阻塞的渲染方式，重定向服务器发送该资源的请求，拿到响应结果后根据Content-Type做响应处理

当所有资源已经下载并处理好后，浏览器出发window.onload事件


   这里说的Content-Tpye是在http协议消息头中表示具体请求中的媒体类型信息
   有一下几种类型：
   



                            </div>
                            <div class="post-tags">
                                
                                    <span href="" class="">
                      # 前端技术
                    </span>
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Feb 15, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="实现一个简单的VUE" alt="实现一个简单的VUE" href="/blog/2020/02/12/vue-demo-1/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="实现一个简单的VUE" alt="实现一个简单的VUE"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 实现一个简单的VUE &gt;</div>
                            <div class="content flex1">
                                
  
实现的效果




     



目标​    实现一个简单的vue函数，包括双向数据绑定，数据的响应式
思路1. 首先想到要实现vue的数据绑定，根据vue的双向数据绑定，把{{xxx}} 与data{}里面的值进行绑定。将值绑定后，我们想到要将这些数据渲染出来，这里就需要知道页面的各个节点与各节点的子节点
 2. 再到数据响应模块，使用object.defineProperty来实现数据的响应式，用get方法来读取属性的值，用set方法来写入属性的值，以此来实现数据绑定
 3. 最后为Vue添加构造函数，例如说this.$el 来表示绑定的元素，$data来表示绑定的数据，$vnode代表虚拟节点模块划分
编译模块
虚拟节点模块
渲染模块
数据响应模块
VUE构造函数模块

编译模块
提供一个compile函数，将一个模板文本(数据)和环境对象（DOM节点）编译成一个结果思想：


使用正则表达式匹配到html代码中包含 括号 的字符串
拿到字符串之后把两边括号替换掉，把表达式分割成数组
这需要与envObj环境变量进行配合使用，绑定后变成一个数组



compile.js 代码

1234567891011121314151617181920212223242526//过程： 先拿到&#123;&#123;xxx&#125;&#125;里面的字符串，然后再对字符串进行加工function getFragments(template) &#123;    var matches = template.match(/&#123;&#123;[^&#125;]+&#125;&#125;/g); //万一有人的用户名叫12&#125;  所以这里要处理一下    return matches || [];&#125;function getValue(fragment, envObj) &#123;    var exp = fragment.replace("&#123;&#123;", "").replace("&#125;&#125;", "");    var props = exp.split(".");//将表达式分割为属性数组    var obj = envObj;    for (var i = 0; i &lt; props.length; i++) &#123;        obj = obj[props[i]];    &#125;    return obj;&#125;export default function compile(template, envObj) &#123;    // 提取模板中的&#123;&#123;&#125;&#125;    var flags = getFragments(template);    var result = template;    for (var i = 0; i &lt; flags.length; i++) &#123;        var flag = flags[i];        result = result.replace(flag, getValue(flag, envObj))    &#125;    return result;&#125;



虚拟DOM:
提供一个函数createVNode,根据提供真实的DOM，构建一个虚拟DOM树思想：


需要创建虚拟DOM 以便以后操作数据
需要判断真实节点是否为文本节点，如果是就要记录到虚拟节点

12345678910111213141516171819202122232425function VNode(realDom, template) &#123;    // node 构造函数    this.realDom = realDom;    this.template = template;    this.children = [];&#125;export default function createVNode(realDom) &#123;    var root = new VNode(realDom, "");    if (realDom.nodeType === Node.TEXT_NODE) &#123;        root.template = realDom.nodeValue;        // 判断真实节点是否为文本节点，如果是，就要记录到虚拟节点        // 文本节点代表的数字是3    &#125;    else &#123;        for(var i  = 0; i&lt; realDom.childNodes.length;i++)&#123;            var childNode = realDom.childNodes[i];            var vNode = createVNode(childNode)            root.children.push(vNode);        &#125;    &#125;    return root;&#125;




渲染模块
用于提取虚拟节点，将其模板编译结果设置到真实的dom中，对虚拟节点的子节点也做同样的操作

123456789101112131415import compile from "./compile.js";// 渲染一个虚拟节点（将文本的虚拟节点进行编译）export default function render(vnode, envObj) &#123;    if (vnode.realDom.nodeType === Node.TEXT_NODE) &#123;        vnode.realDom.nodeValue = compile(vnode.template, envObj);    &#125;    else &#123;        for (var i = 0; i &lt; vnode.children.length; i++) &#123;            var childNode = vnode.children[i];            render(childNode, envObj);        &#125;    &#125;&#125;



数据响应模块
主要负责将原始对象的数据附加到代理对象上，代理对象能够监听到数据的更改，当数据发生改变时，执行某个回调函数(就可以实现数据响应)


使用Object.defineProperty来实现数据的响应式

这里有一个关键是当代理一个对象是，发现对象里面还有属性没法代理。这时候就要重新申请一个新的代理（如下图）



123456789101112131415161718192021222324252627282930313233343536373839404142// 将原始对象的prop属性添加到代理对象中function proxyProp(originalObj, targetObj, prop, callback) &#123;    if (typeof originalObj[prop] === "object") &#123;        // 要代理的属性是一个对象,对象要单独处理        var newTarget = &#123;&#125;;//新的 要代理的对象        createResponsive(originalObj[prop], newTarget, callback);        Object.defineProperty(targetObj,prop,&#123;            get:function()&#123;                return newTarget;            &#125;,            set:function(value)&#123;                originalObj[prop] = value;                newTarget = value;                callback &amp;&amp; callback(prop);            &#125;        &#125;)    &#125;    else &#123;        Object.defineProperty(targetObj, prop, &#123;            get: function () &#123;                return originalObj[prop];            &#125;,            set: function (value) &#123;                originalObj[prop] = value;                callback &amp;&amp; callback(prop);            &#125;        &#125;)    &#125;&#125;// 将原始对象的属性，提取到代理对象中// org是原始对象， target是代理对象 当代理对象被赋值的时候要调用回调函数export default function createResponsive(originalObj, targetObj, callback) &#123;    for (var prop in originalObj) &#123;        proxyProp(originalObj, targetObj, prop, callback);    &#125;&#125;

为vue写一个构造函数12345678910111213141516171819import createVNode from './vnode.js'import createResponsive from './dataResponsive.js'import render from './render.js'export default function vue(option) &#123;    this.$el = option &amp;&amp; option.el;    this.$data = option &amp;&amp; option.data;    this.$vnode = createVNode(document.querySelector(this.$el))    var that = this;    createResponsive(this.$data, this, function () &#123;        // 重新渲染        that.render();    &#125;)    this.render()//初次渲染&#125;vue.prototype.render = function () &#123;    render(this.$vnode, this);&#125;





在前端页面写一个简单的VUE结构
在前端页面写一个简单的VUE结构，测试一下是否正确

1234567891011121314&lt;script&gt;    import Vue from "./vue/index.js"        window.vm = new Vue(&#123;            el: "#app",            data: &#123;                name:"FengZe",                age:16,                addr:&#123;                    province:"广东",                    city:"佛山"                &#125;            &#125;        &#125;)&lt;/script&gt;

大概就是这样实现的了.
源码地址：https://github.com/FengZeHe/vue_demo




                            </div>
                            <div class="post-tags">
                                
                                    <span href="" class="">
                      # 前端技术
                    </span>
                                
                                    <span href="" class="">
                      # vue
                    </span>
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Feb 12, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="vue_demo" alt="vue_demo" href="/blog/2020/02/12/vue-demo/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="vue_demo" alt="vue_demo"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; vue_demo &gt;</div>
                            <div class="content flex1">
                                
  


                            </div>
                            <div class="post-tags">
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Feb 12, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="如何实现一个简单的ofo微信小程序" alt="如何实现一个简单的ofo微信小程序" href="/blog/2020/01/10/ofo_demo/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="如何实现一个简单的ofo微信小程序" alt="如何实现一个简单的ofo微信小程序"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 如何实现一个简单的ofo微信小程序 &gt;</div>
                            <div class="content flex1">
                                
  
实现的效果




     






实现功能简介：

扫码骑车记时功能
用户登录及充值功能
用户报障功能

思路：

要实现这些功能，首先要设置一个首页，首页里面包含所有功能按钮，包括回到当前定位，立即用车，单车报障及个人用户按钮
回到当前定位功能直接调用this.movetoCenter()函数
立即用车功能;调用扫码接口获取开锁密码与当前单车编号，完事进入开锁界面并在90秒后跳转到计费页面并开始记录用户当前开始用车时间。
不过这里需要注意的是在计费中页面，用户仍然可以切换到首页地图，再次点击扫码用车的时候直接进入计费页面。
因为切回首页是把计费页面放在后台,所以使用navtgateTo()方法，而不是使用redirectTo()方法。


单车报障功能
这里要说一嘴的是故障类型跟上传照片是必填，要验证内容是否为空。这里我只是判断了input框中的长度是否大于0；
上传照片这里调用了微信的chooseImage()接口；我使用了一个数组存储上传的照片，所以在删除的时候直接在数组干掉就好了。


用户登录及充值功能
用户登录这里要注意下微信新版本是要授权，在按钮处设置open-type 为 getUserInfo才能使用。
另外我把用户数据存进了storage,这样处理下一次就可以自动登录了。同时在登出的时候也会删除storage.




关于后台：    因为时间（技术）问题暂时没有做出来，后续版本就有了嘿。因此这次我在modeHttp在线mock了后台数据。


源码地址：https://github.com/FengZeHe/ofo_demo




                            </div>
                            <div class="post-tags">
                                
                                    <span href="" class="">
                      # 前端技术
                    </span>
                                
                                    <span href="" class="">
                      # 微信小程序
                    </span>
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Jan 10, 2020</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="Spring学习笔记" alt="Spring学习笔记" href="/blog/2019/12/14/spring/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="Spring学习笔记" alt="Spring学习笔记"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; Spring学习笔记 &gt;</div>
                            <div class="content flex1">
                                
  Spring学习笔记框架的概念：
高度抽取可重用代码的设计
高度的通用性

Spring的特点:优良特性：

非侵入式
依赖注入
面向切面编程
容器
组件化
一站式


Core Container（IOC）核心容器包含Bean Core Context expression 这几个容器

Web：Sping开发Web应用
WebSocket
Servlet
web protlet
(建议用哪个模块就导哪个包)



IOC：
控制反转;被动式的资源获取方式：资源的获取不是自己创建，而是交给容器创建和设置

DI：（Injevtion  依赖注入）
容器能知道哪个组件（类运行的时候时候需要另外一个类）
只要使用管理的组件，都能使用组件提供的强大功能。现在所有的对象交给容器创建，容器中的组件注册。

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;bean id &#x3D; &quot;person03&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;		&lt;constructor-arg name&#x3D;&quot;lastName&quot; value&#x3D;&quot;小明&quot;&gt;&lt;&#x2F;constructor-arg&gt;		&lt;constructor-arg name&#x3D;&quot;email&quot; value&#x3D;&quot;skjdhfkjsdfhkd@126.com&quot;&gt;&lt;&#x2F;constructor-arg&gt;		&lt;constructor-arg name&#x3D;&quot;gender&quot; value&#x3D;&quot;男&quot;&gt;&lt;&#x2F;constructor-arg&gt;		&lt;constructor-arg name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;constructor-arg&gt;	&lt;&#x2F;bean&gt; &#x2F;&#x2F;有参构造器 &lt;constructor-arg&gt;就代表一个属性  &lt;bean id&#x3D;&quot;person01&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;		&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;he&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;age&quot; value &#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;hzf@666.com&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;man&quot;&gt;&lt;&#x2F;property&gt;	  &lt;&#x2F;bean&gt;  &#x2F;&#x2F;通过无参构造器  &#x2F;&#x2F;如果省略name参数 就要严格按照构造器参数的位置  &#x2F;&#x2F;在重载的情况下 type可以指定参数的类型    &#x2F;&#x2F;名称空间：在xml中名称空间是用来防止标签重复的  &lt;book&gt;      &lt;b:name&gt;西游记&lt;&#x2F;name&gt;      &lt;author&gt;         &lt;a:name&gt;吴承恩&lt;&#x2F;name&gt;       &lt;&#x2F;author&gt;  &lt;&#x2F;book&gt;  通过标签的前缀，就可以知道name是指哪个name    xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;      &lt;property name&#x3D;&quot;lastName&quot;&gt;      &lt;&#x2F;null&gt; &#x2F;&#x2F;进行复杂的赋值，在property标签里面   &lt;&#x2F;property&gt;    &#x2F;&#x2F;如果把多个属性赋值给一个对象呢    &lt;bean  id &#x3D;&quot;car01&quot; class&#x3D;&quot;com.bean.Car&quot;&gt;		&lt;property name&#x3D;&quot;carName&quot; value&#x3D;&quot;宝马&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;color&quot; value&#x3D;&quot;pink&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;price&quot; value&#x3D;&quot;30000&quot;&gt;&lt;&#x2F;property&gt;		  &lt;&#x2F;bean&gt;    &lt;property name&#x3D;&quot;car&quot; ref&#x3D;&quot;car01&quot;&gt;&lt;&#x2F;property&gt;  &#x2F;&#x2F;在person01的容器中加入这段代码就ok      &#x2F;&#x2F;在bean里面写property写是引用外部bean， 在property里面写bean是引用内部bean

Spring在为各种属性赋值：
在bean使用ref写是引用外部bean， 在property里面写bean是引用内部bean
在对list属性进行赋值，写在property里面，同时也可以使用ref引用外部赋值
在对map属性进行赋值，在property键值对里面&lt;entry&gt;标签，在标签内使用key value进行键值对的赋值。
util名称空间创建集合类型的bean 方便别人引用123&lt;util:map id&#x3D;&quot;myMap&quot;&gt;&#x2F;&#x2F;一定要有Id    &#x2F;&#x2F;里面写的直接是元素&lt;&#x2F;util:map&gt;




级联属性赋值：就是属性的属性


通过继承实现bean配置信息的重用

123456789101112&lt;bean id&#x3D;&quot;parent05&quot; class&#x3D;&quot;com.bean.Person&quot;&gt;		&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;gender&quot; value&#x3D;&quot;男&quot;&gt;&lt;&#x2F;property&gt;		&lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;akshdajsk&quot;&gt;&lt;&#x2F;property&gt;	&lt;&#x2F;bean&gt;		&lt;bean id&#x3D;&quot;person06&quot; class&#x3D;&quot;com.bean.Person&quot; parent&#x3D;&quot;parent05&quot;&gt;		&lt;property name&#x3D;&quot;lastName&quot; value&#x3D;&quot;fengZe&quot;&gt;&lt;&#x2F;property&gt;	&lt;&#x2F;bean&gt;  &#x2F;&#x2F;abstract&#x3D;&quot;true&quot;,这个Bean的配置是一个抽象的，不能获取他的实例，只能被别人用来继承


bean之间的依赖（只是改变创建顺序）如果在创建之前写入 depends-on=‘book,person“，那么就会先创建book 还有person。


通过静态工厂方法创建bean，实例工厂方法创建beanbean的创建默认就是框架利用反射new出来的bean实例，工厂模式就是有一个类帮你去创建对象


静态工厂：工厂本身不用创建对象：通过静态方法调用  对象 = 工厂类.工厂方法名（）
实例工厂：工厂本身需要创建对象：
工厂类 工厂对象 =  new 工厂类（）；工厂对象.getAirplane

123factory-method：指定工厂方法class:指定静态工厂全类名&lt;constructor-arg value&#x3D;&quot;李四&quot;&gt;&lt;&#x2F;constructor-arg&gt;传参

实例工厂


先配出实例工厂对象
配置我们需要创建的airPlane使用哪个工厂创建
facotry-bean ：指定使用哪个工厂实例
factory-method：使用哪个工厂方法


FactoryBean（是Spring规定的一个接口);只要是这个接口的实现类，Spring都认为是一个工厂，ioc容器启动的时候就不会创建实例

bean的生命周期
ioc容器中注册的bean：

单例bean ，容器启动的时候才会创建好，容器关闭也会销毁创建的bean
多例bean，获取的时候才会创建


引用外部属性文件:

数据库连接池作为单实例是最好的，一个项目就一个连接池，连接池里面管理很多连接。连接直接从连接里拿，可以让spring 帮我们创建连接池对象。
依赖context名称空间，可以加载外部配置文件



自动装配（自动赋值）
autowire= “default” ，可以填byName ,byType, constructor,no。
例如说byName，按照名字，以属性名作为id去容器里找到这个组件，给他赋值。如果找不到就装配null

Spring有四种注解：
@Controller  控制器
@Service 业务逻辑
@Respository 数据库（持久化层）
@Component 
注意：某个类上添加任何一个注解都能快速的将这个组件加入ioc容器的管理 



添加步骤：
加入注释:告诉Spring，自动扫描加注释，依赖名称空间 –context:component-scanbase.package:” “填入需要扫描的包，至少填两级目录
在ioc获取bean的过程中，id是默认是类名的首字母小写， 也可以在注释后加入()来修改名字




                            </div>
                            <div class="post-tags">
                                
                                    <span href="" class="">
                      # 后端技术
                    </span>
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Dec 14, 2019</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="用CSS3做LoadIng动画" alt="用CSS3做LoadIng动画" href="/blog/2019/12/12/frontEnd_Loading/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="用CSS3做LoadIng动画" alt="用CSS3做LoadIng动画"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 用CSS3做LoadIng动画 &gt;</div>
                            <div class="content flex1">
                                
  使用CSS3做Loading动画


                            </div>
                            <div class="post-tags">
                                
                                    <span href="" class="">
                      # 前端技术
                    </span>
                                
                                    <span href="" class="">
                      # CSS3
                    </span>
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Dec 12, 2019</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="vue学习笔记" alt="vue学习笔记" href="/blog/2019/10/02/vue/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="vue学习笔记" alt="vue学习笔记"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; vue学习笔记 &gt;</div>
                            <div class="content flex1">
                                
  vue学习笔记概念：Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现在话的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。vue的特点：
渐进式：vue的侵入性很少，可以与很多其他前端技术联用
组件化
响应式：数据响应式，vue会监控数据变化。当数据变化时

vue的核心功能：关于创建vue工程
直接在页面上引用vue.js
使用构建工具vue-cli脚手架

vue实例vue实例：通过new vue（配置对象）得到的对象
当创建vue实例的时候，vue将会把data（为了实现响应式）methods配置（为了在模板中方便使用）等配置成员提升到vue实例中.
由于有提升的存在，为了防止命名冲突，vue会将自身的成员名称前加上$ 或 _ , 为了防止命名冲突，vue会将自身的成员加上$(可以使用),_符号就不用用了

模板插值：在模板的元素内部使用指令：通常作为元素的属性存在，名称上以v- 开头v-for:用于循环生成元素v-on :用于注册事件。 语法糖@v-if :用于判断该玄素是否可以生成,可以与v-else 或者v-else-if联用v-show:元素已经显示,display:nonev-bind:用于绑定属性, 语法糖:v-model：用于事件双向绑定，实际上是自动绑定用了value值,和注册了input事件
模板中的配置
页面中直接书写
在template配置中书写（常见）
在render中手动配置用函数创建，render函数的参数是一个创建虚拟DOM对象，为什么要创建虚拟DOM,因为真实DOM操作特别慢

配置对象
template:字符串，配置模板
el:配置控制的元素，css选择器
data: 管理的数据，该数据是响应式的
mothods:配置方法，方法中的this指向vue实例，不能会用箭头函数,会干扰vue绑定this挂在的配置
通过el进行配置
使用vue实例中的$mount函数进行配置

关于computed –计算属性
计算属性，其中的配置会提升到vue实例中，因为在模板中可以直接当做属性使用，使用时，实际上调用的是对应的方法。通常，计算属性用户通过data或其他计算属性得到的数据。
与方法的区别：vue会检查计算属性的依赖，当依赖没有发生变化时，vue会直接使用之前缓存的结果，而不会重新计算
能用计算属性尽量使用，因为效率很高。依赖不变时不会重新加载。（计算属性的读取函数不可以有参数，有参数没意义）
计算属性可以配置get和set. 分别用于读取时和设置时。 get读取属性的时候可以监听到，然后检查那张表函数有没有变化。

关于v-html指令：
vue为了安全，会将元素内部的插值进行实体编码

12345678910&lt;div v-html &#x3D; &quot;html&quot;&gt;    &lt;&#x2F;div&gt;config &#x3D; &#123;    data:&#123;        html:&lt;p&gt;带标签的元素&lt;&#x2F;p&gt;    &#125;&#125;&#x2F;&#x2F;这样就可以把html标签渲染出来了

组件组件是页面中可复用的功能单元
VUE中的组建
组件的创建：组件对于开发者，是一个普通的配置对象
组件的注册：1234567891011121314&#x2F;&#x2F;全局注册组件Vue.component(&quot;组件形成&quot;,pager)&#x2F;&#x2F;局部注册组件 在使用的组件和vue实例配置中进行注册const config &#x3D; &#123;    template:&#96;&lt;div&gt;        &lt;MyPager&gt;&lt;&#x2F;MyPager&gt;    &lt;&#x2F;div&gt;&#96;,    el:&quot;#app&quot;,    components:&#123;        MyPager :pager    &#125;&#125;



组件名称的规范，以下命名的方式任选其一：
使用短横线命名
使用大驼峰命名组件的使用：把组件当成标签使用即可，标签名任选其一
短横线命名
大驼峰命名

组件可以嵌套，因为会形成一个组件树，组件树的根叫做根组件
组件中的数据通信：
prevent修饰符用于v-on指令，表示阻止默认行为
stop修饰符用于v-on指令，表示阻止事件冒泡

组件的状态和属性：
通常讲组件中需要自身管理的数据（组件配置中的data）叫做组件状态（component state），组件状态只能在组件内部使用，外部原则上不可以使用.
data(state 状态)在组件中的配置和在vue实例中配置的区别：在组件中data必须是一个函数，而VUE实例中心必须是一个对象。因为组件是可以被复用的，每一个组件都是独立的，所以data必须是一个函数.

123456789&#x2F;&#x2F;在组件中export default&#123;    template,    data()&#123;        return &#123;            &#x2F;&#x2F;返回的结果是组件的状态        &#125;    &#125;&#125;

组件中可以有属性（component props），而vue实例中没有
声明组件属性时，使用短横线或小驼峰命名法
传递组件属性时，使用短横线或小驼峰命名法
属性会被提升到vue组件实例中

==组件的属性时只读的，不允许更改，根本原因是要保证单向数据流==  
自定义事件：
在组件中触发事件： this.$emit(“事件名”,事件参数…)
当一个组件状态发生变化时，该组件会重新渲染，在渲染的过程中，可能会导致其子组件的属性发生变化，而属性的变化会导致组件重新渲染。但根本原因，是状态的变化.
v-model 的本质是一个语法糖，实际上是绑定value属性，同时监听input事件

组件的生命周期
beforeCreate(){}  –&gt;这个是自动执行的
created()  –&gt;组件实例中已经提升到实例总，但是没有渲染页面
beforeMount   –&gt; 组件即将进行渲染，但还没有渲染，此时已经编译好模板
mounted【常用】  –&gt;组件已经完成渲染（页面可见）
beforeUpdate –&gt;组件即将更新，还没有更新，此时得到的数据是新的，但页面依旧是旧的
updated –&gt; 数据，界面都是新的
beforeDestory –&gt; 当组件即将被销毁  调用vm.$destroy()函数
destoryed  –&gt; 解除绑定，销毁子组件以及事件监听器

vue路由vue路由，可以简单理解为，当访问某个地址时，渲染某个组件
使用路由

根据一个配置对象创建路由，得到路由对象
在创建vue实例时，将路由对象配置到实例配置的router中
在合适的位置写上router-view组件，表示路由匹配到组件渲染的位置，它实际上是vue-router做好的一个组件，并且做好了全局注册

路由配置对象

routes:路由规则配置
mode:配置模式
hash模式，兼容性最好，地址出现#号后，切换地址不会导致页面刷新
history模式，使用的是HTML5 history API，地址直接变化，并且页面不刷新






                            </div>
                            <div class="post-tags">
                                
                                    <span href="" class="">
                      # 前端技术
                    </span>
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Oct 2, 2019</span>
                            </div>
                        </div>
                    </a>
                
                    <a title="2019-09-03 实习笔记" alt="2019-09-03 实习笔记" href="/blog/2019/09/03/2019.09.03/"
                       class="post-item swiper-slide flex flex-v">
                        <div class="image">
                            
                                <img title="2019-09-03 实习笔记" alt="2019-09-03 实习笔记"
                                     src="/images/default.jpg"></img>
                            
                        </div>
                        <div class="content-warp flex1 flex flex-v">
                            <div class="title">&lt; 2019-09-03 实习笔记 &gt;</div>
                            <div class="content flex1">
                                
  背景：
今天刷面试题的时候，遇到一个问题——如何判断一段字符串里面出现最多的字符以及出现次数。

思路
利用javascript对象的属性特征，可以实现每个字符与出现次数的绑定
通过遍历和累加，计算得出每个字符出现的次数
通过对比出现的次数，返回出现次数最多的字符

12345678910111213141516171819202122232425262728293031323334353637const str &#x3D; &#39;asddfgdfwwqeweqwezczxcsdfgdgd&#39;;   var obj &#x3D; &#123;&#125;;   var max &#x3D; 0;   var maxStr &#x3D; &quot;&quot;;   for(let i &#x3D; 0; i &lt; str.length ; i++)&#123;     var word &#x3D; str.charAt(i);     if(obj[word] !&#x3D; null)&#123;       obj[word]++;     &#125;else&#123;       obj[word] &#x3D; 1     &#125;          for(let i in obj)&#123;       if(obj[i]&gt;max)&#123;         max &#x3D; obj[i];         maxStr &#x3D; i       &#125;     &#125;        &#125;   console.log(&#39;出现最多次:&#39; + max +&#39;的字符是：&#39;+ maxStr)   console.log(obj);   &#x2F;&#x2F; &#123;a: 1, s: 2, d: 6, f: 3, g: 3, …&#125;   &#x2F;&#x2F; a: 1   &#x2F;&#x2F; c: 2   &#x2F;&#x2F; d: 6   &#x2F;&#x2F; e: 3   &#x2F;&#x2F; f: 3   &#x2F;&#x2F; g: 3   &#x2F;&#x2F; q: 2   &#x2F;&#x2F; s: 2   &#x2F;&#x2F; w: 4   &#x2F;&#x2F; x: 1   &#x2F;&#x2F; z: 2   &#x2F;&#x2F; __proto__: Object


                            </div>
                            <div class="post-tags">
                                
                                    <span href="" class="">
                      # 前端技术
                    </span>
                                
                            </div>
                            <div class="other">
                                <!--<a><i class="iconfont icon-iconfontordinaryliulan"></i>52</a>-->
                                <!--<a><i class="iconfont icon-icon27"></i>52</a>-->
                                <span><i class="iconfont icon-shijian"></i>Sep 3, 2019</span>
                            </div>
                        </div>
                    </a>
                


            </div>
            <div class="swiper-scrollbar"></div>
        </div>
    </div>
</div>
<script>

    function getSwiperPrams() {
        var windowsWidth = $(document).width()
        var slidesPerView
        var direction;
        if(windowsWidth > 1500){
            direction = 'horizontal'
            slidesPerView = 4
        }else if(windowsWidth > 1100){
            direction = 'horizontal'
            slidesPerView = 3
        }else if(windowsWidth > 1000){
            direction = 'horizontal'
            slidesPerView = 2
        }else{
            slidesPerView = 1
            direction = 'vertical'
        }
        return {
            direction: direction,
            slidesPerView: slidesPerView
        }
    }
    var params = getSwiperPrams()

  var mySwiper = new Swiper('.swiper-container', {
    direction: params.direction, // 垂直切换选项
    mousewheel: true,
    slidesPerView: params.slidesPerView,
    spaceBetween: 30,
    scrollbar: {
      el: '.swiper-scrollbar'
    },
    on: {
        resize: function(){

        },
    },

    // 如果需要滚动条
    scrollbar: {
      el: '.swiper-scrollbar',
    },
  })
</script>

  </div>
  <div class="main-bottom">
    <div class="music flex flex-pack-justify flex-align-center">
      <div class="control">
        <a onclick="preSong()"><span class="iconfont icon-shangyishou"></span></a>
        <a onclick="playControl()"><span class="iconfont play-icon icon-kaishi1"></span></a>
        <a onclick="nextSong()"><span class="iconfont icon-xiayishou-copy"></span></a>
      </div>
      <div class="msg">
        <span class="time"></span>
        <div class="line" ref="progress-line-warp">
          <div class="song-msg">周杰伦 - 说好不哭</div>
          <!--<div class="current-line" ref="progress-line">
            <a tag="a" class="target" v-on:mousedown.prevent="mousedown"></a>
          </div>-->
        </div>
        <span class="all-time"></span>
      </div>
      <div class="right-control">
        <a class="order-btn flex flex-align-center" onclick="toogleShowMusicList()">
          <span class="iconfont icon-ttpodicon"></span>
          <span class="number flex1">3</span>
        </a>
      </div>
      <audio id="audio" class="mian-audio" src="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3">
        Your browser does not support the audio element.
      </audio>
    </div>
  </div>
  <div class="music-list">
    <div id="musiclist">
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 说好不哭" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E8%AF%B4%E5%A5%BD%E4%B8%8D%E5%93%AD.mp3" onclick="changePlayIndex(0)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">说好不哭 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 爱在西元前" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E7%88%B1%E5%9C%A8%E8%A5%BF%E5%85%83%E5%89%8D%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(1)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">爱在西元前 - 周杰伦</span>
        </a>
      
        <a class="music-item flex flex-align-center" data-name="周杰伦 - 龙拳" data-url="https://callmesoul-blog.oss-cn-shenzhen.aliyuncs.com/music/%E5%91%A8%E6%9D%B0%E4%BC%A6%20-%20%E9%BE%99%E6%8B%B3%20%5Bmqms2%5D.mp3" onclick="changePlayIndex(2)" >
          <span class="iconfont" class="icon-kaishi"></span>
          <span class="title flex1">龙拳 - 周杰伦</span>
        </a>
      
    </div>
  </div>
</div>

<script>
  var playIndex = localStorage.getItem('playIndex') ? parseInt(localStorage.getItem('playIndex')) : 0
  let musics = $('.music-item')
  musics.eq(playIndex).addClass('active')
  var audio = document.getElementById("audio");

  $('.song-msg').html(musics[playIndex].dataset.name)
  audio.src = musics[playIndex].dataset.url


  var playbtn = document.getElementsByClassName("play-icon")[0];
  var playing = false;
  audio.loop = false;
  audio.addEventListener('ended', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  audio.addEventListener('play', function () {
    playbtn.classList.remove("icon-kaishi1")
    playbtn.classList.add("icon-kaishi")
    playing= true
  }, false);
  audio.addEventListener('pause', function () {
    playbtn.classList.remove("icon-kaishi")
    playbtn.classList.add("icon-kaishi1")
    playing = false
  }, false);
  function toogleShowMusicList() {
    var musiclist = document.getElementsByClassName("music-list")[0];
    if(musiclist.className.indexOf("active") === -1){
      musiclist.classList.add("active")
    }else{
      musiclist.classList.remove("active");
    }
  }

  function playControl() {
    if(playing){
      audio.pause()
    }else{
      audio.play()
    }
  }

  function changePlayIndex(index) {
    if(playIndex !== index){
      localStorage.setItem('playIndex',index)
      playIndex = index
      musics.removeClass('active')
      musics.eq(playIndex).addClass('active')
      $('.song-msg').html(musics[playIndex].dataset.name)
      audio.src = musics[playIndex].dataset.url
      audio.play()
    }else{
      playControl()
    }
  }

  function preSong() {
    var index
    if(playIndex === 0){
      index = musics.length - 1
    }else{
      index = playIndex - 1
    }
    changePlayIndex(index)
  }

  function nextSong() {
    var index
    if(playIndex === musics.length - 1){
      index = 0
    }else{
      index = playIndex + 1
    }
    changePlayIndex(index)
  }

  function toggleMenu() {
    var mainLeft = $('.main-left')
    if(mainLeft.hasClass('active')){
      mainLeft.removeClass('active')
      $('.menu').removeClass('icon-close')
      $('.menu').addClass('icon-menu')
    }else{
      mainLeft.addClass('active')
      $('.menu').removeClass('icon-menu')
      $('.menu').addClass('icon-close')
    }
  }
</script>
